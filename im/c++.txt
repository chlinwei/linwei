
------------------------------
一 C++语言概述
1 C++历史背景
1.1 C++江湖地位
java、C、C++、python、C#...

1.2 C++之父：Bjarne Stoustrup(1950--)
1979，Cpre，为C语言增加类的机制
1983，Bjarne 发布全新编程语言C with class，后来命名为C++
1985，CFront 1.0，
          《The C++ programming Language》

1.3 发展过程
1987，GNU C++
1990，Borland C++（BC编译器）
1992，Microsoft C++
            Microsoft visual C++（VC，VC++）
1998，ISO C++98
2003，对C++98进行修订，C++03
2011，ISO C++2011/C++0X
2014，ISO对C++做了部分扩展，即C++14
据说2017，C++2017

2 应用领域
2.1 游戏
2.2 科学计算(Fortain)
2.3 网络通信（ACE）
2.4 操作系统和设备驱动
...

3 C和C++
3.1 都是编译型语言
3.2 强类型语言
  C++具有比C更加严格的类型检查机制
3.3 C++去除了C不好的特性
3.4 C++增加了C语言没有的好的特性
    支持面向对象，操作符重载、异常处理、泛型编程..
3.5 C++比C更适合大型软件的开发
---------------------
二  第一个C++程序
1 编译方式
g++ first.cpp
gcc   first.cpp -lstdc++

2 文件扩展名
.cpp  .cc  .C  .cxx

3 头文件
 #include<iostream>
 所有与I/O有关的类型、对象、函数都在该头文件中声明

 标准C的头文件依然可以使用。
 #include <stdio.h> <==>#include <cstdio>

4 输入和输出
 用cin对象表示标准输入
 用cout对象表示标准输出

三 名字空间
1 定义名字空间
namespace 名字空间名{
    名字空间成员1；
    名字空间成员2；
    ...
};
名字空间的成员可以是变量、函数、类型、名字空间；
namespace ns1{
   int x;
   void foo(void){...}
   struct Student{...};
   namespace ns2{...}
}
2 名字空间成员使用
1）通过作用域限定符"::"
  名字空间名::要访问成员
  ns1::x = 100;

2）名字空间指令
      using namespace 名字空间名；
      在该指令以后的代码中，指定名字空间中的成员都可见，访问其中的成员可以省略作用域限定。

3）名字空间声明
 using 名字空间名::名字空间成员
 将名字空间中的特定成员引入到当前作用域，在该作用域访问这个成员就如同访问自己的成员一样，可以省略作用域限定。

3 无名名字空间
不属于任何名字空间的标识符，将被编译器划分到无名名字空间中。
::标识符

4 嵌套名字空间
namespace ns1{
     int x = 10;
     namespace ns2{
           int x = 20;
           namespace ns3{
	int x = 30;
           }
     }
}
cout << ns1::x << endl;//10
cout << ns1::ns2::x << endl;//20
cout << ns1::ns2::ns3::x << endl;//30

四 C++结构体、联合体和枚举
1.C++结构体
1）定义结构体变量，可以省略struct关键字
2）结构体可以定义函数，称为成员函数，在成员函数中可以直接访问成员变量。

2.C++联合体
1）union关键字可以省略
2）支持匿名联合

3.C++枚举
1）enum关键字可以省略
2）C++枚举是一种独立的数据类型，而C中枚举本质就是整型数。
    enum COLOR｛RED,GREEN,BLUE｝;
    COLOR c;
C语言中:  c = 100;//ok
C++中:   
       c  = 100;//error
       c  = RED;//ok
五 字符串
1.C中字符串：双引号字面值，字符指针，字符数组。
printf("hello world!");
char* p = "Hello World";
char s[] = "HELLO WORLD"；

strcpy(p,"12345678");//error
strcpy(s,"123456789123456789");//ok
p = "12345678";//ok
s = "12345678";//error

char arr[100];
arr[0] = 'h';
arr[1] = 'e';
arr[2] = 'l';
arr[3] = 'l';
arr[4] = 'o';
cout << arr << endl;//hello

2 C++兼容C的字符串同时，增加string类型，专门表示字符串的。

六 C++的布尔类型
1 bool类型是C++中的基本数据类型，专门表示逻辑值
2 bool在内存中占一个字节：1表示true，0表示false
3 bool类型变量可以接收任意类型的表达式，其值非0则为true，零则为false。

七 C++字符形式的运算符(了解)
&&   --  and
||       --  or
^       --  xor
{        -- <%
}        --  %>
!        --  not
!=      --  not_eq
......

八、C++的函数
1. 函数重载
    draw(int x,int y,int r){...}
    draw(int x,int y,int w,int h){...}
1)函数重载的定义
   在相同作用域中，定义同名的函数，但是它们的参数表必须有所区分，这样的函数构成重载关系。
   重载与函数的返回类型无关，与参数名也无关，而只与参数的个数，参数类型和顺序有关。

八、C++的函数
1. 函数重载
1)函数重载的定义
   在相同作用域中，定义同名的函数，但是它们的参数表必须有所区分，这样的函数构成重载关系。
   重载与函数的返回类型无关，与参数名也无关，而只与参数的个数，参数类型和顺序有关。

2)调用重载函数时，编译器根据实参与形参的匹配程序，自动选择最优的重载版本。
g++编译器的一般规则：
    完全匹配>常量转换>升级转换>降级转换>省略号匹配

3)函数重载原理
   C++编译器通过对函数进行换名，将参数表的信息整合到函数名中，实现解决函数重载与名字冲突的矛盾。
   函数声明中加入extern "C”要求C++编译器不对函数做换名，便于C程序调用该函数。
  extern "C" void func(..){...}
  extern "C"{
        void func1(...);
        void func2(...);
  }

2. 函数的缺省参数
1）可以为函数的部分或全部参数指定缺省值，调用该函数时，如果不给实参，就取缺省值作为相应的形参值。
void func(int a,int b,int flag=缺省值)｛｝
void func(int a,int b,int flag=0)｛...｝
int main(){
   func(10,20);
}
2）缺省参数必须靠右，如果一个参数有缺省值，那么这个参数右侧的所有参数都必须带有缺省值。
void func(int a = 10,int b){}//error
void func(int a = 10,int b = 100 ,int flag = 0)｛...｝
3）如果函数的定义和声明分开，缺省参数应该写在函数的声明部分，而定义部分不写。
  void func(){} -->函数的定义
  void func();   -->函数的声明

3.函数的哑元参数
1）只有类型没有变量名的形参称为哑元
void func(int){...}
2）为了兼容旧代码
算法库:void math_func(int a,int b){...}
使用者:
int main(){
    math_func(num1,num2);
    ...
    math_func(num1,num2);
}
---------
升级算法库:
void math_func(int a，int/*哑元*/){...}
int main(){
    math_func(num1,num2);
    ...
    math_func(num1,num2);
}
3）运算符函数重载:区分前后++、-- //后面讲

4. 内联函数
    使用inline关键字修饰的函数，表示这个函数是内联函数，编译器会尝试做内联优化，避免函数调用的开销。
1）多次调用的小而简单函数适合内联
2）调用次数极少或者大而复杂的函数不适合内联
3）递归函数不适合内联
4）内联只是一种建议不是要求，能否内联取决于编译器，有些函数不加inline关键字也会被编译器默认处理为内联
for(int i=0;i<10000;i++)
    for(int j=0;j<100;j++){...}
for(int i=0;i<100;i++)
    for(int j=0;j<10000;j++){...}
=====================
九、C++动态内存分配
C语言：malloc()/free()
C++中：new/delete 运算符
new运算符用于动态内存的分配，delete运算符用于动态内存的释放。
C语言:
      int *p = (int*)malloc(sizeof(int));
      *p = 100;
      free(p);
C++:
      int *p = new int(200);
      //*p = 200;
      delete  p;

     int* pa = new int[10];
     pa[0] = 10;
     pa[1] = 20;
     ....
     delete[] pa;

十、C++的引用（Reference）
1 定义
   引用就是某个变量的别名，对引用的操作与对该变量操作完全相同。
   int a = 10；
   int& b = a；//b就是a的别名
   b++；//等价于a++
   cout  <<  a  << endl;//11

2 常引用
1）定义引用时加const修饰，即为常引用，不能通过常引用修改引用的目标。
int a = 100;
const  int&  b = a;//b就是常引用
a = 200；//ok
b = 200;  //error
2）普通的引用只能引用左值，常引用既可以引用左值也可以引用右值。
int& b = a;//ok,a是左值
int& b = 10;//error,字面值常量10是右值
const int& r = a；//ok
const int& r = 10;//ok
3）关于左值和右值
左值：可以放在赋值运算符的左边，可以修改，可以被取地址。
    int i;
    i = 10;
    ++i;
    int* p = &i;
右值：只能放在赋值运算符右边的、不可以被修改，不可以被取地址。
   字面值都是右值：
	10 = i; --10;int* p = &10;//error
表达式值多为右值：
	a + b = c；//error
	(a + b)++;//error
                 int* p = &(a+b);//error
函数的返回值：
	int func(void){
	     int a=100;
	     return a;	
	}
	int main(){
	     int res = func();
                      func() = 10;//error
	    ++func();//error
                      int* p = &func(); //error
	}

2 引用型函数参数
1）引用用于函数的参数，可以修改实参的值，可以减小函数调用的开销，避免虚实结合过程中对实参的复制。
2）引用参数可能意外修改实参的值，如果不希望修改实参本身，可以将形参定义为常引用，提高传参的效率同时还可以接收常量型的实参。



十、C++的引用（Reference）
1.
2.
3.
4 引用型函数返回值
1）可以将函数返回类型声明为引用，避免函数返回值带来的内存开销，如果一个函数返回类型被声明为引用，那么该函数的返回值就是一个左值。
2）为了避免在函数外部修改 引用的目标变量，可以为引用附加常属性。
3）不要从函数返回局部变量的引用，因为所引用的内存会在函数返回以后被释放。
4）可以在函数中返回成员变量，静态变量，全局变量。

5.引用和指针
1）引用的本质就是指针
double d = 1.23；
double& rd = d;--》double* const pd = &d；
*pd <==> rd
---------------------
2）指针可以不做初始化，其目标在初始化以后可以随意修改，而引用必须初始化，且一旦初始化所引用的目标不能再改变。
int a,b;
int* p;
p = &a;//p指向a
p = &b;//p指向b

int& r；//error
int& r = a;//r引用a
r = b；//将b的值赋值给a

3）可以定义指针的指针(二级指针)，但是不能定义引用的引用。
int a；
int* p = &a；
int** pp = &p；//ok

int& r = a；
int&& rr = r；//error,C++2011中叫右值引用

4）可以定义指针的引用，但是不能定义引用的指针
int a；
int* p = &a；
int*& rp = p；//ok

int& r = a;
int&* pr = &r;//error

5）可以定义指针数组，但不能定义引用数组
int a，b，c；
int* parr[3]={&a,&b,&c};//ok
int& rarr[3]={a,b,c};//error

6)可以定义数组的引用
int arr[3] = {1,2,3};
int (&rarr)[3] = arr;//ok
//int (*parr)[3] = &arr;//ok

7)和函数指针一样，可以定义函数的引用，其语法特征与指针完全相同。
void func(int a,int b){}
int main(void){
    void (&rfunc)(int,int) = func;//ok
    rfunc(100,200);//ok
}

*8)指针和引用符号停靠
int *p;
int * p;
int* p;//good

int *p,*q;//good
int* p,*q;
---------------
int a = 10;
int& b = a;//good
int & b = a;
int &b = a;

int c = 20;
int &b = a,&d = c;//good
int& b = a,&d = c;
---------------
十一  类型转换
1 隐式类型转换
   char <--> int
   int <--> double
   int* --> void*
   int a=100;
   void *pv = &a;//ok
   int *pi = pv;//error

2 显示类型转换
2.1 强制类型转换
  int -> char
  char c = 'A';
  int i = (int)c;//C中形式
  int i = int(c);//C++风格形式
2.2 C++增加了四种操作符的形式
1）静态类型转换
     目标类型变量=static_cast<目标类型>(源类型变量)
     主要用于将void*转换为其它类型的指针。
     int a;
     void* pv = &a;//隐式
     int* pi = static_cast<int*>(pv);//静态转换

     double* <--> int*//不能隐式，不能静态
2）动态类型转换（后面讲）
  目标类型变量=dynamic_cast<目标类型>(源类型变量)
3）常类型转换
  目标类型变量=const_cast<目标类型>(源类型变量)
  主要用于去除一个指针或引用的常属性。
  const int a = 10；
  const int* p = &a；
  *p = 20;//error
  int* p2 = const_cast<int*>(p)
  *p2 = 20;//ok

  const int& r = a;
  r = 30;//error
  int&  r2 = const_cast<int&>(r);
  r2 = 30;//ok

4）重解释类型转换
  目标类型变量 =
	reinterpret_cast<目标类型>(源类型变量)
  a.任意类型的指针或引用之间进行转换。
  b.在指针和整型之间的转换。

小结：C++之父给C程序员的建议
1.慎用宏，代之const\enum\inline
#define PAI  3.14 
  -->const double PAI = 3.14;
#define  STATE_SLEEP  0
#define  STATE_RUN    1
#define  STATE_STOP   2
  -->enum STATE{SLEEP,RUN,STOP};
#define max(a,b) ((a)>(b)?(a):(b))
  -->inline int max(int a,int b){
	return a>b?a:b;
       }

2 变量随用随声明同时初始化

3 尽量用new/delete取代malloc/free

4 少用void*、指针计算、联合体和强制转换

5 尽量用string表示字符串，少用C风格的char*

================================
十二 类和对象
1，对象
万物皆对象，任何一种事物都可以看作是对象。

2，面向对象
2.1 如何描述对象
      通过对象的属性(名词、形容词、数量词)和行为(动词)表达对象。
冰箱属性：品牌、容量、颜色、功耗
冰箱行为：装东西、冷冻、冷藏..

2.2 面向对象的程序设计
    对自然界的观察引入到编程实践中的一种理念和方法
    这种方法得益于“数据抽象”，在描述对象时把细节的东西剥离出去，只考虑一般性，有规律性的，统一的东西

3 类
     类是将多个对象共性提取出来 定义的一种新的数据类型，是对 对象的属性和行为的抽象描述，对象是类的实例化。
       属性   行为
狗    犬种   进食
       犬龄   睡眠
       体重   玩耍
       毛色  

十三 类的定义与实例化
1 类的一般形式
class/struct 类名:继承方式 基类{
访问控制限定符:
     类名(形参表):初始化表{//构造函数
          //函数体
     };        
     ~类名(void){//析构函数
          //函数体
     }
     返回类型 函数名(形参表){//成员函数
           //函数体
     }
     数据类型  变量名;//成员变量
};

学生：
       属性      行为
       名字      吃饭
       年龄      睡眠
       学号      学习

2 访问控制限定符
public：公有成员，谁都可以访问该成员,不能通过类名直接访问A::m_data;
private：私有成员，只有自己可以访问该成员
protected：保护成员。//后面讲
在C++类中class和struct没有本质的区别，唯一不同在于class的缺省访控属性为私有，而struct的访控属性为公有





十三 类的定义与实例化
1
2
3 构造函数（Constructors）
类名(构造形参表)[:初始化表]{
     //构造函数体;
}
1）构造函数名与类名相同，且没有返回类型
2）构造函数在对象创建时自动被调用
3）构造函数负责确定对象初始化状态以及分配必要的内存
4）构造函数在每个对象的整个声明周期内，一定会被调用，且仅会被调用一次。

4 对象的创建和销毁
1）在栈中创建单个对象
类名 对象(构造实参表)；
类名 对象 = 类名(构造实参表)；

2）在栈中创建多个对象
类名 对象数组[元素个数] = {类名(构造实参表),...}

3) 在堆中创建/销毁单个对象
创建:
     类型* 对象指针 = new 类名(构造实参表)；
销毁：
    delete 对象指针
4）在队中创建/销毁多个对象
创建：
    //这种初始化的写法，只在c++2011支持
    类名* 对象指针 = new 类名[元素个数]{类名(参数),...}
销毁：
    delete[]  对象指针

5 类的声明和定义可以分别放在不用的文件中
类声明部分放在xx.h
类实现部分放在xx.cpp
使用该类的代码通过在其它的XX.cpp中

===========
实现一个电子时钟类，要求用构造接收当前的系统时间，以秒为单位运行。
1）属性：时、分、秒
2）行为：
构造函数初始化时间
    time_t  t = time(NULL);
    tm* local=localtime(&t);
    local->tm_hour;
    local->tm_min;
    local->tm_sec;
成员函数运行时钟，
    while(1){
         //打印时间；
         //计时：时间+1秒
    }；

十四 构造函数和初始化表
1 构造函数重载
  构造函数通过参数表的差别化形成重载，创建对象通过构造实参选择匹配，表示不同对象的创建方式。

2 缺省构造函数
如果一个类没有定义构造函数，编译器会提供一个缺省构造函数(无参构造函数)，使成员变量获得定义。
1)对于基本类型的成员变量不初始化
2)对类 类型的成员 变量，调用相应类型的无参构造函数。
3)如果定义了构造函数，无论是否有参数，编译器都不会再提供无参构造函数。

3 类型转换构造函数(单参构造函数)
class 目标类型{
     目标类名(源类型  src){...}
};
使用explicit关键字修饰类型转换构造函数，可以强制这种转换必须显示地进行。

4 拷贝构造函数
类名 (const 类名& that){...}
1）用一个已经存在的对象构造同类型的副本对象时，会调用该类的拷贝构造函数
class A{..};
A a1;//无参方式构造
A a2=a1;//拷贝方式构造

2）如果一个类没有定义拷贝构造函数，那么编译器会为其提供一个缺省拷贝构造函数
 a，对基本类型的成员变量，按字节复制
 b，对类类型的成员变量(成员子对象),调用相应类型的拷贝构造函数。

3）如果自己定义拷贝构造函数，编译器将不再提供缺省拷贝构造函数，这时要实现成员复制有关操作，必须在自己
定义的拷贝构造函数中编码完成。

4）拷贝构造函数调用时机
 a.用已经定义对象作为同类型对象的构造实参
 b.以对象的形式向函数传递参数。
 c.从函数中返回对象(有时会被编译器优化掉)
   



十四 构造函数和初始化表
1
2
3
4
5 构造函数初始化表
1)指明类中成员变量的初始化方式
  类名(形参表):成员变量1(参数1),成员变量2(常量)..{
      构造函数体;
  }
2)必须要使用初始化表的地方
a.如果有类 类型的成员变量，而该类又没有无参构造函数，则必须通过初始化初始化该成员变量。
b.类中包含"const"和引用"&"成员变量，必须在初始化表中显示的初始化。
c.成员变量初始化顺序由声明顺序决定，而与初始化表的顺序无关。

练习：修改时钟类，要求使用初始化表，为时钟类增加计时器的功能。

十五 this指针与常函数
1.this指针
1）类的构造函数和成员函数中都隐藏一个该类类型的指针参数，名为this。
    a.对于普通的成员函数，this指针就是指向调用该函数的对象。
    b.对于构造函数，this指针就是指向这个正在被构造的对象。

2）this指针可以显示的使用，需要显示使用this指针的地方：
   a.区分作用域
   b.从成员函数中返回对象自身(自引用)
   c.从类的内部销毁对象自身(自销毁)
   d.作为函数的实参，从一个对象传递给另一个对象，实现对象间的交互。

2 常函数
1）在一个成员函数参数表后面加const，这个成员函数就称为常函数。
   返回类型  函数名(形参表) const{函数体}
2）常函数中this指针是一个常指针，不能在常函数中修改该成员变量的值。
3）被mutable关键字修饰的成员变量可以在常函数中被修改
4）非常对象可以调用常函数，可以调用非常函数，但是常对象只能调用常函数，不能调用非常函数。
5）函数名和形参表相同的成员函数，其常版本和非常版本可以构成重载关系，常对象调用常版本，非常对象调用非常版本

十六 析构函数(Destructor)
1 析构是类的特殊的成员函数
 class 类名{
    ~类名(void){...}//析构函数
 };
 1）函数名必须“~类名”
 2）没有返回类型，也没有参数
 3）不能被重载，一个类只能有一个析构函数
 4）主要负责清理对象生命周期内动态产生的资源

2.当对象被销毁时，该对象的析构函数自动被执行
1）栈对象离开作用域时，其析构函数被作用域终止右花括号"}"调用；
2）堆对象的析构函数被delete运算符调用。

3 如果一个类没有显示定义析构函数，那么系统会为该类提供一个缺省析构函数：
1）对基类类型的成员变量，什么也不做；
2）对类 类型的成员变量，调用相应类的析构函数，析构成员子对象。

4 对象的创建和销毁的过程
1）对象的创建
   -->为对象分配内存
   -->按声明顺序依次调用成员子对象的构造函数
   -->执行构造函数体的代码
2）对象销毁
   -->执行析构函数的代码
   -->按声明逆序依次调用成员子对象的析构函数
   -->释放对象所占的内存空间

十七  拷贝构造和拷贝赋值
1 浅拷贝和深拷贝
    如果一个类包含指针形式的成员变量，缺省拷贝构造函数只是赋值指针成员变量本身，而没有复制该指针所指向的内容，这种拷贝构造被称为浅拷贝。
    浅拷贝将导致不同对象间的数据共享，同时会在析构函数中引发"double free"异常，为此必须自己定义一个支持深拷贝的拷贝构造函数。

2 类的缺省拷贝赋值函数和缺省拷贝构造类似，是浅拷贝，为了得到深拷贝的赋值效果，就必须自己定义一个支持深拷贝赋值的运算符函数。
1）防止自赋值
2）释放旧资源
3）分配新资源
4）拷贝新数据
5）返回自引用


作业：实现
          class  String｛
          public:
	构造函数；
	析构函数；
	深拷贝构造；
	深拷贝赋值；
                 访问m_str的接口函数：
          private:
 	char* m_str;
         ｝;
         int main(){
	 String s1("hello world");
                  String s2=s1 ;//拷贝构造
                  String s3;
	 s3 = s2 ;//拷贝赋值
         }




十八 静态成员
C语言：static
      a.修饰局部变量
      b.修饰全局变量 
      c.修饰函数
1 静态成员变量
class 类名{
    static 数据类型 变量名;//声明
};
数据类型  类名::变量名 = 初值;//定义及初始化
1）非静态成员变量属于对象，静态成员变量属于类
2）不能在构造函数中被定义和初始化，需要类的外部单独定义并初始化。
3）可以通过类名直接访问，也可以通过对象访问。
4）静态成员变量在该类的多个实例对象间共享。
5）静态成员变量存放在全局区。
6）静态成员变量使用受访控属性影响。

2 静态成员函数
1）可以通过类名直接访问，也可以通过对象访问
2）和普通成员函数一样受访问属性的约束
3）静态成员函数没有this指针，也没有const属性

3 静态成员函数只能访问静态成员；非静态成员函数既可以访问静态成员也可以访问非静态成员。
-----------
4 单例模式
1）禁止在外部创建对象：私有化构造函数
2）类自己维护唯一对象：静态成员变量
3）提供访问该对象的方法: 静态成员函数
4）创建方式
     饿汉式 : 无论用不用，程序启动创建
     懒汉式 : 用的时候创建，不用时即销毁
------------------
------------------
十九  成员指针
1.成员变量指针
1）定义
类型 类名::*成员指针变量名 = &类名::成员变量;
Student s;
string* p = &s.name;//普通指针
string Student::*panme = &Student::name;
2)赋值
指针名 = &类名::成员变量名
3)使用
对象.*成员指针变量名；
对象指针->*成员指针变量名；
2.成员函数指针
1）定义：
  返回类型 (类名::*成员函数指针)(形参表) 
		  = &类名::成员函数名；
2)赋值
  成员函数指针 = &类名::成员函数名
3）使用
  (对象.*成员函数指针)(实参表)
  (对象指针->*成员函数指针)(实参表)

3.静态成员指针与普通指针在定义、使用和语义没有任何区别。
====================
二十  操作符重载
复数
3+4i；
（1+2i）+ （3+4i） = (4+6i)
 c1.add(c2)
1 双目操作符 L#R
1.1 运算类的双目操作符：+ - *  /  %...
  a.左右操作数可以是左值，也可以是右值
  b.表达式的值为右值
1）成员函数形式
  L#R的表达式会被编译器处理L.operator#(R)的成员函数调用，该函数的返回值即为表达式的值。
2）全局函数形式
  L#R的表达式也可以被编译器处理为::operator#(L,R)的全局函数调用，该函数的返回值就是表达式的值
3）通过friend关键字，可以把一个全局函数声明为某个类的友元，友元函数可以访问类当中的任何成员。
   
1.2 赋值类的双目操作符
   a.左操作数是左值不能是右值(常量)，右操作数可以是左值也可以是右值。
   b.表达式的值是一个左值，而且他就是左操作数的本身
1）成员函数形式
    L.operator#(R)
2）全局函数的形式
    ::operator#(L,R)

2 单目操作符#O
  -  ~ ！ ...
2.1 计算类单目操作符
1）成员函数形式
   O.operator#();
2）全局函数形式
   ::operator#(O);
2.2 自增减单目操作符
1）前缀自增减
int a = 10;
(++a) = 10;//ok
操作数是左值(可修改)，返回值就是操作数自身也是左值.
成员函数形式:
    O.operator#()
全局函数形式:
   operator#(O)
2）后缀自增减
int a = 10;
int res = a++;
(a++) = 20;//error
10++;
printf("%d\n",a);
操作数是左值(可修改)，返回值就是操作数副本，是右值.
成员函数形式:
    O.operator#(int)
全局函数形式:
   operator#(O，int)
============
3 其它操作符重载


-----------------
#include<iostream>
#include<stdarg.h>
int ripple(int, ...);
int main(void)
{
    int num;
    num = ripple(3, 5, 7);
    cout << num << endl;
}
int ripple(int n, ...)
{
    int i, j = 1, k = 0;
    va_list p;
    va_start(p, n);
    for( ; j < n; ++j)//循环2次
    {
        i = va_arg(p, int);//i = 7
        for( ; i; i &= i-1) // 100 & 011 = 0
        {
           ++k;//+1+1+1+1+1
        }
    }
    return k;  //5
}

 



二十  操作符重载
1 ..
2 ..
3 其它操作符重载
3.1 插入/提取操作符： << >>
cout << a << b << endl;
cin >> a;
ostream cout;
istream cin;

friend ostream& operator<<(ostream& os,const RIGHT& right){}
friend istream& operator>>(istream& is,RIGHT& right){}

3.2 下标操作符: []
class A {
int *m_a;
};
A a(10);
a[0] = 10;//a.operator[](0) -> a.m_a[0] = 10

int arr[5] = {1,2,3,4,5};
arr[0] = 10;
const int (&r)[5] = arr;
r[0] = 10;//error

*3.3 函数操作符:()
func();
A a;
//a.operator()(...)
a(...);//实现类的对象可以当作函数来调用

3.4 解引用和间接成员访问操作符： *  ->
A a;
*a=
a->
用于实现智能指针：一个封装常规指针的类类型对象。

3.5 类型转换操作符
1）通过构造函数实现自定义类型转换
   基本类型 --> 类 类型
   类 类型 --> 类 类型
2）通过类型转换操作符函数实现实现自定义的类型转换
   类 类型-->基本类型
   类 类型 --> 类 类型
   operator 目标类型(void)const{...}
3)两个基本类型不能实现自定义转换

3.6 new/delete操作符
static void* operator new(size_t size){...}
static void opetator delete(void* p){...}

4 操作符重载的限制
1）下列操作符不能重载：
作用域限定操作符 "::"
直接成员访问操作符 “.”
直接成员指针解引用操作符 ".*"
条件操作符“?:”
字节长度操作符“sizeof”
	int a = 100;
	sizeof(a+3.14);//8
	sizeof(a = a+3.14);//4
	cout << ａ＜＜endl;//100
类型信息操作符“typeid”//后面讲

2）如果一个操作符的所有操作数都是基本类型，则无法重载。
    int operator+（int a,int b）{//error
	return a - b;
    }

3）操作符重载不会改变编译器预定义的优先级.

4）操作符重载无法改变操作数的个数。

5）无法通过操作符重载发明新的操作符
  double operator@（double a）｛//error
	return a*a;
｝

===========
二十一  继承（Inheritance）
1 继承的基本概念
    通过一种机制表达类型之间共性和特性的方式，利用已有数据类型定义新的数据类型，这种机制叫做继承。
  
  人类：姓名、年龄、吃饭、睡觉
  学生类：姓名、年龄、学号 、吃饭、睡觉、学习
  教师类：姓名、年龄、工资、吃饭、睡觉、授课

  人类：姓名、年龄、吃饭、睡觉
  学生继承人类：学号、学习
  教师继承人类：工资、授课

	人类(基类、父类)
               /       \
         学生类    教师类(派生类、子类)         
         基类派生子类，子类继承基类。
2 继承的语法
class 子类：继承方式1  基类1，继承方式2 基类2...{
         ...
};
class Human{
public:
   void sleep(){..}
   void eat(){..}   
private:
   string name;
   int age;
};
class Student:public Human{
  //Student类继承Human类，Student类中存在一份human类中成员。
};
继承方式:
    共有继承：public
    保护继承：protected
    私有继承：private

3 继承的特性（public）
3.1 任何时候子类对象可以看作是基类对象
Student s；
s.eat（）
s.sleep（）

3.2 向上和向下造型
1）向上造型：将子类 类型的指针或引用转换 为基类 类型的指针或引用。这种操作性缩小的类型转换，在编译器看来是安全的，可以隐式转换。
2）向下造型：将基类 类型的指针或引用转换 为子类 类型的指针或引用。这种操作性放大的类型转换，在编译器看来不不安全的，必须显示转换。

3.3 子类继承基类的成员
1）在子类中或者通过子类，可以直接访问基类中的共有和保护成员，如同它们是在子类中声明的一样。

2）基类的成员在子类中虽然存在但是不可见，所以无法直接访问，但是可以通过基类提供的共有或者保护的接口函数间接访问。

3）基类的构造函数和析构函数，子类无法继承，但是可以在子类自己的构造函数中通过初始化表，显示指明基类部分(基类子对象)的初始化方式。
===========
作业一 ：实现一个3X3矩阵，支持如下操作符
+ - "*" += -=  -(负) ++(前后)  --（前后） []  <<
operator[]
int m_a[3][3];
1 2 3      	9 8 7       	10  10  10
4 5 6  +  	6 5 4  =   	10  10  10
7 8 9      	3 2 1       	10  10  10
 
1 2 3      	9 8 7       	 30    24  18
4 5 6  *  	6 5 4  =   	 84    69  54
7 8 9      	3 2 1       	 138  114  90

作业二：读懂继承的案例




二十一  继承（Inheritance）
1
2
3 继承的特性（public）
...
3.4 子类隐藏基类的成员
1）子类和基类中定义同名的成员函数，作用域不同，不能构成重载关系，而是一种隐藏关系。如果需要在子类中访问所隐藏的成员函数可以借助作用域限定操作符"::"显示指明。
2）通过using声明可以将基类的成员函数引入子类的作用域形成重载。

4 继承方式和访问控制限定
4.1 访问控制
访问控制	   访问控制      内部       子类       外部       友元	
限定符          属性             访问       访问       访问       访问
public          公有成员      ok          ok         ok         ok
protected    保护成员      ok          ok         no         ok  
private         私有成员      ok         no         no         ok

4.2 继承方式
基类中的	在公有子	在保护子     在私有子
                 类中变成    类中变成     类中变成
公有成员    公有          	保护 	 私有
保护成员    保护          	保护	 私有
私有成员    私有	私有	 私有	

4.3 私有子类和保护子类类型的指针或引用，不能转换为其基类的指针或引用。

5 子类的构造和析构
5.1 子类构造函数
1）如果子类的构造函数没有显示指明其基类子对象的初始化方式，那么编译器会选择调用基类的无参构造函数初始化该子对象。
2）如果希望子类对象的基类部分以有参的方式被初始化，就需要在子类的构造函数的初始化表中(而不是函数体)显示说明其基类子对象的初始化方式。
3）子类对象的构造过程
   ->分配内存
   ->构造基类子对象(按继承表的顺序)
   ->构造成员子对象(按声明顺序)
   ->执行子类的构造函数体代码
   //析构过程和构造正好相反

5.2 子类的析构函数
1）子类的析构函数，会自动调用其基类的析构函数，析构基类子对象。
2）基类的析构函数不能调用子类的析构函数。
     对一个指向子类对象的基类指针使用delete运算符，实际被调用的是基类的析构 函数，该函数没有调用子类的析构函数，所释放的仅仅基类子对象中的动态资源，子类特有的动态资源将形成内存泄漏。

6 子类的拷贝构造和拷贝赋值
6.1 子类的拷贝构造
1）子类没有定义拷贝构造函数，编译器为子类提供缺省的拷贝构造函数，该函数会自动调用基类的拷贝构造函数，初始化基类子对象。
2）子类定义了拷贝构造函数，但是没有显示指明对基类的拷贝构造，子类对象中的基类子对象将以无参方式初始化。
3）子类定义了拷贝构造函数，同时显示指明对基类拷贝构造，基类子对象将以拷贝方式做初始化。

6.2 子类的拷贝赋值
1）子类没有定义拷贝运算符函数，编译器提供缺省拷贝赋值运算符函数，自动调用基类的拷贝赋值运算符函数，复制基类子对象
2）子类定义了拷贝赋值运算符函数，但是没有复制基类部分，基类子对象保持赋值之前的状态。
3）子类定义了拷贝赋值运算符函数，同时也复制了基类部分，基类子对象也会得到赋值。

*7 子类的操作符重载
    在为子类提供操作符重载函数时，可以调用调用基类针对该操作符的重载定义，完成部分工作。

8 多重继承
8.1 一个子类同时继承多个基类，这样继承方式叫做多重继承。

电话    播放器    计算机
   \         |         /
        智能手机

8.2 将继承自多个基类的子类 类型指针，隐式或静态转换为基类类型，编译器会根据各个基类子对象在子类对象中的内存布局，进行适当的偏移计算，保证指针的类型与其所指向的目标类型一致。

8.3 名字冲突问题
1）一个子类的多个基类中存在相同的名字，当通过子类访问这些名字时，编译器会报歧义错误--名字冲突。
2）解决名字冲突的一般做法就是显示地通过作用域限定指明所访问的名字继承自哪个基类。
3）如果产生冲突的名字是成员函数并且满足重载的条件，可以通过using声明，在子类中形成重载关系，通过重载解析解决冲突问题。

8.4 钻石继承
     A
   /   \  
  B    C 
   \   /  
     D



二十一  继承（Inheritance）
......
8.4 钻石继承
     A
   /   \  
 B     C 
   \   /  
    D
1）一个子类的多个基类源自共同的基类祖先，这样的继承结构被称为钻石继承。
2）派生多个中间子类(B/C)的公共基类(A)子对象,在继承自多个中间子类的汇聚子类(D)对象中,存在多个实例。在汇聚子类中，或通过汇聚子类对象，访问公共基类的成员，会因继承路径的不同导致不一致。
3）通过虚继承让公共基类子对象在汇聚子类对象中的实例唯一，并为所有的子类共享。

8.5 虚继承语法
1）在继承表中使用virtual关键字。
2）虚基类(A)的所有子类（无论是直接的还是间接的）都必须在其构造函数中显示指明该虚基类子对象的构造方式，否则编译器将以缺省方式构造该子对象。
3）位于继承链的最末端子类的构造函数负责构造虚基类子对象。

练习：实现B、C、D类拷贝构造和拷贝赋值

============================
二十二 多态(Polymorphic)
            图形(位置/绘制)
          /                      \
  矩形(长和宽/绘制)    圆形(半径/绘制)
1 多态概念
     如果将基类中的某个成员函数声明为虚函数，那么其子类中与该函数具有相同原型的成员函数就也是虚函数，并且对基类中的版本形成覆盖。
     这时通过指向子类对象的基类指针，或者引用子类对象的基类引用，调用虚函数，实际被执行的将是子类中的覆盖版本，而不是基类中的原始版本，这种语法现象称为多态。

2 虚函数覆盖的条件
1）只有类的成员函数才能被声明虚函数，类的静态成员函数和构造函数不能被声明虚函数。
2）只有在基类中的以virtual关键字修饰的成员函数才能作为虚函数被子类覆盖，而与子类中virtual关键字无关。
3）虚函数在类中的覆盖版本必须和该函数在基类中的原始版本具有相同的函数签名，即函数名、形参表和常属性必须严格一致。
4）如果基类中的虚函数返回除类 类型的指针和引用以外的数据，那么该函数在子类中的覆盖版本必须返回相同类型的数据。
5）如果基类中的虚函数返回类类型的指针(A*)或引用(A&)，那么允许子类中的覆盖版本返回子类的指针(B*)或引用(B&)——类型协变
class A{};
class B:public A{};
*6)虚函数在子类中的覆盖版本和基类中的原始版本的访问控制属性没有必然联系。

3 多态条件
1）多态特性除了要在基类中声明虚函数，并在子类中提供有效的覆盖，还必须是通过指针或者引用来调用虚函数，才能表现出来。

2）调用虚函数的指针也可以是this指针，只要他是一个指向子类对象的基类指针，同样可以表现出多态性。

*3）当基类的构造被子类的构造函数调用时，子类对象尚未构造完成，不能说是子类类型的，它只能表现出基类类型的外观和行为。这时调用虚函数，只能被绑定到基类版本，没有多态特性。

*4）当基类的洗后函数被在子类的析构函数调用时，子类对象已经不再是子类类型，它只能表现出基类的外观和行为。调用虚函数，只能被绑定到基类版本，没有多态特性。

======================
//哪些函数可以声明成virtual？
成员函数  ok
静态成员函数  no
全局函数  no
构造函数  no
析构函数  ok
操作符重载函数   ok
=================
4 纯虚函数、抽象类和纯抽象类
4.1 纯虚函数
virtual 返回类型 函数名(形参表)[const] = 0;

4.2 抽象类
 1）一个类中包含了至少一个纯虚函数，这个类就是抽象类。
 2）抽象类不能实例化对象。
 3）如果子类没有覆盖其抽象基类中的全部纯虚函数，那么该子类就是一个抽象类，类的抽象的属性可以被继承。

4.3 纯抽象类
如果一个抽象类中除了构造和析构函数意外所有的成员函数都是纯虚函数，那么该抽象类就是一个纯抽象类。



 
二十二 多态(Polymorphic)
...
*5 多态实现原理（虚函数表和动态绑定）
1）编译器会为包含虚函数的类生成一张虚函数表，用来存放每个虚函数地址,简称虚表，每个虚函数对应虚表中的索引号。
2）编译器还会为包含数虚函数的类增加一个隐式的成员变量，用于存放虚函数表的首地址，该变量被称为虚函数表指针，简称虚指针。
3）所谓虚函数覆盖，其实就是用子类中的虚函数地址覆盖基类虚表中的虚函数地址。
4）当编译器看到通过指针或引用调用虚函数的语句时，不会生成有关函数调用的指令，而会用一段代码做替换，这段代码在运行阶段被执行，完成如下工作：
    a.确定调用指针或引用的目标对象的真是类型，并找到虚指针
    b.根据虚指针找到相应的虚表，并从中获取所调用虚函数的入口地址
    c.根据虚函数的入口地址执行虚函数代码。
    这个函数绑定的过程在运行阶段完成，因此被称为动态绑定。

6 动态绑定对性能的影响
1）动态绑定会增加内存的开销；
2）虚函数的调用会增加时间的开销；
3）虚函数不能被内联优化
如果没有多态的要求，最好不要使用虚函数

7 虚析构函数
如果将基类的析构声明为虚函数，那么子类的析构函数就也是一个虚函数，并且对基类的虚析构函数构成有效的覆盖，可以表现多态的特性。
这时delete一个指向子类对象的基类指针，实际被调用的将是子类的析构函数，子类析构会自动调用基类的析构函数，实现资源完美释放，避免内存泄漏的风险。
=================
实例：薪资计算
所有员工：姓名、工号、等级、基本工资
经理：绩效奖金
技术员：研发津贴(元/小时)
销售员：提成比率

薪资：基本工资+绩效工资
基本工资=等级额度*出勤率
绩效工资工资的计算因职务不同而异

绩效工资的具体计算方法
普通员工：基本工资的一般
经理：绩效奖金*绩效因数(输入)
*技术员：研发津贴*工作小时数*进度因数(输入)
销售员：销售额度(输入)*提成比率
*技术主管：(技术员绩效工资+经理的绩效工资)/2
销售主管：(销售员绩效工资+经理的绩效工资)/2

打印员工信息，输入必要数据，计算薪酬。
	员工
           /       |         \
   技术员     经理      销售员
        \      /     \      /
      技术主管     销售主管

=========================
二十三  运行时类型信息
1. typeid运算符
    typeid(类型/对象)，返回一个typeinfo类型对象的常引用。typeinfo中包含名为name(）成员函数，返回char*字符串,包含类型的信息。
    typeinfo类提供"==" "!="运算符的支持，通过它们直接进行类型之间的比较，如果在类型之间存在多态特性的继承关系，typeid还可以利用多态的特性确定实际对象类型。

2. 动态类型类型转换
   dynamic_cast主要用于具有多态特性的的父子类指针和引用之间的显示类型转换。
百度百科:dynamic_cast:将一个基类对象指针(或者引用)cast到继承类指针,
dynamic_cast会根据基类指针(引用)是否真正指向继承类指针来做相应的处理
	A
               /　＼　
　　　　Ｂ　  Ｃ　　　
Ａ* pa = &b;
B*  pb = pa;//显示转换
C*  pc = pa;//动态类型，error

  dynamic_cast在转换过程中，会检查目标对象和期望转换的对象是否一致，如果一致则转换成功，否则失败。如果转换的是指针，返回NULL表示失败，如果是引用抛出“bad_cast”异常表示失败。

=============================
二十四 异常（Exception）
1 常见错误
1）语法错误
2）逻辑错误
3）功能错误
4）设计缺陷
5）需求不符
6）环境异常
7）操作不当

2 传统的错误处理机制
1）通过返回值表示错误
优点：函数调用路径中所有的局部对象都能被右花括号正确地析构，不会有内存泄漏。
缺点：错误处理流程比较复杂，逐层判断，代码臃肿。

2）通过远跳机制处理错误
优点：不需要逐层的判断，实现一步到位的错误处理，代码精炼。
缺点：函数调用路径中的局部对象失去被析构机会，容易形成内存泄漏。



int (*m_arr)[3] = new int[a][3];//ok
int arr[3][3] = new int[3][3];//error
int **arr = new int*[3];//ok
int **arr = new int[3][3];//error






二十四 异常（Exception）
...
3.C++异常
      结合两种传统错误处理机制，同时避免它们的缺点，在形式上实现一步到位的错误处理，同时保证所有的局部对象得到正确的析构。

4. 异常语法
4.1 异常的抛出
     throw  异常对象
1）可以抛出基本类型的对象
   throw  -1;
   throw  "file open error";
2）可以抛出类 类型的对象
    FileException ex("file open error");
    throw  ex;
         ||
    throw  FileException("file open error");

4.2 异常的捕获
     try{
          //可能引发异常的语句
     }
     catch(异常类型1){
          //针对异常类型1的处理	
     }
     catch(异常类型2){
          //针对异常类型2的处理	
     }
     ...
     catch(...){
           //针对其它异常的处理
     }

4.3 catch子句根据异常对象的类型自上而下顺序匹配，而非最优匹配，因此对子类类型异常的捕获不要放在对基类类型异常的捕获后面。否则前者将被后者提前捕获。

4.4 建议在catch子句中使用引用接收异常对象，避免拷贝构造的性能开销，同时可以减少浅拷贝引发的风险。

4.4 标准异常类
class exception{
public:
     exception() throw(){}
     virtual ~exception() throw(){}
     virtual const char* what() const throw() {}
};
class Error:public execption{
    virtual const char* what() const throw() {}
};

Error ex;
exception& r = ex;
r.what();//调用子类的what函数

5 异常说明
1）可以在函数原型中增加异常说明，说明该函数所可能抛出的异常。
返回类型 函数名(形参表)throw(异常说明表){...}
void fun(const string& file,int size)throw(FileError,MemoryError)
2）函数的异常说明是一种承诺，表示该函数所抛出的异常不会超出说明的范围。如果不守承诺，抛出异常说明以外的异常类型，该异常无法被正常捕获，而会继续向上层抛出，最终被系统捕获，终止进程。
3）不写异常说明，表示可以抛出任何异常
4）空异常说明，throw(),表示不会抛出任何异常
5）如果函数的声明和定义分开，要保证异常说明类型一致。
6）如果基类中的虚函数带有异常说明，那么该函数在子类中的覆盖版本不能说明比基类版本抛出更多的异常，否则将因为"放松throw限定"导致编译失败。

6 构造函数和析构函数中的异常
1)构造函数抛出异常，对象将会被不完整构造，这样的对象其析构函数不会被执行。因此在构造函数抛出异常之前，需要手动销毁所有在异常产生之前动态分配的资源。
2)析构函数最好不要抛出异常，在析构函数中有引发异常的操作，都应该在析构函数内部消化掉.
class A{
    ~A(void){
         ...
         try｛
              throw ...
              ...
        ｝
         catch(){
         }
    }
};
int main(void)
{
     try{
           A a;
     }
     catch (){
            ....
     }
}

===========
二十五  I/O流
===========
C++ I/O流   istream/ostream
C语言 ---     fopen()/fread()/fwrite()...
I/O子系统    open() /read()
驱动程序      寄存器，中断控制...
I/O硬件      

		           ios
	               /                               \
                       istream                           ostream
                /         |              \                /        |          \         
   istrstream     ifstream      iostream     ofstream  ostrstream  
                                             /          \
                                    strstream    fstream
1.格式I/O
1)格式化函数：通过I/O对象的成员函数，改变或者获取其中的状态，进而影响格式化字符串的形式。
int  ios::precision(int);//设置浮点精度
int  ios::width(int);//设置显示域宽
long ios::setf(long);//添加格式标志位
...

2）流控制符：通过将流控制符对象插入输出流，或提取自输入流，改变其中的状态，进而影响格式化数据的形式。
setprecision(int);//设置浮点精度
endl；//换行
....

2 字符串流
#include <strstream>
istrstream 、ostrstream、strstrem
------------------------
#include <sstream>
istringstream、ostringstream、stringstream


3 文件流
#include <fstream>
ifstream \ ofstream \ fstream

构造函数：
ifstream(const char* filename,openmode mode)
ofstream(const char* filename,openmode mode)
fstream(const char* filename,openmode mode)
filename：文件路径包含文件名
mode：打开文件权限，缺省值可读可写可创建

通过成员函数打开I/O流
void open(const char* filename,openmode mode)

=========================
4 随机读写
istream& istream::seekg(off_type offset,ios::seekidr origin);
ostream& ostream::seekp(off_type offset,ios::seekidr origin);
origin:
   ios::beg  从文件头偏移
   ios::cur   从当前位置偏移
   ios::end  从文件尾偏移

5 二进制I/O（fread,fwrite,read,write）
ostream& ostream::write(const char* buffer,size_t num);
istream& istream::read(const char* buffer,size_t num);

===========================
GNU  make

Makefile：描述一个工程的编译连接等规则
make：根据Makefile生成可执行文件

目标：依赖
         命令.......
=============================

1.共有成员:
在任何情况下均可以访问
2.保护成员:
只能在类的内部及其之类的内部访问它,在类的外部不能访问
3.私有成员:
只能在类的内部访问它,其之类也不能访问,更别说在外部访问了

1.共有继承(public):
共有继承的特点是基类的共有成员函数和保护
成员作为派生类的成员时,它们都保持原有的状态
而私有成员仍然是私有的,不能被这个
派生类的之类所访问

2.私有继承(private):
私有继承的特点是基类的共有成员和
保护成员都作为派生类的私有成员,
并且不能被这个派生类的子类所访问

3.保护继承(protected):
保护继承的特点是所有的共有成员
和保护成员都成为派生类的保护成员,
并且只能被它的派生类成员函数或者
友元函数访问,基类的私有成员仍然是
私有的


在C++的世界中有这样两个概念,向上类型转换,
向下类型转换,分别描述的是
之类向基类和基类向子类的强制
类型转换
切割:覆盖方法和之类数据丢失的现象生成切割(slice)
class Base{
public:
int b;
virtual void Test()
{
cout << "base" << endl;
}
};
class Derived:public Base{
public:
int d;
virtual void Test(){
cout << "derived" << endl;
}
};
int main(void){
Derived d;
Base b = d;//直接赋值(产生切割)
b.Test();

Base& b2 = d;//使用引用赋值(不产生切割)
b2.Test();

Base* b3 = &d;//使用指针赋值(不产生切割)
b3->Test();
return 0;
}
结论:在向上强制转换过程中,使用指针或者引用不会
	造成切割,而使用直接赋值会造成切割


函数指针:
void Invoke(char* s);
int main(void){
	void (*fp)(char* s);//声明一个函数指针fp
	fp=Invoke;//将Invoke函数的入口地址赋值给fp
	fp("hello,world");
	return 0;
}
void Invoke(char* s){
	printf(s);
}
实际中为了方便,通常用宏定义的方法来
声明函数指针
typedef void (*FP)(char* s);
void Invoke(char* s);
int main(void){
	FP fp;//通常用宏来声明一个函数指针fp
	fp=Invoke;
	fp("hello,world");
	return 0;

}
void Invoke(char* s)  {
	printf(s);
}

函数指针数组
#include <iostream>
#include <string>
using namespace std;
typedef void (*FP)(const char* s);
void f1(const char* s){
	cout << s;
}
void f2(const char* s) {
	cout << s;
}
void f3(const char* s){
	cout << s;
}
int main(void){
	//void* a[] = {f1,f2,f3};//定义了指针数组,这里a是一个普通指针,而不是函数指针
	//a[0]("hello,world\n");//编译错误,类型不匹配a是一个普通指针数组,而成员是函数指针
	FP f[] = {f1,f2,f3};//f是一个函数指针
	f[0]("hello,world");//正确
	return 0;
}

回调函数
//定义回调函数
void PrintfText(){
	printf("hello,world");
}
void CallPrintfText(void (*callfuct())){
	callfuct();
}
int main(void){
	CallPrintfText(PrintfText);
	return 0;
}
带参数的回调样式
void PrintfText(const char* s) {
	printf(s);
}
//定义实现带参回调函数的"调用函数"
void CallPrintfText(viod (*callfunt)(const char*),const char* s);
int main(void){
	CallPrintfText(PrintfText,"hello,world");
	return 0;
}
