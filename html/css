一、文字
1.规定文字样式的属性
格式:font-style:italic;
取值:
normal:正常的,默认值
italic:倾斜的

2.规定文字粗细
格式:font-weight:bold;

单词取值:
lighter:细线,默认值
bold:加粗
bolder:比bold还要粗

数字取值:
100 ~ 900 之间整百的数字

3.规定文字大小的属性
格式:font-size:30px;
单位:px(像素pixel)

4.规定文字字体的属性
格式:font-family:"微软雅黑";
注意点:
1)如果取值是中文,需要用双引号或者单引号括起来
2)设置的字体必须是用户电脑里已经安装的字体 ，如果设置的字体
用户没有,那么用户会使用默认的字体来显示(宋体)
3)如果设置的字体不存在,而又不想用默认的字体来显示
格式:font-family: "字体1","备选方案1","备选方案2",...; 
4),中文字体可以处理英文,英文字体不能处理中文,
如果想给中文和英文分别设置单独的字体,那么英文字体必须写在中文前面
格式:font-family:"英文字体","中文字体";
5)在企业开发中最常用的字体:
中文:宋体/微软雅黑 
英文:Times New Roman/Arial
6)并不是字体名称是英文就一定是英文字体,因为中文字体其实都有自己的英文
名称,所以是不是中文字体,要看能不能处理中文

5.缩写:
格式:font: style weight size family;
注意点:
1)在缩写格式中有的属性值可以省略,style,weight可以省略
2)在缩写格式中,style和weight的位置可以交换
3)在缩写格式中,有的属性值不能省略,family和size不能省略
4)size和family的位置是不能随便乱放的,size一定要写在family的前面,size和family必须写在所有属性的最后


6.行高:除了边框,即padding+ height
规律:
1)文字在行高中默认是垂直居中的
2)在企业开发中经常将盒子的高度和行高设置为一样,那么这样就可以保证
一行文字在盒子的高度中是垂直居中的
3)企业开发中如果一个盒子中有多行文字,那么我们就不能设置行高来实现
让文字锤子居中,只能通过设置padding来让文字居中
4)在企业开发中,如果一个盒子中存储的是文字,那么一般情况下我们会以盒子
左边的内边距为基准,因为右边内边距会有误差,因为右边如果放不下一个文字,
那么文件就会换行显示.

二.文本

1.文本装饰属性
格式:text-decoration:underline;
取值:
underline:下划线
overline:上划线
line-through:删除线
none:什么都没有,最常见的用途就是去掉a标签的下划线

2.文本水平对齐的属性
格式:text-align:center;(文字图片居中)
取值:
left
right
center

3.文本缩进的属性
格式:text-indent:2em;
取值:
2em,其中em是单位,一个em表示缩进一个文字的宽度,2em缩进连个文字的宽度


三.颜色
格式:color:值;
取值:
1)英文单词:不是所有的颜色都能通过英文单词来表格
2)rgb:三颜色,r(red),g(green绿色),b(blue蓝色),数字值在0~255之间,0表示
不发光,255代表发光,值越大表示越亮
红色: rgb(255,0,0)
绿色: rgb(0,255,0)
蓝色: rgb(0,0,255)
黑色: rgb(0,0,0)
白色: rgb(255,255,255)

前端开发中其实并不常用黑色
只要让红色/绿色/蓝色的值都是一样就是灰色 
而且如果这三个值越小,就越偏黑色,越大就月像白色
color:rgb(200,200,200)_
3)rgba(css3) rgba中的rgb和前面一样,只是多了个a,这个a代表透明度,值越小，越透明
格式:color: rgba(255,0,0,0.2);
4)十六进制
本质就是rgb,十六进制中通过每两位表示一个颜色
例如:#FFEE00 FF表示r EE表示g 00表示b
5)十六进制缩写
在css中只要十六进制的颜色每两位的值都是一样的,那么就可以简写为1位.
例如:#FFEE00 == #FE0



四.选择器
1.标签选择器
作用:根据指定的标签名称,在当前的界面中找到
所有该名称的标签,然后设置属性

格式:
标签名称 {
    属性:值;
}
注意点:
1)标签选择器选中的是当前界面中所有的标签
而不能选中某一个标签
2)标签选择器无论标签藏的多深都能选中
3)只要是HTML中的标签都可以作为标签选择器

2.id选择器
作用:根据指定的id名称找到对应的名称,然后设置属性 
格式:
#id名称{
    属性:值;
}
注意点:
1)每个html标签中都有id属性
2)在同一个界面中,id的名称是不能重复的
3)id名称是有一定的规范的,只能由字母,数字,下划线组成,只能
由字母或者下划线,不能以数字开头
4)id名称不能是html标签的名称,即不能是a h1 img ...
5)在企业开发中一般情况下如果仅仅是为了设置样式,我们
不会使用id,因为在前端开发中id是留给js使用的

3.类选择器
作用:根据指定的id名称找到对应的标签,然后设置属性
格式:
.类名 {
    属性:值;
}
注意点:
1)每个html标签中都有class属性
2)在同一个界面中,class的名称是可以重复的
3)类名的命名规范和id名称命名规范一样
4)html标签中每个标签可以同时绑定多个类名
格式: <标签名称 class="类名1 类名2...">
错误的写法:<标签名称 class="类名1" class="类名2">

4.后代选择器
作用:找到指定标签的所有后代标签,设置属性
格式:
标签名称1 标签名称2 {
    属性:值;
}
先找到名称叫做标签名称1的标签,然后再在这个标签下面去查找
所有名称叫做标签名称2的标签,然后设置属性

注意点:
1)后代选择器必须用空格隔开,后代不仅仅是儿子,也包括孙子/重孙子,
只要最终是放到指定标签中的都是后代
2)后代选择器不仅仅可以使用标签名称,还可以使用其他选择器


5.子代选择器
格式:
标签名称1>标签名称2{
   属性:值;
}
先找到名称叫做"标签名称1"的标签,然后在这个标签中查找所有直接
子元素叫做"标签名称2"的元素

注意点:
1)子元素选择器只会查找儿子,不会查找其他被嵌套的标签
2)子元素选择器之间需要用>符号连接,并且不能有空格
3)子元素选择器不仅仅可以使用标签名称,还可以使用其他选择器
4)子元素选择器可以用过>一直延续下去

6.交集选择器
作用:给所有选择器中的标签中,相交的那部分标签设置属性
格式:
选择器1选择器2{
    属性:值;
}
例如: p.para1{
    color:red;
}
.para1#identity{
    color:red;
}

注意点:
1)选择器和选择器中没有任何的连接符号
2)选择器可以使用标签名称/id名称/class名称
3)交集选择器仅仅作为了解

7.并集选择器
作用:给所有选择器选中的标签设置属性
格式:
选择器1,选择器2{
    属性:值;
}
注意点:
1)并集选择器必须使用,来连接
2)选择器可以使用标签名称/id名称/class名称

8.兄弟选择器
8.1相邻兄弟选择器 CSS2
作用;给指定选择器后面紧跟的那个选择器选中的标签设置属性
格式:
选择器1+选择器2{
    属性:值;
}
8.2通用兄弟选择器 CSS3
作用:给指定选择器后面所有选择器选中的所有标签设置属性
格式:
选择器1~选择器2{
	属性:值;
}

9.序选择器(10个):每一层都会遍历
9.1同级别的第几个
:first-child 选中同级别的第一个标签
注意点:不区分类型
:last-child 选中同级别的最后一个标签
注意点:不区分类型
:nth-child(n) 选中同级别中的第n个标签
注意点:
1)不区分类型
2)n可以为数字还可以为odd(奇数)和even(偶数)
3)n还可以为xn+y即:nth-child(xn+y); 
:nth-last-child(n) 选中同级别中的倒数第n个标签,n从0开始递增
:only-child 选中父元素中唯一的元素

9.2同级别同类型的第几个
:first-of-type 选中同级别中同类型的第一个标签
:last-fo-type  选中同级别中同类型的最后一个标签
:nth-of-type(n) 选中同级别中同类型的第n个标签
注意:n可以为数字还可以为odd(奇数)和even(偶数)
:nth-last-of-type(n) 选中同级别中同类型的倒数第n个标签
:only-of-type 选中父元素中唯一类型的某个标签


10.属性选择器
作用:根据指定的属性名称找到对应的标签,设置属性

10.1
格式:[attribute]
作用:根据指定的属性名称找到对应的标签,设置属性

10.2
格式:[attribute=value]
作用:找到有指定属性,并且属性的取值等于value的标签,设置属性
应用场景:用于区分input属性

10.3 属性的取值是什么开头的
[attribute|=value] CSS2
[attribute^=value] CSS3
区别:CSS2中的只能找到value开头,并且value是被-和其他内容隔开的
而CSS3中的只要是以value开头的都可以找到,无论有没有被-隔开

10.4 属性的取值是什么结尾的
[attribute$=value] CSS3

10.5 属性的取值是否包含某个特定的值
[attribute~=value] CSS2
[attribute*=value] CSS3
区别:CSS2中的只能找到独立的单词,也就是包含value,并且value
是被空格隔开的,CSS3中的只要包含value就可以找到

11.通配符选择器
作用:给当前界面上所有的标签设置属性
格式:
*{
    属性:值;
}
注意点:由于通配符选择器是设置界面上所有的标签的属性,
所以在设置之前会遍历所有的标签,如果当前界面上的标签比较多,
那么性能就会比较低,所以在企业开发中一般不会使用通配符选择器


12.伪元素选择器(CSS) :给指定标签的内容前面添加一个子元素或者给指定标签
的内容添加一个子元素
格式:
标签名称:;before{ //或者after 
    属性:值;
}

13:伪类选择器
a标签存在一定的状态:
1)默认状态,从未访问过的
2)被访问过的状态
3)鼠标长按状态

1):link 修改从未被访问过状态下的样式
2):visited 修改被访问过的状态下的样式
3)):hover 鼠标悬停在a标签上的状态下的样式,hover出了用于a标签外,还可以用于其他任何标签
4):active 修改鼠标长按的状态下的样式


注意点:
1)a标签的伪类选择器可以单独出现也可以一起出现,一起出现的
时候顺序必须注意顺序,link visited hover active
2)如果:link 和:visited修改的样式一样,则可以简写
3)在企业开发中编写a标签伪类选择器最好写在标签选择器的后面
4)企业开发中和a标签盒子相关的属性都写在a标签选择器中(显示模式/宽度/高度/margin/padding),a标签中文字/背景相关的都写在伪类选择器中
a:visited {color:green;}
a:link {color:green;}
简写为:
a {color:green;}






五.继承性
作用:给父元素设置一些属性,子元素也可以使用
1.并不是所有的属性都可以继承,只有以color/font-/text-/line开头的属性才可以继承
2.在CSS的继承中不仅仅是儿子可以继承,只要是后代都可以继承

3.继承性中的特殊性
3.1 a标签的文字颜色和下划线是不能继承(父辈)的
3.2 h标签的文字大小是不能继承(父辈)的

应用场景:
一般用于网页上的一些共性信息,例如网页的文字颜色,字体,文字和大小
body{}

六.层叠性
作用:处理CSS处理冲突的一种能力
注意点:
1)层叠行只有在多个选择器选中"同一个标签",然后又设置了"相同的属性",才会发生层叠性

七.优先级
作用:当多个选择器选中同一个标签,并且给同一个标签设置相同的属性时,如何
层叠就由优先级来确定

1.优先级判断的三种方式
1.1是否是直接选中(间接选中就是继承,直接选中优先级大于间接选中的)
如果是间接选中,那么就是谁离目标标签比较近就听谁的
1.2相同选择器.
如果都是直接选中,并且都是同类型的选择器,那么就是谁写在后面就听谁的
1.3不同选择器,并且不是相同类型的选择器,那么就会按照选择器的优先级来层叠
id>类>标签>通配符>继承>浏览器默认


2.important
作用:用于提升某个直接选中标签的选择器中的某个属性的优先级的,
可以将被指定的属性的优先级提升为最高

注意点:
1.important只能用于直接选中,不能用于间接选中(即对后代元素没有影响)
p{
    color:green !important;
}
注意点:
1)通配符选中的标签也是直接选中的
2)!important只能提升被指定的属性的优先级,其他的属性的优先级不会被提升
3)!important必须写在属性值的分号前面.
4)!important前面的感叹号不能省略

3.优先级权重(只有选择器是直接选中标签的才需要计算权重)
作用:当多个选择器混合在一起使用时,可以通过计算权重来判断谁的优先级最高
规则:
1)首先先计算选择器中有多少个id,id多的选择器优先级高
2)如果id个数一样,那么再看类名的个数,类名个数多的优先级高
3)如果类名的个数一样,那么再看标签名称的个数,标签名称多的优先级高
4)如果id个数一样,类名个数也一样,标签名称数也一样,那么就不会往下计算了,
那么此时谁写在后面听谁的,也就是说优先级一样,谁写在后面就听谁的
#d1 ul .box2{
 color:red;
}
#.box1 li #d2{
 color:blue;
}
这两个优先级一样(id,类名,标签个数一样),谁写在后面听谁的


八.CSS元素显示模式
在HTML中HTML将所有的标签分为两类,分别是容器级和文本级
在CSS中CSS也将所有标签分为三类,分别是块级元素和行内元素
块级元素:会独占一行
行内元素:不会独占一行
行内块级元素

容器级的标签:
div h ul ol dl li dt dd ...

文本级的标签:
span p buis stong em ins del ...

块级元素:
p div h ul ol dl li dt dd ...
行内元素:
span  buis stong em ins del ...

1.块级元素和行内元素的区别:
1.1块级元素:
1)独占一行
2)如果没有设置宽度,那么默认和父元素一样宽,如果设置了宽高就按照设置
的来显示
1.2行内标签:
1)不会独占一行
2)如果没有设置内容,那么和内容一样宽,行内元素是不可以设置宽度
和高度的

2.行内块级元素:为了让元素既能够不独占一行,又可以设置宽度和高度
img 、input

3.CSS元素显示模式转换
display取值:
block 块级
inline 行内
inline-block 行内块级


九.背景
1.背景颜色:background-color用来设置背景颜色
取值:和 color取值一样

2.背景图片:background-image:url()
注意点:
1)图片的地址必须放在url()中,地址可以为本地地址,也可以是网络地址
2)如果图片的大小没有标签的大小大,图片会自动在水平和垂直方向平铺和填充
3)如果网页上出现了图片,那么浏览器会再次发送请求图片
2.1背景平铺属性:background-repeat
取值:
repeat(默认值):水平和垂直平铺
no-repeat :水平和垂直都不平铺
repeat-x :只在水平方向平铺
repeat-y :只在垂直方向平铺
应用场景:
可以通过背景图片的平铺来降低图片的大小,提升网页的访问速度

3.背景定位属性:background-position:水平方向 垂直方向
注意点:一个标签可以同时设置背景颜色和背景图片,如果颜色和图片
同时存在,那么图片会覆盖颜色
取值:
3.1具体的方向名词
水平方向:left center right
垂直方向:top center bottom
3.2具体的像素
background-position: 100px 200px;

3.3背景关联方式background-attachment
默认情况下背景图片会随着滚动条的滚动而滚动
那么可以修改背景图片和滚动条的关联方式
取值:
scroll:默认值,随着滚动条的滚动而滚动
fixed:不会随着滚动条的滚动而滚动

4.背景属性缩写
background:背景颜色 背景图片 平铺方式 关联方式 定位方式
注意点:
background属性中,任何一个属性都可以被省略

css 3中 背景新增的属性
1.background-size:背景尺寸属性
取值:
1)具体像素:100px 200px
第一个参数:宽度
第二个参数:高度
2)百分比: 50% 50%
当前元素宽高百分比
3)宽度等比拉伸:auto 100px
4)高度等比拉伸:100px auto
5)cover:告诉系统图片需要等比拉升,宽度和高度都需要填满元素
6)contain:告诉系统图片需要等比拉升,宽度或高度填满元素

2.background-origin:背景图从什么区域开始显示,默认情况下
从padding区域开始显示
取值:
padding-box:默认的,从padding区域开始显示
border-box:从border区域开始显示
content-box:从内容区域开始显示

3.background-clip:设置background-color从哪个区域开始绘制,
默认是从border区域开始绘制的
取值:
border-box(默认值)
padding-box
content-box

4.多重背景图片
多张背景图片之间由逗号隔开,先添加的背景图片会盖住后添加的背景图片
写法1:background:url(...) no-repeat right,bottom ,url(...)...
写法2:
background-image:url(...),url(...);
background-repeat:no-repeat,no-repeat;
background-position:left top,right top;
5.插入图片和背景图片的区别
背景图片:<div id="d1"></div>
插入图片:<div id="d2"><img src="01.jpg"></div>

1)背景图片仅仅是一个装饰,不会占用位置,插入图片会占用位置
2)背景图片有定位属性,所以可以很方便的控制图片的位置,插入
图片没有定位属性,所有控制图片的位置不太方便
3)插入图片的语义比背景图片的语义要强,所以在企业开发中如果你的
图片想要被搜索引擎收录,那么推荐使用插入图片

6.CSS精灵图
作用:可以减少请求的次数,以及可以降低服务器处理压力
使用:需要配合背景图片和背景定位来使用


十.边框,内边距,外边距
1.边框
1.1连写(同时设置4条边框)
border: 边框的宽度 边框的样式 边框的颜色

注意点:
1)连写格式中颜色属性可以省略,省略之后是黑色
2)连写格式中样式不能省略，省略之后就看不到边框了
3)连写格式中宽度可以省略,省略之后还是可以看见边框的

1.2连写(分别设置四条边框
border-top: 边框的宽度 边框的样式 边框的颜色
border-right: 边框的宽度 边框的样式 边框的颜色
border-bottom: 边框的宽度 边框的样式 边框的颜色
border-left: 边框的宽度 边框的样式 边框的颜色
1.3连写(分别设置四条边的边框)
border-width:上 右 下 左;
border-style:上 右 下 左;
border-color:上 右 下 左;
上 右 下 左 = > 上 右 下 > 左边的取值和右边的一样
上 右 下 左 = > 上 右 > 左边的取值和右边一样,下边的取值和上边一样
上 右 下 左 = > 上 > 右下左边取值和上边一样

1.4分写
border-top-width
border-top-style
border-top-color
...

2.内边距
边框和内容之间的距离(如果内容是文字,其实padding-top是边框的底部到行高的顶部之间的距离)
2.1非连写:
padding-top
padding-right
padding-bottom
padding-left
2.2连写:
padding:上 右 下 左;

注意点:
如果给标签设置了内边距,内边距也会有背景颜色

3.外边距
标签和标签之间的距离
3.1非连写
margin-top
margin-right
margin-bottom
margin-left

3.2连写
margin:上 右 下 左;

3.3两个盒子嵌套
1)设置里面一个盒子的顶部的外边距,外面一个盒子也会被顶下来,
如果外面的盒子不想被一起顶下来,那么可以给外面的盒子添加一个边框属性,或者
在外面的盒子设置overflow:hidden(用第二种方法好)
2)在企业开发中,一般情况下如果需要控制嵌套关系盒子之间的距离,应该首先
考虑padding,其次考虑margin,margin本质上用于控制兄弟关系之间的间隙的
3)在嵌套关系中,可以利用marign:0 auto;的方式来让里面的盒子在外面的
盒子水平居中,只对水平方向有效,对垂直方向无效

注意点:
1)外边距的那一部分是没有背景颜色的
2)在默认布局的垂直方向上,默认情况下外边距是不会叠加的,
会出现合并现象,谁的外边距大听谁的

十一.盒子模型
结论:
1)宽度/高度:是用来指定可以存放内容的区域
1.内容的宽度和高度:
就是通过width/height属性设置的宽度和高度
2.元素的宽度和高度
宽度 =  左边框 + 左内边距 + width + 右内边距 + 右边框 
同理高度
3.元素空间的宽度和高度:
宽度 = 左外边距 +  左边框 + 左内边距 + width + 右内边距 + 右边框 +右外边距 
4.box-sizing:CSS3
1)作用:
这个属性可以保证盒子新增padding和border之后,
盒子元素的宽度和高度不变,增加padding或者border之后,width和height将变小
2)取值:
content-box(默认值):
元素的宽高 = 边框 + 内边距 + 内容宽高

border-box:
元素的宽高 = width(初始值)


5.text-align:center 和margin:0 auto;的区别
1)text-align:center; 设置盒子中存储的文字/图片水平居中
2)margin:0 auto;让盒子自己水平居中


十二.网页布局
1.标准流(文档流/普通流)排版方式:
标准流中有两种排版方式,一种是垂直排版，另一种是垂直排版,
如果元素是块级元素,那么就会垂直排版
如果元素是行内元素/行内块级元素,那么就会水平排版

注意点:
1)标注流中内容的高度可以撑起父元素的高度
2)在浮动流中的元素是不可以撑起父元素的高度的


2.浮动流排版方式:
1)浮动流是一种"半脱离标准流"的排版方式
2)浮动流只有一种排版方式,就是水平排版,它只能设置某个元素
左对齐,或者右对齐
注意点:
1)在浮动流中,不可以使用margin:0 auto;的
2)浮动元素的脱标?
当某一个元素浮动后,那么这个元素看上去就像被从标准流中删除
了一样,这就是浮动元素的脱标
3)浮动元素脱标后的影响?
如果前面一个元素浮动了,而后面一个元素没有浮动那么这个时候前面
的一个元素就会覆盖住后面的一个元素
4)在浮动流中的元素是不可以撑起父元素的高度的
5)在企业开发中想让多个盒子的顶部对齐,可以让多个盒子同时浮动

特点:
1)在浮动流中是不区别块级元素/行内元素/行内块级元素的
无论是块级元素/行内元素/行内块级元素都能水平排版
2)在浮动流中无论是块级元素/行内元素/行内块级元素都能
设置宽高,浮动流中的元素和标准流中的行内块级元素很像


浮动元素的规则:
1)相同方向上浮动的元素,先浮动的元素会显示在前面,后浮动的
元素会显示在后面
2)不同方向上的浮动元素,左浮动会找左浮动,右浮动会找右浮动
3)浮动元素浮动之后的位置,有浮动元素浮动之前在标准流中的位置
决定
4)浮动元素贴靠现象
5)浮动元素字围现象(没有浮动的元素内容(文字或者图片)会包围浮动元素)
3.定位流排版方式

清除浮动方式:
1)给前面一个父元素设置高度，在企业开发中,能不写高度就不写高度,所以这种方式
很少用
2)给后面的浮动盒子添加clear属性
取值:
none(默认值,按照浮动元素的排序规则排序,左浮动找左浮动,右浮动找右浮动) 
left:不受左边浮动元素的影响
right:不受右边浮动元素的影响
both:不受左右边浮动元素的影响
注意点:当我们给某个元素添加clear属性之后,那么这个属性的margin属性可能会失效(当垂直方向的两个元素时,如果上面的元素为浮动,且没有设置宽高,如果下面的元素设置clear,再设置margin则margin无效)

3)外墙法:在两个盒子中间添加一个额外的元素,给这个添加的元素设置clear:both
注意点:外墙发可以让第二个盒子使用margin-top,但是不能让第二个盒子使用margin-bottom
如果想要设置两个盒子的margin,则直接设置中间盒子的高度即可

4)内墙法:在第一个盒子中所有子元素最后添加一个额外的块级元素,给
这个额外的元素设置clear:both
注意点:内墙法可以让第二个盒子使用margin-top,但是也能让第二个盒子使用margin-bottom
也能直接设置中间盒子的高度

外墙法和内墙法的区别:外墙法不能撑起一个盒子的高度,而内墙法可以撑起
一个盒子的高度

注意点:在企业开发中不常用外墙法和内墙法,来清除浮动

5)伪元素选择器清除浮动
.box1::after{
    content:"";
    display:block;
    height:0;
    visibility:hidden;
    clear:both;
}
.box1 {
    *zoom:1; //兼容IE6
}
注意:远离和内墙法差不多

6)overflow:hidden来清除浮动,在第一个盒子中,使用overflow:hidden来清除浮动
注意点:
.box1 {
    overflow:hidden;
    *zoom:1; //兼容IE6
}
和内墙法差不多,两个盒子都能设置margin
作用(共3个):
1)可以将超出标签范围的内容裁剪掉
2)清除浮动
3)可以通过让外面的盒子设置overline:hidden;,使用里面的盒子能够设置
margin-top,外面的盒子不被顶下来 




套路:
1)清空默认边距
body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,
fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0}
2)清空默认样式
a{
    text-decoration:none;
}
ul,ol {
	list-style:none;
}

3)利用body设置整个界面的文字信息
文字大小 文字字体 文字颜色
body {
    font-size:12px;
    font-family:"宋体";
	color:#333;
}



十三.定位流分类
格式:position:relative;
<div id="d1></div>
<div id="d2 style="position:relative;top:5px;"></div>
d2这个标签的外边距的顶部比没有相对定位之前向下偏移5px

注意点:
1)在相对定位中同一个方向上的定位属性只能使用一个
2)由于相对定位是不脱离标准流的,所以在相对定位中是区分块级元素/行内元素/行内块级元素
3)由于相对定位是不脱离标准流的,并且相对定位的元素会占用标准流中的
位置,所以给相对定位的元素设置margin/padding/border等属性时会影响到
标准流的布局
4)如果一个绝对定位的元素是以body为参考点,那么其实是以网页首屏的宽度
和高度作为参考点 ,而不是以整个网页的宽度和高度作为参考点
5)一个绝对定位的元素会忽略祖先元素的padding
6)相对定位:是不会脱离标准流的,会继续在标准流中占用一份空间, 不利于布局界面

应用场景:
1)用于对元素进行微调
2)配合后面学习的绝对定位来使用

2.绝对定位:绝对定位的元素是脱离标准流的,相对于body来定位的
注意点:
1)绝对定位的元素是不区分块级元素/行内元素/行内块级元素和浮动元素一样(脱离文档流)

规律:
1)默认情况下所有绝对行为的元素,无论有没有祖先元素,都会
以body为参考点
2)如果一个绝对定位的元素有祖先元素,并且祖先元素也是定位
流,那么这个绝对定位的元素就以定位流的那个祖先元素作为参考点,这个定位流指的是
绝对定位/相对定位/固定定位,定位流中只有static不行
3)如果一个绝对定位的元素有祖先元素,并且祖先元素也是定位流，而且祖先元素中有
多个元素都是定位流,那么这个绝对定位的元素会以离它最近的那个定位流的祖先元素
4)默认情况下绝对定位的元素会以body作为参考点,所以会随着浏览器的宽高的变化而变化
为参考点

如何让一个绝对定位的元素水平居中?
margin:0 auto 肯定是无效的,可以设置绝对定位元素的left:50%;再设置
绝对定位元素的margin-left:负元素宽度的一半
套路:
子元素用绝对定位,父元素用相对定位

3.固定定位:脱离标准流的,不会占用标准流的空间,和绝对定位一样不区分行内/块级/行内块
z-index规律
1)默认情况下定位流的元素会盖住标准流的元素
2)默认情况下定位流的元素后面编写的会盖住前面编写的元素
3)z-index的值越大,越显示在上面, 默认值是0
4)只能定位流元素才能设置z-index,static无效

从父现象:
1)如果两个子元素的父元素都没有设置z-index属性,那么谁的
z-index属性比较大谁就显示在上面
2)如果两个元素的父元素设置了z-index属性,那么子元素的z-index
属性就会失效,也就是说谁的父元素的z-index属性比较大，谁
就显示在上面

4.静态定位


十四.过渡模块
1.过渡三要素
1)必须要有属性发生变化
2)必须要有属性需要执行过渡效果
3)必须告诉系统过渡效果持续的时长

transition-property:width;
transition-duration:5s;
transition-delay:2s; //规定过渡效果何时开始,默认是0 

transition-timing-function:
linear 匀速
ease  加速度由大变小
ease-in   加速度由小变大
ease-out 和ease 很像
ease-in-out 加速度先由小变大,再由大变小

过渡连写:
1)transition: property,duration,timing-function,delay;

注意点:
当多个属性需要同时执行过渡效果时用逗号隔开即可
1)transition-property:width,background-color;
transition-duration:5s,5s;
2)transition: property,duration,timing-function,delay,...;
3)连写的时候可以省略后面两个参数,因为只要满足三要素就可以了
4)如果多个属性运动的速度/延迟的时间/持续时间都一样,可以简写:
transition:all 4s; 


编写过渡套路
1)不要管过渡,先编写基本界面
2)修改我们认为需要修改的属性
3)再回过去给被修改属性的那个元素添加过渡即可


十五.2D转换模块
transform: 
取值:
rotate(45deg);旋转45度
rotateZ(默认的)
rotateX
rotateY

translate(100px,100px); translateZ,translateY ,translateX 
第一个参数:水平方向移动
第二个参数:垂直方向移动


scale(2,2);
第一个参数:水平放大倍数
第二个参数:垂直放大倍数
如果水平放大和垂直放大倍数一样,则可以只写一个参数 scale(2)

连写:
transform: rotate(45deg) translate(100px,100px) scale(1,0.5)
没有顺序

注意点:
1)2D的转换模块rotate会修改元素的坐标系,所以旋转之后再平移就会出现问题 ,
所以最好在旋转之前就translate



transform-origin: 形变中心点,默认请款下所有元素都是以自己的中心点作为参考点旋转的,
可以通过形变中心点来修改它的参考点

transform-origin: 参数1 参数2
第一个参数:水平方向
第二个参数:垂直方向
取值:有三种形式,具体像素,百分比,特殊关键字(center,left,right,bottom,top)


perspective(近大远小): 400px;
注意:透视属性必须添加到需要呈现近大远小效果的元素的父元素上面



阴影:
1)给盒子添加阴影(6个参数)
box-shadow:h-shadow(水平阴影) v-shadow(垂直阴影) blur(模糊距离)
spread(阴影尺寸) color(阴影颜色) inset(内外阴影)
注意点:
1)盒子的阴影分为内外阴影,默认是外阴影
2)快速添加阴影只需要编写三个参数即可: h-shadow v-shadow blur
2)默认情况下阴影的颜色和盒子内容颜色一样


2)给文字添加阴影(4个参数)
text-shadow:h-shadow v-shadow blur(模糊度) color

注意点:
1)文字阴影颜色默认和文字颜色一样
2)快速添加文字阴影只需编写前三个参数即可,h-shadow v-shadow blur	


十六.动画模块

动画和过度之间的区别
1)不同点:过渡必须认为的触发才会执行动画,动画不需要人为的触发就能执行动画
2)相同点:过渡和动画都是用来给元素添加动画的,过渡和动画都是系统新增的一些属性,过渡
和动画都需要满足三要素才会有动画效果


1.三要素:
1)告诉系统需要执行哪个动画
animation-name:lnj(动画名称,随便写的); 
2)创建一个动画名称为lnj的动画
@keyframes lnj {
    from {
        margin-left:0;
    }	
    to {
        margin-left:500px;
	}
}

@keyframes lnj {
    0%{
       transform:rotate(10deg);
    }		
    25%{
       transform:rotate(50deg);
    }		
    50%{
       transform:rotate(70deg);
    }		
    100%{
       transform:rotate(100deg);
    }		
}
3)动画持续时长
animation-duration:3s;

2.其他属性
1)animation-delay:2s; 告诉系统多少秒之后开始执行动画和transition-duration,差不多
2)animation-timing-function: 动画执行时的速度和transition-timing-function差不多,控制速度变化的
3)animation-iteration-count:3;动画需要执行的次数
还可以为关键字:infinite
4)animation-direction:alternate;是否需要执行往返动画
取值:
normal:默认的,执行完一次之后回到起点
alternate:往返动画,执行一次之后往回执行下一次,来回分别算一次
5)animation-play-state:paused;控制动画暂停或运行
取值:
running:执行动画
paused:暂停动画


动画三个状态:
1.等待状态
2.执行状态
3.结束状态

animation-fill-mode作用:
指定动画等待状态和结束状态的样式:
取值:
none:不做任何改变
backwards:让元素等待状态的时候显示动画第一帧样式
forwards:让元素结束状态保持动画最后一帧的样式
both:让元素等待状态显示动画第一帧,让元素结束状态保持动画最后一帧的样式



连写:
animation: 动画名称 动画时长 动画运动速度 延迟时间 执行次数 往返动画;

连写格式的简写:
animation: 动画名称 动画时长


注意点:
1)动画中如果有和默认样式中同名的属性,会覆盖默认样式中同名的属性
2)在编写动画的时候,固定不变的值写在前面,需要变化的值写在后面2)在编写动画的时候,固定不变的值写在前面,需要变化的值写在后面

十七.3D转换模块
1.2D和3D:
2D就是一个平面,只有宽度和高度,没有厚度
3D就是一个立体,有宽度和高度,还有厚度
默认情况下所有元素都是2D的
2.如果让某个元素呈3D展现
和透视一样,想看到某个元素的3D效果,只需给他的父元素添加一个transform-style:preserve-3d




十八.
css书写格式:
1.行内样式:直接将css代码写到元素开始标签中
2.内嵌样式:在一对head标签中写上一对style标签,然后在style标签中编写css代码
3.外链样式:可以单独信件一个.css文件,把css代码写到这个文件中,推荐使用
<link rel="stylesheet" href="01.css">
4.导入样式:可以单独新建一个.css,
<style>
@import "01.css";
</style>


外链样式和导入样式的区别:
1)外链样式是通过link标签关联而导入样式是通过@import关联的,而这个
@import是CSS2.1推出的,所以有兼容问题
2)外链样式在显示界面的时候,会先加载CSS样式,再加载结构,所以
用户看到界面时一定已经设置了样式,
导入样式在显示界面的时候,会先加载结构,再加载样式,所以用户看到
界面的时候不一定已经设置了样式




offsetTop scrollTop  scrollTop 区别
http://blog.csdn.net/fswan/article/details/17238933 

clientTop 上边框长度   = border-top
clientHeight 内容高度(如果有滚动条,则不包括滚动条) = height + padding



offsetLeft 指的是左外边框距离y轴的距离 = 元素的x坐标
注意:其实就是此元素的包含块的左内边框到该元素的左外边框的距离
offsetHeight:指的是上外边框到下外边框的距离(没有margin)=上下border + padding + height


scrollHeight 内容高度(包括滚动内容的长度) 和clientHeight 差不多
scrollTop 当有滚动条的时候,滑动滚动条时,被滑过的内容的高度
