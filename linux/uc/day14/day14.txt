今天内容：
     (1)网络的基本常识
     (2)基于socket的一对一通信模型
     (3)基于tcp协议的通信模型

1.网络的基本常识
如：
    目前比较主流的网络通讯软件：QQ  微信  MSN  阿里旺旺 飞信 ... ...    

1.1 七层网络模型 和 常用的协议
(1)七层网络模型
     ISO将网络协议从逻辑上划分为7层，来保障数据传递过程中的可靠性、安全性等，具体的7层网络模型如下：
应用层 - 主要为应用程序的通信服务的，将数据交给应用程序
表示层 - 主要将数据按照统一的格式进行封装和打包等
会话层 - 对话，主要用于控制会话何时开始、何时结束等
传输层 - 主要对数据进行错误检查和重新排序等
网络层 - 主要用于选择具体的网络协议进行数据的传递
数据链路层 - 主要用于将打包好的数据转换为高低电平信号
物理层 - 主要指具体的交换机设备等

(2)常用的协议
    TCP - 传输控制协议，面向连接，该协议提供可靠的全双
               工的子节流
    UDP - 用户数据报协议，非面向连接，没有tcp协议可靠但
               是速度比较快
    IP  -  互联网协议，是上述两种协议的底层协议

1.2 IP地址 和 子网掩码的概念
(1)IP地址的概念和分类
     IP地址本质就是在互联网中的唯一地址标识，其数据类型为32位二进制组成的整数(ipv4)，当然也有128位二进制组成的整数(ipv6)
     日常生活中描述IP地址的主要形式为: 点分十进制表示法，也就是将每8位二进制转换为一个十进制整数，不同的十进制整数之间通过小数点分隔；
如：
     0x01020304  =>  1.2.3.4

查看IP地址的方式:
     windows系统中： ipconfig    ipconfig/all
     linux系统中： ifconfig    /sbin/ifconfig

     IP地址主要分为两部分：  网络地址  +  主机地址，根据网络地址和主机地址的划分，将IP地址分为以下4类：
     A类：0 + 7位网络地址 +  24位主机/本地地址
     B类：10 + 14位网络地址 + 16位主机/本地地址
     C类：110 + 21位网络地址 + 8位主机/本地地址
     D类：1110 + 28位多播地址

(2)子网掩码的概念
     子网掩码本质就是用于帮助IP划分具体的网络地址和主机地址，也可以用于判断两个IP地址是否在同一个局域网中，具体的划分方法为：按位&运算进行
如：
    IP地址：172.30.100.41
 子网掩码：255.255.255.0   &
-----------------------------------------------
                172.30.100   -  网络地址 
                             41   -  主机地址
练习：
     判断以下两个IP地址是否在同一个局域网中？？？
     166.111.160.1   和  166.111.161.45
      子网掩码全部为：255.255.254.0
解析：
     IP地址：166.111.160.1 
  子网掩码：255.255.254.0   &
-----------------------------------------------
                166.111.160   -  网络地址

    IP地址：166.111.161.45
 子网掩码：255.255.254.0   &
-----------------------------------------------
                166.111.160   -  网络地址
综上所述：
     上述两个IP地址在同一个局域网中

1.3 端口号和字节序的概念
(1)端口号
     IP地址 - 互联网中的地址标识，通过该地址可以定位主机
     端口号 - 主要用于定位某一台主机上的具体进程
     端口号的数据类型是：unsigned short类型，范围是：0 ~ 65535，其中0 ~ 1024之间的端口由系统占用，因此编程指定端口号时，建议从1025开始使用
     网络编程中需要提供：IP地址  +  端口号

(2)字节序的概念
小端系统：低位内存地址存放低位数据的系统
大端系统：低位内存地址存放高位数据的系统
如：
     对于十六进制的数据 0x12345678来说
小端系统中按照地址从小到大依次：0x78 0x56 0x34 0x12
大端系统中按照地址从小到大依次：0x12 0x34 0x56 0x78

一般性原则：
     对于多字节整数来说，为了避免不同的操作系统中存放字节序的不同而造成的数据不一致性问题，习惯上将所有发送出去的多字节整数先转换为网络字节序再发送，而将所有从网络上收到的多字节整数先转换为主机字节序再解析，而网络字节序本质就是大端系统的字节序

2.基于Socket的一对一通信模型
2.1 基本概念
    Socket  -  本意为插座的意思，表示逻辑上的通信载体
2.2 基本模型
服务器：
    (1)创建socket，使用socket函数
    (2)准备通信地址，使用结构体变量
    (3)绑定socket和	通信地址，使用bind函数
    (4)进行通信，使用read/write函数
    (5)关闭socket，使用close函数
客户端：
    (1)创建socket，使用socket函数
    (2)准备通信地址，是服务器的地址
    (3)连接socket和通信地址，使用connect函数
    (4)进行通信，使用read/write函数
    (5)关闭socket，使用close函数

2.3 相关函数的解析
(1)socket函数
     #include <sys/types.h>
     #include <sys/socket.h>
     int  socket(int  domain, int type, int protocol);
第一个参数：协议族/域，决定本地通信还是网络通信
     AF_UNIX/AF_LOCAL  -  实现本地通信
     AF_INET  -  实现基于ipv4网络协议的通信
     AF_INET6  -  实现基于ipv6网络协议的通信
第二个参数：通信的类型，决定具体的通信协议
     SOCK_STREAM  -  提供有序的、可靠的、双向的面向连
            接的字节流通信，本质就是基于tcp协议的通信模式
     SOCK_DGRAM  -  提供不可靠的，非面向连接的数据报
            通信，本质就是基于udp协议的通信模式
第三个参数：特殊的协议，直接给0即可
返回值：成功返回socket的描述符，失败返回-1
函数功能：
      主要用于创建端点来实现进程间的通信

(2)通信地址的结构体类型
a.通用的通信地址
   struct sockaddr 
   {
        sa_family_t sa_family;
        char        sa_data[14];
   };
   该结构体主要用于函数的形参类型，很少定义结构体变量

b.实现本地通信的通信地址
   #include <sys/un.h>
   struct sockaddr_un
   {
         sa_family_t  sun_family;//地址族，相当socket函数
                   中的第一个参数
         char  sun_path[];//socket文件的路径名
   };
   该结构体专门用于准备本地通信的通信地址

c.实现网络通信的通信地址
   #include <netinet/in.h>
   struct sockaddr_in
   {
        sa_family_t  sin_family; //地址族 AF_INET
        in_port_t       sin_port ;// 端口号
        struct in_addr  sin_addr;// ip地址
   };
   struct in_addr
   {
        in_addr_t  s_addr; 
   };
   该结构体专门用于准备网络通信的通信地址

(3)bind函数
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>
    int bind(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：通信地址的首地址，需要类型转换
第三个参数：通信地址的大小，使用sizeof计算即可
函数功能：
      主要用于socket和通信地址

(4)connect函数
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>
     int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
函数功能：
     主要用于连接socket和通信地址，参数和返回值参考bind函数即可

(5)字节序的转换函数
     #include <arpa/inet.h>
     uint32_t htonl(uint32_t hostlong);
 => 主要用于将32位的主机字节序转换为网络字节序
     uint16_t htons(uint16_t hostshort);
 => 主要用于将16位的主机字节序转换为网络字节序
     uint32_t ntohl(uint32_t netlong);
 => 主要用于将32位的网络字节序转换为主机字节序
     uint16_t ntohs(uint16_t netshort);
 => 主要用于将16位的网络字节序转换为主机字节序

(6)IP地址的转换函数
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    in_addr_t inet_addr(const char *cp);
 => 主要用于将字符串形式的IP地址转换为整数类型
    char *inet_ntoa(struct in_addr in);
 => 主要用于将结构体类型的IP地址转换为字符串类型

作业：
     练习和理解基于socket的通信模型
明日预报：
     (1)基于tcp的网络通信模型
     (2)tcp和udp协议的区别
     (3)基于udp的网络通信模型





























































 























