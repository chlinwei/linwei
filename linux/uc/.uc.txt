2.2 Unix/linux系统下高级C编程的主要内容
    (1)Unix/linux系统下的开发方式和编程基础
    (2)Unix/linux系统下的内存管理技术
    (3)Unix/linux系统下的文件管理和目录操作
    (4)Unix/linux系统下的进程管理  
    (5)Unix/linux系统下的信号处理
    (6)Unix/linux系统下的进程间通信技术
    (7)Unix/linux系统下的网络编程技术
    (8)Unix/linux系统下的多线程技术
----------------------------------------------------------------------------
今天内容：
    (1)Unix/linux系统的简介
    (2)gcc编译器的使用
    (3)多文件结构的编程
    (4)常用的预处理指令
    (5)环境变量的概念和使用
1.Unix/linux系统的简介
1.1 Unix系统的简介
      在1969年左右，编写操作系统时采用的汇编语言，编写和维护都非常不方便，贝尔实验室  汤普逊 研发了一门语言叫做B语言， 贝尔实验室 丹尼斯-里奇 在B语言的基础上做了修改和扩展，叫做 New B语言，后来改名为C语言
      C语言诞生于1972年，在编程语言排行榜上占据重要
的地位    
      Unix系统诞生于1970年，具有多用户、多任务以及支持多种处理器的特点  
1.2 linux系统的简介
     linux系统是一款  自由免费开放源代码的类Unix操作系统
     ubuntu 系统是一款linux系列的操作系统，每六个月会发布一个版本，分别是：4月 和  10月
     当前教学环境： ubuntu  12.04版本   32位的操作系统
     
2.gcc的使用
2.1 基本概念
    gcc 原名叫做 GNU C Compiler(编译器)，只支持对C语言的编译处理，后来对该编译器做了扩展，支持了更多的编程语言，如C++等，因此改名为 GNU  Compiler Collection
2.2 基本功能(重点)
     编程时采用的是高级语言，如C语言等，高级语言编写的程序代码无法被计算机直接执行，需要将高级语言转换为汇编语言，再将汇编语言转换为机器指令，最后链接生成可执行文件才能被计算机执行，而上述过程主要包含以下四步走：
(1)预处理/预编译
    - 主要用于实现头文件的扩展和宏替换等
(2)编译
    - 主要用于将高级语言翻译成汇编语言，得到汇编文件
(3)汇编
    - 主要用于将汇编语言翻译成机器指令，得到目标文件
(4)链接
    - 主要用于将目标文件和库文件进行链接，得到可执行文件
2.3 常用的编译选项
(1)熟练掌握的选项
     gcc/cc -E  xxx.c
  => 表示对高级源代码文件进行预处理操作，默认输出到控
        制台上，使用-o选项来改变输出位置为 xxx.i
      
     gcc/cc -S xxx.i
  => 表示将预处理文件经过编译翻译成汇编语言文件(xxx.s)
     gcc/cc -c xxx.s
  => 表示将汇编语言文件翻译成机器语言文件(xxx.o)
     gcc/cc xxx.o
  => 表示链接目标文件和库文件生成可执行文件(a.out)
     gcc/cc xxx.c
  => 表示编译链接生成可执行文件(需要执行上述4步走)
练习：
     gcc/cc -E xxx.c -o xxx.i
     gcc/cc -S xxx.i/xxx.c
     gcc/cc -c xxx.s/xxx.i/xxx.c
     gcc/cc xxx.o/xxx.s/xxx.i/xxx.c
(2)熟悉的选项
     -std   表示用于指定具体的C标准
     -v      表示用于查看编译器的版本信息
     -Wall 表示尽可能多地显示所有的警告信息
     -Werror 表示把警告当作错误进行处理
(3)了解的选项
     -g  表示生成调试信息
     -x   表示用于指定源代码的编程语言
     -O  表示进行优化处理
(4)扩展的选项
     man  命令/函数名称/gcc/cc 
     作业： 装个英文词典 -  星际译王 
2.4 常见的文件后缀
     .h  - 头文件             .c  - 源文件
     .i   - 预处理文件       .s  - 汇编文件
     .o  - 目标文件            
     .a  - 静态库文件        .so - 共享库文件
3.多文件结构的编程
3.1 多文件结构的主要组成
     .h - 头文件，主要存放结构体的定义，函数的声明等
     .c - 源文件，主要存放函数的定义等
     .a - 静态库文件，主要对功能函数的打包
     .so - 共享库文件，主要对功能函数的打包
3.2 头文件的详细内容(重点)
(1)头文件卫士
    #ifndef xxxx
    #define xxx
    #endif //xxx
(2)包含其他头文件
    #include <stdio.h>
    ... ...
(3)进行宏定义
    #define PI 3.14
    ... ...
(4)结构体的定义以及对类型起别名
    typedef struct 
    {
	 link lk;
    } stack;
(5)外部变量/函数的声明
    extern int num;
    void show(void);
    ... ...
注意：
    变量/函数的定义不能放在头文件中，因为当多个.c包含该头文件时，在一起编译链接的情况下会引发重定义的错误信息
例子：
     采用多文件的结构进行编程，要求根据用户输入的半径计算出圆形的周长和面积
     周长： 2 * PI * r 
     面积： PI * r * r
作业：
     练习从高级源代码到可执行文件的生成步骤
明日预报：
    (1)常用的预处理指令
    (2)环境变量的概念和使用
    (3)库文件的概念和使用
 
      
 
           
  
   
复习：
1.Unix/linux系统的简介
1.1 Unix系统的简介
     C语言诞生于1972年，在编程语言排行榜上占据重要
的地位
     Unix系统诞生于1970年，具有支持多用户、多任务、以及多种处理器的特点
1.2 linux系统的简介
     linux系统是一款  免费自由开发源代码的类Unix操作系统
    
2.gcc编译器的使用
2.1 基本概念
     原名叫做GNU C Compiler  该名为 GNU Compiler Collection
2.2 基本功能
     根据高级语言编写的源代码，来生成最终的可执行文件
(1)预处理/预编译   -E   
(2)编译  -S
(3)汇编   -c
(4)链接   gcc/cc xxx.o
2.3 常用的编译选项
     -E    -S   -c   -o 
     -std   -v   -Wall   -Werror
     -g   -x   -O
     man gcc/cc
2.4 常用的文件后缀
     .h     .c    .i     .s     .o     .a     .so
3.多文件结构的编程
3.1 多文件结构的主要组成
      .h   .c   .a    .so
3.2 头文件中的详细内容
(1)头文件卫士
     #ifndef ...
     #define ...
     #endif
(2)包含其他头文件
     #include <stdio.h>
(3)进行宏定义
     #define PI 3.14
(4)结构体的定义以及对类型其别名
     typedef struct
     {
          int id;
          char name[20];
     }Student; 
(5)外部变量/函数的声明
     extern int num;
     void show(void);
----------------------------------------------------------------------------
今天内容：
    (1)常用的预处理指令
    (2)环境变量的概念和使用
    (3)库文件的概念和使用
1.常用的预处理指令
1.1 复习标C中学过的预处理指令
     #include   包含...
     #define     定义...
     #undef      取消宏定义
     #ifdef        如果定义...
     #ifndef      如果没有定义...
     #if             如果...
     #elif          否则如果...
     #else         否则...
     #endif        结束如果
     ... ...
1.2 学习常用的新指令
     #line  整数n
 => 主要用于将下一行的行号修改为第n行
 => 可以用于控制调试阶段出错的行号
     #warning  字符串
  => 表示在预处理阶段产生一个警告信息
     #error 字符串
  => 表示在预处理阶段产生一个错误信息
  => 可以用于在调试阶段产生错误/警告信息
思考：
     #if   和 普通的if之间有什么区别呢？？
       #if  - 在编译期间做检查和判断
         if   - 在运行阶段做检查和判断
     #pragma GCC dependency 文件名
 => 表示当前文件依赖于指定的文件名，如果指定的文件最后
       一次修改时间晚于当前文件，则产生警告信息
 => 可以用于在调试阶段去监控具体的文件
老杨：vi show.c
       void show(void)
       {
             printf("我是帅哥我怕谁\n");
       }
小马哥：vi main.c
       #pragma GCC dependency "show.c"
       int main(void)
       {
             show();
             return 0;
       }
       #pragma GCC poison 标识符
   => 主要用于将指定的标识符设置为毒药，一旦使用该标识
        符则产生错误信息
         
      #pragma pack(整数n)
   => 表示设置结构体按照n的整数倍进行对齐和补齐
   => 主要用于通过上述方式来节省内存空间
        
1.3 常用的预定义宏
    __FILE__  -  用于获取预定义宏所在的文件名   %s
    __LINE__  -  用于获取预定义宏所在的行号      %d
    __DATE__ -  用于获取预定义宏所在文件的最后一次
                       编译日期  %s
    __TIME__ -  用于获取预定义宏所在文件的最后一次
                       编译时间  %s
    ... ...
2.环境变量的概念和使用
2.1 基本概念
      环境变量 - 一般是指在操作系统中用来指定操作系统运行的相关参数的特殊变量，也就是说环境变量就是用于存放系统/软件环境 相关参数信息的 特殊变量
      Path/PATH本质就是一种环境变量，路径存放在该环境变量中的应用程序/软件 可以通过文件名直接运行，从而省略路径信息
2.2 配置方法
(1)Windows Xp系统中的配置方法
      我的电脑 => 右键，选择属性  => 高级  =>  环境变量 => 系统变量中，找到Path,点击编辑  =>  在Path变量值的最后增加分号，再添加新路径  => 一路点击确定即可
      其中分号就是一个路径分隔符，用于划分不同的路径
      (切记 不要删除Path变量中之前的变量值)
(2)linux系统中的配置方法
      打开终端输入：  
           export PATH=$PATH:.
                $PATH - 表示获取环境变量PATH原来的数值
                     ：    - 表示路径分隔符，用于划分不同的路径
                       .  - 表示当前目录
      执行上述指令之后，表示把当前目录所在的路径追加到环境变量PATH的变量值末尾
      上述配置方法只对当前终端有效，新开的终端无法使用，为了配置永久性生效，vi ~/.bashrc文件中，编写以下代码：
      export PATH=$PATH:.
      保存退出之后，使用source ~/.bashrc文件，让配置文件中的指令立即生效
处理意外情况的方法：
     打开主目录，在主目录中使用快捷键 ctrl + h来显示所有的隐藏目录和文件，找到.bashrc文件，点击鼠标右键，选择使用文件编辑器的方式打开，修改文件内容后，保存关闭即可
2.3 编程相关的常用环境变量
     CPATH/C_INCLUDE_PATH 
  - 主要用于存放C语言头文件所在的路径
     CPLUS_INCLUDE_PATH 
  - 主要用于存放C++语言头文件所在的路径
     LIBRARY_PATH 
  - 主要用于存放库文件路径，解决编译链接时的问题
     LD_LIBRARY_PATH
  - 主要用于存放共享库所在的路径，解决运行时的问题
练习：
     采用多文件的结构进行编程，编写以下3个文件：
        add.h - 声明一个计算两个int类型参数和并返回的函数
        add.c  - 实现头文件中声明的函数
        main.c - 调用自定义的函数即可
2.4 查找头文件的主要方式
(1)#include <>
     - 表示在系统默认的路径中查找该头文件中
     - /usr/include/ ...
     - 可以使用命令whereis 来查找具体的头文件
(2)#include ""
     - 表示优先在当前目录中查找该头文件，查找不成功时，
       也会去系统默认的路径中进行查找
(3)配置环境变量CPATH/C_INCLUDE_PATH
       export CPATH=$CPATH:..
(4)采用编译选项进行指定(重点)
       gcc/cc xxx.c -I 头文件所在的路径
       gcc/cc xxx.c -I ..
注意：
      方法(1)(2)的缺点在于：一旦头文件的位置发生改变，则需要修改源程序来解决问题
      方法(3)的缺点在于：当有多个项目需要配置环境变量时，可能会引起冲突
      方法(4)的优势在于既不需要修改源程序，也不会引起多个项目的冲突问题，因此优先采用此方法
3.库文件的概念和使用
      在大型项目中，如果每个功能函数都存放在一个独立的.o文件中，那么项目管理变成灾难问题，因此采用库文件来解决该文件，具体的解决方案如下：一般按照功能模块将多个.o文件打包成一个/多个库文件，编写者只需要提供库文件和头文件即可
     库文件主要分为两种： 静态库文件(.a) 和共享库文件(.so)
3.1 静态库的概念和特性
(1)基本概念
     静态库本质就是由若干个.o文件打包生成的.a文件
     链接静态库的方式就是将库中被调用的代码指令复制到调用模块中，体现在最终的可执行文件中
(2)基本特性
优点：
      a.不需要跳转，因此效率会比较高
      b.可以脱离静态库文件
缺点：
      a.最终生成的可执行文件会比较大
      b.修改和维护都非常不方便
注意：
      使用ldd a.out的方式查看所以来的库文件
      使用gcc/cc -static xxx.c的方式强制要求按照静态库的方式进行链接处理，最终生成的可执行文件比较大
作业：
     复习uc讲过的内容
明日预报：
     (1)库文件的概念和使用
     (2)C语言中的错误处理
     (3)环境表的概念和使用
      
   
 
     
               
     
    
 
复习：
1.常用的预处理指令
   #line 整数n
   #warning 字符串
   #error 字符串
   
   #pragma GCC dependency 文件名
   #pragma GCC poison 标识符
   #pragma pack(整数n)   
2.环境变量的概念和使用
2.1 基本概念
   环境变量 - 用于存放系统/软件环境参数信息的特殊变量
   Path/PATH 就是一种环境变量，存放应用程序/软件的路径信息，启动应用程序/软件 只需要文件名即可
2.2 配置方法
(1)Xp系统
     我的电脑  => 右键，选择属性  => 高级  => 环境变量 => 系统变量Path，点击编辑，在变量值的末尾增加分号，添加新路径  =>  一路点击确定即可
(2)linux系统中配置方法
     终端中： export PATH=$PATH:.
      vi ~/.bashrc文件
      source ~/.bashrc
2.3 常用的环境变量
     CPATH/C_INCLUDE_PATH
     CPLUS_INCLUDE_PATH
     LIBRARY_PATH 
     LD_LIBRARY_PATH
     
2.4 查找头文件的主要方式
(1)#include <>
(2)#include ""
(3)配置环境变量CPATH  
     export CPATH=$CPATH:..
(4)gcc/cc xxx.c -I 头文件所在的路径(重点)
3.库文件的概念和使用
3.1 静态库的概念和特性
(1)基本概念
     静态库本质就是由若干个.o文件打包生成的.a文件
     链接静态库的方式本质就是将被调用的代码指令复制到调用模块中，体现在最终的可执行文件中
(2)基本特性
优点：
     a.不需要跳转，执行效率高
     b.可以脱离静态库文件
缺点：
     a.最终生成的可执行文件会比较大
     b.修改和维护都不方便
----------------------------------------------------------------------------
今天内容：
    (1)库文件的概念和使用
    (2)C语言中的错误处理
    (3)环境表的概念和使用
1.库文件的概念和使用
1.1 静态库的生成和调用步骤
(1)生成步骤
    a.编写源程序xxx.c，如：vi add.c
    b.只编译不链接生成目标文件xxx.o
       如： cc -c add.c
    c.生成静态库文件
        ar -r/*插入*/ lib库名.a 目标文件名
        ar -r libadd.a add.o
(2)调用步骤
    a.编写测试源程序xxx.c，如：vi main.c
    b.只编译不链接生成目标文件xxx.o
       如： cc -c main.c
    c.链接静态库文件生成可执行文件，链接方式有以下三种：
       1)直接链接
            cc 目标文件 静态库文件名
            如：cc main.o libadd.a
       2)采用编译选项进行链接(重点)
            cc 目标文件 -l 库名 -L 库文件所在的路径
            如：cc main.o -l add -L .
       3)通过配置环境变量LIBRARY_PATH进行链接
             export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add
1.2 共享库的基本概念和特性
(1)基本概念
     共享库本质就是由若干个.o文件打包生成的.so文件
     共享库和静态库的最大不同就是：链接共享库时并不会把被调用的代码指令复制到调用模块中，而是将被调用的代码指令在共享库中的相对地址嵌入到调用模块中
(2)基本特性
优点：
      a.共享库占用的空间比较小，也就是可执行文件比较小
      b.修改和维护都非常方便
缺点：
      a.需要跳转执行，因此执行效率比较低
      b.不可以脱离共享库文件
注意：
     目前主流的开发都采用共享库文件
1.3 共享库的生成和调用步骤
(1)生成步骤
    a.编写源程序xxx.c，如：vi add.c
    b.只编译不链接生成目标文件xxx.o
      如： cc -c -fpic/*小模式*/ add.c
    c.生成共享库文件
       gcc/cc  -shared/*共享的*/ 目标文件 -o lib库名.so
      如:   cc -shared add.o -o libadd.so 
(2)调用步骤
    a.编写测试源程序xxx.c，如：vi main.c
    b.只编译不链接生成目标文件xxx.o
       如： cc -c main.c
    c.链接共享库文件生成可执行文件，链接方式有以下三种：
       1)直接链接
            cc 目标文件 共享库文件名
            如：cc main.o libadd.so
       2)采用编译选项进行链接(重点)
            cc 目标文件 -l 库名 -L 库文件所在的路径
            如：cc main.o -l add -L .
       3)通过配置环境变量LIBRARY_PATH进行链接
             export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add    
注意：
     调用共享库文件时需要配置环境变量LD_LIBRARY_PATH
，具体的配置方法如下：
     export  LD_LIBRARY_PATH=$LD_LIBRARY_PATH:. 
注意：
    当同一个目录中具有相同库名的静态库和共享库时，使用gcc/cc编译链接时会自动优先选择共享库进行链接，如果希望链接静态库则使用-static选项来强制要求
1.4 共享库的动态加载
     #include <dlfcn.h>
     编译链接时需要指定选项  -ldl
(1)dlopen函数     
     void *dlopen(const char *filename, int flag);
第一个参数：字符串形式的文件名
第二个参数：具体的操作标志
      RTLD_LAZY - 延迟加载
      RTLD_NOW - 立即加载
返回值：成功返回共享库的句柄信息/地址，失败返回NULL
函数功能：
      主要用于加载第一个参数指定的共享库到内存中
(2)dlsym函数
     void *dlsym(void *handle,  const  char *symbol);
第一个参数：共享库的句柄，dlopen函数的返回值
第二个参数：字符串形式的符号，一般指函数名
返回值：成功返回函数名所对应的内存地址，失败返回NULL
函数功能：
      主要用于查找指定共享库中指定函数被加载到内存中地址
(3)dlclose函数
     int dlclose(void *handle);
函数功能：
     主要用于关闭/卸载参数指定的共享库，成功返回0，失败
     返回非0
(4)dlerror函数
     char *dlerror(void);
函数功能：
     主要用于获取dlopen/dlsym/dlclose函数执行期间产生的最近一个错误信息通过返回值返回，如果没有产生错误，则返回值为NULL
2.C语言中的错误处理
如：
     int main(void)
     {
           return 0; //表示程序正常结束
          // return -1;  // 表示程序出错结束
     }
2.1 C语言中的错误表现形式(错了吗？)
     一般来说，C语言中函数的错误表现形式如下：
     (1)对于返回值类型为int类型的函数来说，并且函数的计算结果不可能是负数时，使用返回-1表示出错，使用其他数据表示正常结束
     (2)对于返回值类型为int类型的函数来说，如果函数的计算结果可能是负数时，使用指针作为函数的参数将函数的计算结果带出去，而函数的返回值专门用于表示函数是否出错，习惯上使用-1表示出错，0表示正常结束
     (3)对于返回值类型为指针类型的函数来说，使用返回NULL表示函数出错，其他数据表示正常结束
     (4)如果不考虑函数是否出错，则返回值类型使用void即可
例子：
      按照上述要求，编写以下四个功能函数
      (1)要求返回1~10之间的随机数，如果随机数是5，则返回错误
      (2)比较两个int类型参数的大小，返回其中的最大值，如果两个参数相等，则返回错误
      (3)比较传入的字符串是否为"error"，如果是则返回错误，否则返回”ok“
      (4)打印传入的字符串即可
2.2 错误的编号（为什么错了？）
     errno本质就是一个int类型的全局变量，当函数调用出错时，会自动将错误的原因编号设置到errno中，因此可以通过errno的值来获取具体的错误原因
     #include <errno.h>
     该头文件中包含了errno全局变量的外部声明，以及常见的错误编号宏定义
     /etc/shadow - 存放了真实的密码信息，不过有加密
     /etc/passwd - 存放了当前系统的所有用户信息
文件的内容解析如下：
     tarena:  x:     1000   :  1000:
     用户名：密码：用户ID： 用户组ID
     tarena,,,:/home/tarena:  /bin/bash     
     注释信息 :    用户主目录    : shell的类型
作业：
     (1)查询函数strerror 和 perror的使用
     (2)编写两个功能函数，分别打印实心的菱形和空心的菱形，将这两个函数所在的.c文件分别打包成静态库和共享库进行调用，再练习一下共享库的动态加载
           *                        *
         ***                     * *
       *****                  *    *
         ***                     * *
           *                         *
明日预报：
     (1)C语言中的错误处理
     (2)环境表的概念和使用
     (3)内存管理技术
     
复习：
1.库文件的概念和使用
1.1 静态库的生成和调用步骤
(1)生成步骤
    a. vi add.c
    b. cc -c add.c
    c. ar -r libadd.a add.o
(2)调用步骤
    a. vi main.c
    b. cc -c main.c
    c. 链接的方式有三种：
        1) cc main.o libadd.a
        2) cc main.o -l add -L . 
        3) export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add
1.2 共享库的基本概念和特性
(1)基本概念
     共享库与静态库的最大不同之处：不会拷贝被调用的代码指令，而是将被调用代码指令在共享库中的相对地址拷贝到调用模块中
(2)基本特性
优点：
      a.共享库占用的空间比较小，可执行文件比较小
      b.修改和维护都比较方便
缺点：
      a.执行效率低
      b.不可以脱离共享库文件
1.3 共享库的生成和调用步骤
(1)生成步骤
    a. vi add.c
    b. cc -c -fpic add.c
    c.  cc -shared add.o -o libadd.so
(2)调用步骤
    a. vi main.c
    b. cc -c main.c
    c. 链接的方式有三种：
        1) cc main.o libadd.so
        2) cc main.o -l add -L . 
        3) export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add
注意：
    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.
1.4 共享库的动态加载
    #include <dlfcn.h>
     编译链接时需要指定 -ldl
    dlopen() - 打开/加载共享库文件
    dlsym() - 获取共享库中指定的函数地址
    dlclose() - 关闭/卸载共享库文件
    dlerror() - 获取具体的错误原因
2.C语言中的错误处理
2.1 C语言中的错误表现形式(错了吗？)
    (1)对于返回值类型为int类型的函数来说，并且函数的计算结果不可能是负数时，则返回-1代表错误，返回其他数据代表正常结束
    (2)对于返回值类型为int类型的函数来说，并且函数的计算结果可能是负数时，需要使用指针作为函数的参数将函数的计算结果带出去，而函数的返回值专门表示成功还是失败，使用-1表示错误，0表示成功
    (3)对于返回值类型为指针类型的函数来说，使用返回NULL表示错误
    (4)如果不考虑函数是否出错，则返回值类型给void
2.2 错误编号(为什么错了？)
     #include <errno.h>
     errno本质就是一个int类型的全局变量
     /etc/passwd - 包含了当前系统的用户信息
     /etc/shadow - 包含了系统中的真实密码信息
作业：
---------------------------------------------------------------------------
今天内容：
    (1)C语言中的错误处理
    (2)环境表的概念和使用
    (3)内存管理技术
1.C语言中的错误处理
1.1 错误信息
(1)strerror函数
     #include <string.h>
     char *strerror(int errnum);
函数功能：
     主要用于根据参数指定的错误编号翻译成对应的错误信息，通过返回值返回，当错误编号不合法时，返回“Unknown error nnn”
(2)perror函数(重点)
     #include <stdio.h>
     void perror(const char *s);
函数功能：
     主要用于向标准错误输出上打印最后一个错误信息，如果参数不为空时，则参数的内容原样输出，后面跟着一个冒号，一个空格，再跟着错误信息，并且最后自动换行
(3)printf函数(了解)
    printf("%m\n");  => 打印具体的错误信息
注意：
    判断函数是否出错需要根据函数的返回值进行判断，在明确函数已经出错的情况下，可以通过errno来获取具体的错误原因，但是不能直接使用errno来作为判断函数是否出错的依据，因为errno是个全局变量，errno的数值会随时发生改变，尤其在多线程编程中
2.环境表的概念和使用
2.1 基本概念
     环境表本质就是环境变量的集合，每个进程内部都拥有一张独立的环境表，用于记录和当前进程相关的环境变量信息
     环境表本质就是一个字符指针数组，并且以空指针作为字符指针数组的结尾标志，其中每个指针都是指向一个格式为"环境变量名=环境变量值"的字符串的首地址，而整个环境表的首地址记录在一个全局变量char** environ中，因此可以通过全局变量environ来获取整个环境表中的信息
2.2 基本操作
(1)getenv函数
     #include <stdlib.h>
     char *getenv(const char *name);
函数功能：
     主要用于获取参数指定的环境变量名所对应的环境变量值
，如果环境变量不存在，则返回NULL
(2)setenv函数
     #include <stdlib.h>
     int setenv(const char *name, const char 
*value, int overwrite);
第一个参数：环境变量名
第二个参数：环境变量值
第三个参数：是否修改的标志位
      非0 - 可以修改
        0 - 不可以修改
返回值：成功返回0，失败返回-1
函数功能：
      主要用于增加环境变量/修改环境变量的变量值，也就是如果环境变量不存在则增加，如果环境变量存在则是否修改取决于第三个参数
(3)unsetenv函数
    #include <stdlib.h>
    int unsetenv(const char *name);
函数功能：
      主要用于从环境表中删除参数指定的环境变量，如果该环境变量不存在，则函数的调用依然是成功的，环境表也不会发生改变
(4)putenv函数
     #include <stdlib.h>
     int putenv(char *string);
函数功能：
     主要用于增加环境变量/修改环境变量的值，参数的格式为：name=value，也就是说环境变量不存在则增加，存在则修改，成功返回0，失败返回非0
(5)clearenv函数
     #include <stdlib.h>
     int clearenv(void);
函数功能：
     主要用于清空整个环境表中所有的环境变量对，并且将全局变量environ也置为空指针，成功返回0，失败返回非0
2.3 main函数的原型
    int main(int argc,char* argv[],char* envp[])
第一个参数：记录命令行参数的个数
第二个参数：字符指针数组，用于记录每个命令行参数的地址
第三个参数：字符指针数组，用于记录当前进程的环境表信息
执行程序的方式为  a.out a.txt b.txt时：
      argc = 3;
      argv[0] = a.out
      argv[1] = a.txt
      argv[2] = b.txt
   
注意：
    由于历史的原因，main函数的第三个参数并不一定会被所有的系统支持，因此建议使用全局变量environ来访问环境表
实际案例：
     实现从文件argv[1]到文件argv[2]的拷贝
a.打开文件argv[1]和argv[2]
b.读取文件argv[1]中的内容写入到文件argv[2]中
c.关闭文件argv[1]和argv[2]        
     a.out a.txt b.txt     
  => 实现从a.txt到b.txt的拷贝
     a.out b.txt c.txt
  => 实现从b.txt到c.txt的拷贝
3.内存管理技术
3.1 程序和进程的基本概念
     程序 - 本质就是指存放在磁盘上的可执行文件
     进程 - 本质就是指运行在内存中的程序
     同一个程序可以同时启动多个进程
3.2 进程中的内存区域划分
如：
    int num;  // 全局变量   初始值是0    BSS段
    int main(void)
    {
         int num; // 局部变量  初始值是随机数   栈区
         return 0;
    }         
(1)代码区(Text)
    - 主要用于存放功能代码，函数指针指向该区域
(2)只读常量区(Text)
    - 主要用于存放字符串常量，const修饰的已经初始化的全
       局变量 和 静态局部变量
(3)全局区/数据区(Data)
    - 主要用于存放没有const修饰的已经初始化的全局变量和
       静态局部变量      
(4)BSS段(Data)
    - 主要用于存放没有const修饰的没有初始化的全局变量和
      静态局部变量
    - 该区域会在main函数执行之前执行自动清零的操作
(5)堆区(Heap)
    - 主要指使用malloc/calloc/realloc/free函数操作的
       内存区域
    - 该区域中的内存由程序员手动申请和手动释放
(6)栈区(Stack)
    - 主要用于存放局部变量(包括函数的形参),const修饰的
      局部变量以及块变量
    - 该区域中的内存由操作系统自动管理
综上所述：
     进程中的内存区域按照地址从小到大依次是：代码区、只读常量区、全局区、BSS段、堆区、栈区
     一般来说，堆区的内存地址按照从小到大依次分配，而栈区的内存地址按照从大到小依次进行分配
作业：
     根据图片以及程序来分析和理解进程中的内存区域划分
明日预报：
    (1)内存管理技术
     
    
       
复习：
1.C语言中的错误处理
     strerror() - 根据指定的错误编号翻译成对应的错误信息
     perror() - 打印错误信息
     printf("%m\n"); - 打印错误信息
2.环境表的概念和使用
2.1 基本概念
      环境表本质就是环境变量的集合，每个进程都拥有一张独立的环境表，用于记录属于当前进程的环境信息
      环境表本质是一个以NULL指针为结尾的字符指针数组，环境表的首地址记录在 全局变量 char** environ;
2.2 基本操作
     getenv() - 获取环境变量的值
     setenv() - 增加/修改环境变量
     unsetenv() - 删除环境变量
     putenv() - 增加/修改环境变量
     clearenv() - 清空整个环境表
2.3 main函数的原型
    int main(int argc,char* argv[],char* envp[])
3.内存管理技术
3.1 程序和进程的概念
     程序 - 存放在磁盘上的可执行文件
     进程 - 运行在内存中的程序
     程序可以同时启动多个进程
3.2 进程的内存区域划分
     内存地址从小到大：代码区、只读常量区、全局区/数据区、BSS段、堆区、栈区
作业：
----------------------------------------------------------------------------
今天内容：
     (1)内存管理技术
1.内存管理技术
1.1 存放常量字符串的不同形式之间的比较
如：
    char* pc = "hello";
    char ps[] = "hello";
      对于记录常量字符串的字符指针来说，指针的指向可以改变，但是指针指向的内容不可以改变；
      对于记录常量字符串的字符数组来说，数组名的指向不可以改变，但是数组名指向的内容可以改变；
      对于记录动态内存区域的指针来说，指针的指向和指针指向的内容都可以改变；
1.2 虚拟内存管理技术
    在Unix/linux系统中都采用虚拟内存管理技术对内存空间进行管理，即：每个进程都有0 ~ 4G-1的虚拟地址空间(虚拟的，并不是真实存在的)，由操作系统负责把虚拟地址和真实的物理内存地址映射起来，因此，不同进程中的地址空间看起来是一样的，但是所对应的物理内存却是不一样的
     其中0 ~ 3G-1之间的地址空间叫做用户空间，3G ~ 4G-1之间的地址空间叫做内核空间，绝大多数用户程序都运行在用户空间，内核空间只有内核才可以访问，当然内核也提供了相关的函数用于访问内核空间
     内存地址的基本单位是字节，但是内存映射的基本单位是内存页，目前主流的操作系统中一个内存页的大小是4Kb，也就是4096个字节
      ... ...
     1Pb = 1024Tb
     1Tb = 1024Gb
     1Gb = 1024Mb
     1Mb = 1024Kb
     1Kb = 1024byte(字节)
     1byte = 8 bit(二进制位)
1.3 段错误的由来
    (1)试图使用没有经过映射的虚拟地址时，可能引发段错误
    (2)试图对没有操作权限的内存空间进行操作时，可能引发段错误
1.4 使用malloc函数申请动态内存
(1)使用malloc函数申请的动态内存时的注意事项
     使用malloc函数申请动态内存时，malloc函数除了申请指定的内存空间之外，还可能申请额外的12个字节用于存储动态内存的管理信息，包括动态内存的大小，是否可用等信息，因此以后使用malloc函数申请的动态内存时，切记不要对动态内存进行越界访问，以避免对管理信息的破坏
(2)使用malloc函数申请动态内存的一般性原则
     一般来说，当使用malloc函数申请比较小块的动态内存时，操作系统会一次性映射33个内存页大小的存储空间，本质就是为了提高效率
    #include <unistd.h>
    #include <sys/types.h>
    getpid() - 主要用于获取当前进程的进程号
    
     cat  /proc/进程号/maps 
      - 表示查看指定进程的内存映射情况
具体的察看结果有六列：地址范围、操作权限、偏移量、设备
      编号、I节点的编号、具体的进程名称/内存区域名称
1.5 使用free函数释放动态内存
     一般来说，使用free函数释放动态内存时，释放多少则减去多少，当把所有动态内存全部释放完毕时，系统还会保留33个内存页，本质上还是为了提高效率
1.6 内存管理的相关函数
(1)getpagesize函数
     #include <unistd.h>
     int getpagesize(void);
函数功能：
     主要用于获取当前系统中一个内存页的大小，目前主流的操作系统都是4096个字节
(2)sbrk函数
     #include <unistd.h>
     void *sbrk(intptr_t increment);
函数的功能：
     主要用于根据参数指定的值来调整动态内存空间的大小
     当参数 > 0时：
          申请动态内存，成功返回申请到的内存空间的首地址
     当参数 = 0时：
          动态内存空间不变，成功返回当前动态内存的末尾地址
     当参数 < 0时：
          释放动态内存，成功返回释放之前的内存空间末尾地址
      函数调用失败时，返回(void*)-1
注意：
     使用sbrk函数申请内存比释放内存简单
     一般来说，使用sbrk函数申请比较小的内存时，操作系统会一次性映射1个内存页的大小，当申请的内存空间超过1个内存页时，系统会再次映射1个内存页的大小，当使用sbrk函数释放1个字节的内存时，系统可能会一次性释放1个内存页，当所有的动态内存被释放时，系统不会保留动态内存，因此相对于malloc函数来说更节省内存空间，但是效率没有malloc函数高
作业：
     查询并尝试使用brk函数
明日预报：
    (1)内存管理技术
    (2)文件管理
    
 
   
    
    
 
复习：
     ... ...
今天内容：
     (1)内存管理
     (2)文件管理
1.内存管理
1.1 内存管理的相关函数
(1)brk函数
     #include <unistd.h>
     int brk(void *addr);
函数功能：
     主要用于将动态内存的末尾地址调整到参数指定的位置，也就是根据具体的范围来调整动态内存的大小
     参数位置  > 末尾位置
         - 申请动态内存
     参数位置  = 末尾地址
         - 动态内存空间不变
     参数位置 < 末尾位置
         - 释放动态内存
注意：
     使用brk函数释放内存比申请内存方便，因此一般情况下和sbrk函数搭配使用，sbrk函数专门用于申请内存空间，brk函数专门用于释放内存空间
练习：
     使用sbrk函数和brk函数搭配使用，首先申请一个int类型的存储空间，存放数据66，在申请一个double类型的存储空间，存放数据3.14，最后申请10个字节的字符串空间，存放那个数据"hello"，打印以上内存空间中的数据，最后释放所有的内存空间
(2)mmap函数
     #include <sys/mman.h>
     void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
第一个参数：建立映射的起始地址，给NULL则由内核指定
第二个参数：映射的长度/大小
第三个参数：映射的权限
     PROT_EXEC - 可执行
     PROT_READ - 可读
     PROT_WRITE - 可写
     PROT_NONE - 不可访问
第四个参数：映射的标志
     MAP_SHARED - 共享的
     MAP_PRIVATE - 私有的
     MAP_ANONYMOUS - 映射到物理内存
第五个参数：文件描述符，暂时给0即可
第六个参数：文件中的偏移量，暂时给0即可
返回值：成功返回映射的首地址，失败返回MAP_FAILED
函数功能：
     主要用于建立文件/设备到内存中的映射
(3)munmap函数
     int munmap(void *addr, size_t length);
第一个参数：映射的起始地址，mmap函数的返回值
第二个参数：映射的长度/大小
函数功能：
      主要用于解除指定的映射关系
1.2 内存管理的层次关系
应用程序 - 业务逻辑
     |
STL标准模版库 - 使用容器和内存分配器，自动管理
     |
标准C++语言 - 使用运算符new申请，使用delete释放
     |
标准C语言  -  使用malloc函数申请,使用free函数释放
     |
POSIX标准  -  使用sbrk函数申请，使用brk函数释放 
     |
linux系统   - 使用mmap函数建立映射，munmap解除映射
                                                                          用户层
--------------------------------------------------------------------------
                                                                          内核层
操作系统内核 - vmalloc函数等
     |
... ...
2.文件管理
2.1 基本概念
     在linux系统中，几乎把所有的一切都统称为文件，包括目录和输入输出设备等等，因此对文件的绝大部分操作都适用于各种输入输出设备等
   
     /dev/null   -  空设备文件
如：
     echo hello
  => 终端中会输出 hello
     echo hello > a.txt
  => 将hello 写入到文件a.txt中
     echo hello > /dev/null
  => 丢弃命令的执行结果
     cat  /dev/null > a.txt
  => 表示清空文件中的内容
2.2 基本操作(重中之重)
复习标C中文件操作函数：
      fopen()/fclose()/fread()/fwrite()/fseek()
学习UC中文件操作函数：
      open()/close()/read()/write()/lseek()
(1)open函数
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    int open(const char *pathname, int flags);
    int open(const char *pathname, int flags, mode_t mode);
    int creat(const char *pathname, mode_t mode);
第一个参数：字符串形式的文件路径和文件名
第二个参数：文件的操作标志
      必须包含以下标志位中的一个
          O_RDONLY  -  只读
          O_WRONLY -  只写
          O_RDWR  -  可读可写
     还可以按位或以下的标志位：
          O_APPEND  -  以追加的方式打开文件
          O_CREAT  -  若文件不存在则创建，若存在则打开
          O_EXCL - 与O_CREAT搭配使用，若文件不存在则
                           创建，若文件存在则创建失败
          O_TRUNC - 若文件存在，则清空文件中的内容
第三个参数：文件的权限信息
      当创建一个新文件时，则需要该参数指定文件的权限信
      息，如：0664，当打开一个已经存在的文件时，不需要
      该参数，此时使用第一个open版本函数
返回值：成功返回文件描述符，失败返回-1
函数功能：
     主要用于打开/创建一个文件/设备
ls -l a.out的执行结果如下：
        -            rwx         rwx           r-x               1 
    文件的类型 属主权限 属组权限  其他用户权限  硬链接数
     tarena   tarena     7431        11月 20 14:43   a.out
    属主名称 属组名称  文件的大小 最后一次修改时间 文件名
其中的文件的类型主要有：
    -  表示普通规则文件
    d  表示目录文件
    ...
其中的权限信息主要有：
    r  表示可读   数字值为 4
    w 表示可写   数字值为 2
    x  表示可执行 数字值为1
    -  表示没有此权限  数字值为0
作业：
    查询文件基本操作的其他函数
明日预报：
    (1)文件的管理
复习：
1.文件管理
1.1 文件的基本操作
    open() - 打开/创建一个文件
    close() - 关闭文件
    read() - 读取文件中的内容
    write() - 向文件中写入数据
    lseek() - 调整文件的读写位置
1.2 标C和UC文件操作的比较
      标C的文件操作函数效率更高一些，因为函数内部提供了输入输出缓冲区，当数据积累到一定数量之后才会访问内核，才会写入数据到文件中
      使用time命令获取程序的执行时间
      UC文件操作可以通过自定义缓冲区的方式来提高效率，但不是缓冲区越大则效率越高
1.3 文件描述符的工作原理
作业：
--------------------------------------------------------------------------
今天内容：
     (1)文件的管理       
1.文件的管理
1.1 dup/dup2函数
     #include <unistd.h>
     int dup(int oldfd);
函数功能：
     主要用于对参数oldfd进行复制，成功返回新的文件描述符，失败返回-1
     #include  <unistd.h>
      int dup2(int oldfd, int newfd);
函数功能：
     主要用于实现从oldfd到newfd的复制，如果必要的话先强制关闭newfd再占用，成功返回新的描述符，失败返回-1
注意：
    使用dup/dup2函数复制文件描述符，本质就是复制文件描述符所对应的文件表地址，也就是让多个文件描述符同时对应同一个文件而已
1.2 fcntl函数
    #include <unistd.h>
    #include <fcntl.h>
    int fcntl(int fd, int cmd, ... /* arg */ );
第一个参数：文件描述符，open函数的返回值
第二个参数：操作的命令(执行一个什么样的操作)
     F_DUPFD - 实现复制文件描述符的功能，与dup2所不同
             的是，不会强制关闭占用的描述符，寻找>=第三个
             参数的描述符进行复制
    F_GETFD/F_SETFD - 获取/设置文件描述符的标志
    F_GETFL/F_SETFL - 获取/设置文件状态标志
    F_SETLK/F_SETLKW/F_GETLK - 实现文件锁的功能
第三个参数：可变长参数，是否需要取决于cmd
       实现文件锁的功能时，该参数是一个指向以下结构体的结构体指针，结构体类型如下：
struct flock 
{
     ...
     short l_type;/*锁的类型：F_RDLCK(读锁), F_WRLCK(写锁), F_UNLCK(解锁) */
     short l_whence;  /*锁定的起始位置:              SEEK_SET, SEEK_CUR, SEEK_END */
     off_t l_start;   /*针对起始位置的偏移量*/
     off_t l_len;     /*锁定的字节数*/
     pid_t l_pid;     /*加锁的进程号(F_GETLK使用)，否则默认给-1即可
};
返回值：
    F_DUPFD - 成功返回新的文件描述符，失败返回-1
    F_GETFD - 成功返回文件描述符的标志值，失败返回-1
    F_GETFL - 成功返回文件的状态值，失败返回-1
    其他命令成功返回0，失败返回-1
函数功能：
     (1)复制文件描述符(了解)
     (2)操作文件描述符标志(了解)
     (3)操作文件状态标志(了解)
     (4)实现建议锁/文件锁的功能(重点)
1.3 使用fcntl函数实现文件锁的功能
(1)文件锁的由来
     当有多个进程同时对同一个文件进行读写操作时，可能会产生数据的覆盖问题，也就是多个进程同时读文件可以进行，但是只要有一个进程在执行写操作，那么其他进程既不能读也不能写，为了实现上述效果，可以通过文件锁机制来实现
      文件锁本质就是一把读锁和一把写锁，其中读锁是一把共享锁，允许其他进程加读锁，不允许其他进程加写锁；而写锁是一把互斥锁，不允许其他进程加读锁和写锁(君子协定)
          
(2)F_SETLK作为函数的实参
      当锁的类型为F_RDLCK/F_WRLCK时，实现加锁功能
      当锁的类型为F_UNLCK时，实现解锁功能
练习：
     vi 04write.c文件，编程向文件b.txt中写入字符串内容"hello"，并且判断写入是否成功
总结：
     根据例子代码可知，给文件加完写锁之后还是可以向文件中写入数据内容的，结果说明文件锁是独立于文件的，也就是文件锁并不能控制对文件的读写操作，只能控制其他进程能否加锁成功，换句话说，如果给文件加了一把锁，可以导致第二次加锁失败(两个读锁除外)
  
思考：
    如果希望通过文件锁来控制对文件的读写操作,如何处理？
解决方案：
    为了实现上述效果，可以在每次进行读写操作之前尝试加读写锁，根据能否加上读写锁来决定能否进行读写操作，从而使得文件锁对文件的读写操作产生了约束
释放文件锁的方式：
     a.将锁的类型改为F_UNLCK，然后重新设置即可
     b.使用close函数关闭文件后，文件描述符对对应的文件
        上所有属于当前进程的文件锁都会释放
     c.进程结束，会自动释放所有该进程增加的文件锁
练习：
    vi 06unlock.c文件，首先对文件b.txt中的前10个字节加写锁，然后占用20秒之后开始解锁，解锁的方式为修改锁的类型，然后再占用20秒之后关闭文件，结束进程
(3)F_SETLKW作为函数的实参
      功能与F_SETLK类似，所不同的是如果当前锁加不上时，会进入阻塞状态一直等待，直到可以加上锁为止
(4)F_GETLK作为函数的实参
      如果第三个参数所描述的锁可以放置到文件上，则不去放置该锁，而是将锁的类型改为F_UNLCK，结构体中的其他成员保持不变；
      如果第三个参数所描述的锁不可以被放置到文件上，则使用文件上已经存在的锁信息去替换参数锁信息，并且将l_pid设置为真正给文件加锁的进程所对应的进程号；
 
1.4 access函数
      #include <unistd.h>
      int access(const char *pathname, int mode);
第一个参数：字符串形式的路径和文件名
第二个参数：操作模式
      F_OK  表示判断文件是否存在
      R_OK  表示判断文件是否可读
      W_OK  表示判断文件是否可写
      X_OK  表示判断文件是否可执行
函数功能：
     主要用于检查文件的存在性以及对应的权限信息      
作业：
     编写函数generator_id()实现生成递增帐号的功能
     a.out  100000   
     a.out  100001
     a.out  100002
     ... ...
明日预报：
    (1)文件管理
    (2)目录管理
    (3)进程管理
 
复习：
1.文件的管理
    dup/dup2函数  - 主要用于复制文件描述符
    fcntl函数 - 主要用于操作文件描述符
    access函数 - 主要用于判断文件是否存在以及拥有权限 
作业：
-----------------------------------------------------------------------------
今天内容：
     (1)文件的管理
     (2)目录的管理
     (3)进程的管理
1.文件的管理
1.1 常用的文件管理函数
(1)stat/fstat函数(重点)
     #include <sys/types.h>
     #include <sys/stat.h>
     #include <unistd.h>
     int stat(const char *path, struct stat* buf);
     int fstat(int fd, struct stat *buf);
第一个参数：文件的路径名/文件描述符
第二个参数：结构体指针
struct stat
{
      ...
      mode_t    st_mode;/*文件的类型和权限信息*/
      off_t     st_size;    /*文件的大小信息*/
      time_t    st_mtime;   /*文件的最后一次修改时间*/
      ...
      // 其中off_t本质就是long int类型
      // 其中time_t本质就是long int类型
};
函数功能：
     主要用于获取参数指定文件的状态信息
     #include <time.h>
     char *ctime(const time_t *timep);
  => 主要用于将整数类型的时间转换为字符串形式的时间
     struct tm *localtime(const time_t *timep);
  => 主要用于将整数类型的时间转换为结构体指针类型时间
     struct tm 
     {
         int tm_sec; /* 秒 */
         int tm_min;/* 分 */
         int tm_hour;/* 时 */
         int tm_mday;/* 日 */
         int tm_mon; /* 月 +1 */
         int tm_year; /* 年 +1900 */
         int tm_wday;/* 星期 */
         int tm_yday; /* 一年中的第几天 */
         int tm_isdst; /* 夏令时 了解 */
    };
扩展：
    获取一个文件大小的方法主要有三种：
        a.使用fseek函数将文件读写位置重置到末尾，使用
            ftell函数来获取文件的大小
        b.使用lseek函数将文件读写位置重置到末尾，通过返
            回值获取文件的大小
        c. 使用stat/fstat函数可以获取文件的大小
(2)chmod/fchmod函数
     #include <sys/stat.h>
      int  chmod(const  char  *path,  mode_t mode);
      int fchmod(int fd, mode_t mode);
第一个参数：文件的路径名/文件的描述符
第二个参数：文件的权限信息
函数功能：
      主要用于修改指定文件的权限信息
(3)truncate/ftruncate函数(重点)
     #include <unistd.h>
     #include <sys/types.h>
     int truncate(const char  *path,  off_t length);
     int ftruncate(int fd, off_t length);
第一个参数：文件的路径名/文件描述符
第二个参数：文件的最新长度
函数功能：
      主要用于修改文件的大小信息
注意：
      如果文件变小了，则多余的数据会被丢弃，如果文件变大了，则文件会被扩展，扩展出来的空间读取到的数据是'\0'
(4)umask函数(了解)
     #include <sys/types.h>
     #include <sys/stat.h>
     mode_t umask(mode_t mask);
函数功能：
     主要用于设置文件创建时的权限屏蔽字为：mask & 0777，通过返回值返回之前旧的权限屏蔽字
(5)又见mmap/munmap函数
     建立文件到虚拟内存地址之间的映射
  => 通过映射的机制可以将对文件的读写操作转换为对内存
        地址的读写操作，因此又多了一种访问文件的方式     
(6)其他功能函数
     link() - 主要用于创建硬链接
     unlink() - 主要用于删除硬链接
     rename() - 主要用于重命名
     remove() - 主要用于删除文件
     ... ... 
2.目录的管理
2.1 常用的管理函数
(1)opendir函数
     #include <sys/types.h>
     #include <dirent.h>
     DIR *opendir(const char *name);   
函数功能：
     主要用于打开参数指定的目录，成功返回目录的首地址，失败返回NULL
(2)readdir函数
     #include <dirent.h>
     struct dirent *readdir(DIR *dirp);
函数功能：
     主要用于读取参数指向的目录中的内容，成功返回目录指针，失败返回NULL，结构体的类型如下：
struct dirent
{
      ...
      unsigned char  d_type;/* 文件的类型 */
      char   d_name[256]; /* 文件名称 */
};
(3)closedir函数
     #include <sys/types.h>
     #include <dirent.h>
     int closedir(DIR *dirp);
函数功能：
     主要用于关闭参数指定的目录
练习：
     编程实现递归打印指定目录中的所有内容，要求子目录中的内容也要打印出来
2.2 其他目录管理函数
    mkdir() - 创建目录
    rmdir() - 删除目录
    chdir() - 切换目录
    getcwd() - 获取当前工作目录的绝对路径
    ... ...
3.进程的管理
3.1 基本概念和基本命令
(1)基本概念
     程序 - 存放在磁盘上的可执行文件
     进程 - 运行在内存中的程序
     同一个程序可以启动多个进程
(2)基本命令
     ps  -  查看当前终端启动的进程信息(进程的快照)
ps命令的执行结果如下：
     PID  -  进程的编号(重点)
     TTY  - 终端的次要装置号码(了解)
     TIME - 消耗CPU的时间(了解)
     CMD - 进程的名称(重点)
     ps -aux 表示显示所有包含其他使用者的进程信息
     ps -aux|more  表示分屏显示进程信息
ps -aux | more的执行结果如下(了解)：
     USER  -  用户名称
     PID - 进程号
     %CPU -  占用CPU的百分比
     %MEM  - 占用内存的百分比
     VSZ - 虚拟内存的大小
     RSS - 真实物理内存的大小
     TTY - 终端的次要装置号码     
     STAT - 进程的状态信息
     START - 进程的启动时间
     TIME - 消耗CPU的时间
     COMMAND -  进程的名称
进程的常见状态有(了解)：
     S  - 休眠状态，为了减轻CPU的压力
     s  -  进程的领导者，拥有子进程
     Z  -   僵尸进程(已经结束但是资源没有释放的进程)
     R  -  正在运行的进程
     O  -  可以运行的进程
     T  -   挂起的进程
     <  -  优先级比较高的进程
     N  -   优先级比较低的进程
     ...  ... 
    
     ps -ef  表示以全格式的方式显示所有进程信息
     ps -ef | more  表示以分屏方式显示进程信息
ps -ef | more的执行结果如下(了解):
      UID  -  用户的编号
      PID  -  进程的编号 
      PPID -  父进程的编号
      C  - 占用CPU的百分比
      STIME - 进程的启动时间
      TTY  - 终端的次要装置号码          
      TIME - 消耗CPU的时间
      CMD  - 进程的名称
  
      kill -9 进程号   表示杀死指定的进程 
  
      目前主流的操作系统支持多进程，在操作系统中，如果进程A启动了进程B，那么进程A就叫做进程B的父进程，进程B就叫做进程A的子进程
      操作系统中进程0(系统级的进程)负责启动进程1(init)和进程2，其他所有的进程都是直接/间接  由 进程1/进程2 启动的，所有的进程组成了树形结构
作业：
      查询和尝试使用文件和目录的其他管理函数
明日预报：
     (1)进程的管理
     (2)信号的处理
     
    
     
 
    
复习：
1.文件的管理
    stat()/fstat() - 主要用于获取文件的状态信息
    chmod()/fchmod() - 主要用于修改文件的权限信息
    truncate()/ftruncate() - 主要用于修改文件的大小
    umask()  -  主要用于设置文件创建时的权限屏蔽字
    mmap()/munmap() - 建立虚拟地址到文件的映射
    link()/unlink()/rename()/remove()/... ...
2.目录的管理
    opendir() - 打开目录
    readdir() - 读取目录中的内容
    closedir() - 关闭目录
    mkdir()/rmdir()/chdir()/getcwd()/ ... ...   
  
3.进程的管理
3.1 基本概念和基本命令
     ps  -  查看当前终端所启动的进程  PID   CMD
     ps -aux  -  显示所有包含其他使用者的进程信息
     ps -ef  -  以全格式的方式显示进程信息
     kill -9 进程号  表示杀死指定的进程
     目前主流的操作系统都支持多进程，如果进程A启动了进程B，则进程A叫做进程B的父进程，进程B叫做进程A的子进程
     进程0(系统级进程)负责启动了进程1(init)和进程2，其他所有的进程都是直接/间接 由 进程1/进程2 启动的，最终组成了树形结构   
-----------------------------------------------------------------------------
今天内容：
     (1)进程的管理
     (2)信号的处理
1.进程的管理
1.1 各种ID的获取
    #include <sys/types.h>
    #include <unistd.h>
    getpid()  -  获取当前进程的进程编号，返回pid_t
    getppid()  -  获取当前进程父进程的进程编号,返回pid_t
    getuid()  -  获取当前用户的编号，返回uid_t
    getgid()  -  获取当前用户所在用户组的编号，返回gid_t
注意：
    PID - 进程的编号，操作系统通过该编号唯一标识指定的进程，但是进程号的分配采用延迟重用的策略，在任意时刻都保证了进程号的唯一性
    pid_t本质就是int类型，进程号都是非负整数
    uid_t本质就是unsigned int类型
    gid_t本质就是unsigned int类型
      
1.2 进程的创建
(1)fork函数
     #include <unistd.h>
     pid_t fork(void);
函数功能：
     主要用于通过复制当前正在调用进程的方式来创建子进程，调用成功时父进程返回子进程的进程号，子进程返回0，调用失败时父进程返回-1，没有子进程存在
注意：
     使用fork函数创建子进程后，父子进程之间的执行顺序取决于操作系统的调度算法
(2)父子进程的代码执行方式
    a.对于fork函数之前的代码，由父进程执行一次；
    b.对于fork函数之后的代码，由父子进程各自执行一次；
    c.fork函数的返回值 由父子进程各自返回一次，父进程返
       回子进程的进程号，子进程返回0，因此可以通过函数的
       返回值来区分父子进程
(3)父子进程之间的关系
    a.父进程启动了子进程，父子进程同时执行，如果子进程先结束，子进程会给父进程发信号，父进程负责回收子进程的资源；
    b.如果父进程先结束，则子进程会变成孤儿进程，子进程会变更父进程(重新设定父进程,init进程)，init进程因为收养孤儿进程，因此被称为孤儿院；
    c.如果子进程先结束，但是父进程由于各种原因没有收到子进程发来的信号，则不会负责回收其资源，那么子进程就会变成僵尸进程；
(4)父子进程之间内存资源的关系
     对于fork函数创建的子进程来说，子进程会复制父进程中除了代码区之外的其他内存区域，而代码区和父进程共享
(5)扩展
    a.如何使用fork函数创建4个进程？？？
          fork();
          fork();
      4个进程：1个父进程 + 2个子进程 + 1个孙子进程
   b. 如何使用fork函数创建3个进程？？？
          pid = fork();
          if(0 != pid)
         {
                fork();
         }    
      3个进程：1个父进程  +  2个子进程
   c. 俗称"fork炸弹"
        while(1)
        {
              fork();
        }
1.3 进程的终止
(1)正常终止进程的方式
    a.执行到了main函数的return 0；
    b.调用exit()函数
    c.调用_exit()/_Exit()函数
    d.最后一个线程返回
    e.最后一个线程调用pthread_exit()函数
(2)非正常终止进程的方式
    a.采用信号来终止进程，如：ctrl+c
    b.最后一个线程被其他线程调用pthread_cancel函数取消
(3)终止进程相关函数的解析
    #include <unistd.h>
    void _exit(int status);   => UC函数
    #include <stdlib.h>
    void _Exit(int status);   => 标C函数
函数功能：
     主要用于立即终止当前正在调用的进程，自动关闭所有属于该进程的文件描述符，让该进程的所有子进程变更父进程为init进程，该进程也会其父进程发送SIGCHILD信号来回收该进程的资源
     参数值会被返回给当前进程的父进程作为当前进程的退出状态信息，父进程若要收集退出状态信息，则需要调用wait系列函数来处理
     #include <stdlib.h>
     void exit(int status);
函数功能：
      主要用于引起正在调用进程的终止，参数status & 0377之后的结果会被返回给父进程作为当前进程的退出状态信息
      在终止进程之前会自动调用所有由atexit()和on_exit()函数注册过的函数
      
      #include <stdlib.h>
      int atexit(void (*function)(void));
函数功能：
      主要用于注册参数指定的功能函数，注册过的函数会在进程正常终止时调用，而进程正常终止的方式为：调用exit()函数和从main函数中返回
      该函数调用成功时返回0，失败返回非0
1.4 进程的等待
(1)wait函数
     #include <sys/types.h>
     #include <sys/wait.h>
     pid_t wait(int *status);
函数功能：
     主要用于挂起当前正在调用的进程，直到该进程的一个子进程终止为止
     当参数不为空时，就将获取到的进程退出状态信息存放到参数status所指向的存储空间中，为了解析该退出状态信息，需要使用以下的带参宏：
     WIFEXITED(*status) - 如果进程正常终止则返回真，所谓正常终止就是指：调用exit()/_exit()/从main函数中返回
     WEXITSTATUS(*status) - 获取子进程的退出状态信息
     成功返回终止子进程的进程号，失败返回-1
(2)waitpid函数
     #include <sys/types.h>
     #include <sys/wait.h>
     pid_t waitpid(pid_t pid, int  *status,int options);
第一个参数：进程的编号
    <-1 等待进程组ID为pid绝对值的任意一个子进程(了解)
     -1  等待任意一个子进程(重点)
     0   等待和正在调用进程在同一个进程组的任意子进程
          (了解)
    >0  等待进程号为pid的子进程(重点)
第二个参数：指针作为函数的参数，获取进程的退出状态
第三个参数：等待的方式，默认给0，表示等不到会阻塞
    WNOHANG - 没有子进程终止时立即返回，不会阻塞
返回值：成功返回终止子进程的进程号，失败返回-1
函数功能：
      主要用于等待指定的进程状态发生改变
注意：
      The call wait(&status) is equivalent to:
      waitpid(-1, &status, 0);
1.5 进程的其他管理函数
(1)vfork函数
     #include <sys/types.h>
     #include <unistd.h>
     pid_t vfork(void);
函数功能：
     与fork函数类似，都是创建当前正在调用进程的子进程，有关创建的详细信息、返回值以及常见的错误信息请参考fork函数即可
     与fork函数不同之处在于，不会复制父进程中的内存区域，而是直接占用，导致父进程会被挂起直到子进程终止，或者子进程调用exec系列函数为止，所以vfork函数保证了子进程先于父进程执行
      使用vfork函数创建的子进程终止时只能调用_exit函数，而不能从当前函数返回 或者 调用exit函数
(2)exec系列函数
    #include <unistd.h> 
    int execl(const char *path, const char*arg, ...);
第一个参数：字符串形式的路径名
第二个参数：字符串形式的参数，一般指定可执行文件名
第三个参数：可变长参数，是否需要取决于前两个参数
函数功能：
      主要用于执行指定的文件
如：
    使用execl函数执行ls -l 命令时的用法如下：
        execl("/bin/ls","ls","-l",NULL);
注意：
       vfork函数本身没有太大的实际意义，一般需要与exec系列函数搭配使用，这样可以使得父子进程去执行完全不同的代码段
       fork函数也可以和exec系列函数搭配使用，但是效率相对比较低，因此一般情况下很少这样使用
(3)system函数
     #include <stdlib.h>
     int system(const char *command);
函数功能：
     主要用于执行参数指定的shell命令，但是在实际项目开发中可能更多地被用于执行shell脚本和可执行文件
2.中断的概念和分类
      中断就是指暂停执行当前正在执行的程序转而执行其他程序或者处理意外情况的过程
      中断分为：硬件中断  和 软件中断
3.信号的处理
3.1 基本概念和特点
(1)基本概念
      信号本质就是一种软件中断,它既可以作为进程间通信的一种方式，又可以中断一个正常运行的进程，它更多地被用于处理意外情况
(2)基本特点
    a.信号是异步的，也就是进程并不知道信号何时会到达;
    b.进程既可以处理信号，也可以发送信号给指定的进程;
    c.每个信号都有一个名字，并且用SIG开头;
3.2 信号的基本命令和分类
      kill -l  表示查看当前系统所支持的所有信号
      一般来说，在linux系统中支持的信号范围是：1 ~ 64，不保证信号是连续的，而unix系统与linux系统有所不同，一般支持的范围是 1 ~ 48;
      在linux系统中，其中 1 ~ 31之间的信号叫做不可靠信号，不支持排队，信号随时可能会丢失，也叫做非实时信号；
      其中34 ~ 64之间的信号叫做可靠信号，支持排队，信号不会丢失，也叫做实时信号；
要求掌握的信号：
      SIGINT    2   使用ctrl+c产生该信号   进程终止
      SIGQUIT  3   使用ctrl+\产生该信号   进程终止
      SIGKILL   9   使用kill -9产生该信号   进程终止
作业：
      查询signal函数并且尝试使用
明日预报：
      (1)信号的处理
   
   
 
复习：
1.进程的管理
1.1 各种ID的获取
      getpid() - 获取当前进程的进程号
      getppid() - 获取当前进程的父进程进程号
      getuid() - 获取用户的编号
      getgid() - 获取用户组的编号
      pid_t 本质就是 int 类型， 系统采用延迟重用
1.2 进程的创建
     fork() - 复制当前进程的方式来创建子进程
     
     子进程会复制父进程中除了代码区之外的其他内存区域，而代码区和父进程共享
     
     fork();
     fork();
     pid = fork();
     if(0 != pid)
     {
          fork();
     }
   
    while(1) {  fork();}
1.3 进程的终止
(1)正常终止进程的方式
     a.执行了main函数中的return
     b.调用exit()函数
     c.调用_exit()/_Exit()函数
     d.最后一个线程返回
     e.最后一个线程调用了pthread_exit()函数
(2)非正常终止进程的方式
     a.使用信号终止进程
     b.最后一个线程被其他线程调用pthread_cancel()函数
1.4 进程的等待
     wait() - 等待任意一个子进程结束
     waitpid() - 等待指定的子进程结束    
1.5 进程的其他管理函数
     vfork() - 创建子进程
     execl() - 执行指定的文件
     system() - 执行指定的shell命令
2.信号的处理
2.1 基本概念和特性
    信号本质就是一种软中断，它既可以作为进程间通信的机制，又可以终止一个正在执行的进程，更多地被用于处理意外情况
2.2 基本概念和分类
    在linux系统中支持的信号是 1 ~ 64，不保证连续，其中 1 ~ 31之间的信号叫做不可靠信息，不支持排队，信号可能会丢失，也叫做非实时信号；其中34 ~ 64之间的信号叫做可靠信号，支持排队，信号不会丢失，也叫做实时信号    
     kill -l
掌握的信号：
     SIGINT   2   ctrl+c    默认处理方式为终止进程
     SIGQUIT  3  ctrl+\    终止进程
     SIGKILL   9  kill -9    终止进程
作业：
     查询和解析signal函数
----------------------------------------------------------------------------
今天内容：
     (1)信号的处理
1.信号的处理
1.1 信号的处理方式
(1)默认处理，绝大多数信号的处理方式为终止进程
(2)忽略处理
(3)自定义处理  
注意：
     其中信号SIGKILL只能采用默认处理方式
     每个用户只能处理属于该用户的信号，只能给该用户的进程发送信号，其中root用户可以给几乎所有进程发信号
     #include <signal.h>
     typedef void (*sighandler_t)(int);
     sighandler_t     signal(int    signum,
          sighandler_t handler);
函数原型解析：
     typedef void (*sighandler_t)(int);
 =>  typedef void (*)(int)  sighandler_t;
 =>  typedef void (*p)(int)  sighandler_t;
     sighandler_t     signal(int    signum,
          sighandler_t handler);
 => void (*)(int)  signal(int    signum,
           void (*)(int) handler);
 =>  void (*)(int)  signal(int    signum,
           void (*handler)(int) );
 =>  void (*signal(int    signum,
           void (*handler)(int)) )(int);
 =>  signal首先是一个函数
        具有两个参数：一个是int类型，一个是函数指针类型
        函数的返回值类型也是函数指针类型
 =>  函数指针是一个 指向 int类型参数 void类型返回值的 
            函数的 指针
函数功能解析：
     第一个参数：信号的名称/信号值(处理哪个信号)
     第二个参数：函数指针类型
          SIG_IGN - 忽略处理
          SIG_DFL - 默认处理
          自定义函数地址 - 自定义处理
    返回值：成功返回之前的处理方式，失败返回SIG_ERR
    函数功能：
          主要用于设置信号的处理方式
练习：
    编程打印进程号，设置对信号SIGINT进行自定义处理，对信号SIGQUIT进行忽略处理，设置完毕之后使用fork函数创建子进程，打印子进程的进程号后进入无限循环，父进程直接结束，在另一个终端中采用kill命令发送信号进行测试
总结：
     (1)对于fork函数创建的子进程来说，完全照搬父进程对信号的处理方式，也就是父进程自定义，子进程自定义；父进程默认，子进程也默认；父进程忽略，子进程也忽略处理；
     (2)对于vfork函数和execl函数启动的进程来说，父进程默认，子进程也默认；父进程忽略，子进程也忽略；父进程自定义处理，子进程采用默认处理；
1.2 信号的发送方式
(1)采用键盘方式发送(只能发送部分特殊的信号)
      SIGINT   2   采用ctrl+c来发送
      ... ...
(2)采用程序出错方式发送(只能发送部分特殊的信号)
      段错误  本质就是SIGSEGV信号   11
      ... ...
(3)使用kill命令发送信号(可以发送所有信号)
      kill -信号值 进程号
   => 表示给指定的进程发送指定的信号
(4)采用系统函数发送信号(重点)
      kill()/raise()/alarm()/sigqueue()
1.3 发送信号的系统函数解析
(1)kill函数
    #include <sys/types.h>
    #include <signal.h>
    int kill(pid_t pid, int sig);
第一个参数：进程号(给谁发信号)
    >0 表示发送信号到进程号为pid的进程(重点)
      0 表示发送信号给和当前进程在同一个进程组的每个进程
          (了解)
     -1 表示发送信号给当前进程可以发送的每个进程，除了进
           程init(了解)
   <-1 表示发送信号给进程组ID为-pid的每个进程(了解)
第二个参数：信号值/信号名称(发送什么样的信号)
     0 表示不会发送信号，而是判断进程/进程组是否存在
函数功能：
     主要用于给指定的进程发送指定的信号
(2)raise函数
     #include <signal.h>
     int raise(int sig);
函数功能：
     主要用于给当前正在调用的进程/线程发送参数指定的信号，对于单线程的进程来说，等价于kill(getpid(),sig)
     成功返回0，失败返回非0
     #include <unistd.h>
     unsigned int sleep(unsigned int seconds);
函数功能：
     主要用于按照参数指定的秒数进行睡眠，直到参数指定的秒数到了或者被一个不能忽略的信号打断，如果睡够了则返回值为0，如果没有睡够则返回还没有来得及睡的秒数(也就是剩余的秒数)
(3)alarm函数
     #include <unistd.h>
     unsigned int alarm(unsigned int seconds);
函数功能：
     主要用于在经过参数指定的秒数之后发送SIGALRM信号给当前正在调用的进程
     每次设置新闹钟之后会取消之前的闹钟，参数为0时不会设置新闹钟，专门用于取消闹钟
    成功返回之前闹钟剩余的秒数，如果之前没有闹钟则返回0
(4)sigqueue函数
     等到讲完sigaction函数之后回来再讲
1.4 信号集的基本概念和操作
(1)基本概念
     信号集本质就是由若干个信号组成的集合，当前系统支持的信号范围是 1 ~ 64，不保证连续
分析：
     采用最节省内存方式描述信号集，数据类型该如何设计？
     char str[64];     需要64个字节
     采用每一个二进制位代表一个信号，则需要64个二进制位，那么也就是8个字节，类型为：long long int;
总结：
     信号集的数据类型是sigset_t类型，大小是128个字节，但是底层采用每一个二进制位来代表一个信号;
typedef struct
{
     unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
typedef __sigset_t sigset_t;
(2)基本操作
     #include <signal.h>
     sigemptyset() - 清空信号集//成功0失败-1
     sigfillset() - 填满信号集//成功0失败-1
     sigaddset() - 增加指定的信号到信号集中//成功0失败-1
     sigdelset() - 删除信号集中指定的信号//成功0失败-1
     sigismember() - 判断指定的信号是否存在
	 //返回1：说明指定的信号存在,
	 //返回0：说明指定的信号不存在
	 //返回-1：说明出错
1.5 信号的屏蔽
(1)sigprocmask函数
     #include <signal.h>
     int   sigprocmask(int    how,    const sigset_t *set, sigset_t *oldset);
第一个参数：屏蔽方式
      SIG_BLOCK - ABC  CDE => ABCDE(原+新)
      SIG_UNBLOCK - ABC  CDE => AB(原-新)
      SIG_SETMASK - ABC  CDE => CDE(新替换原，重点)
第二个参数：屏蔽的信号集
第三个参数：获取之前的屏蔽集
函数功能：
      主要用于获取/修改屏蔽的信号集
(2)sigpending函数
     #include <signal.h>
     int sigpending(sigset_t *set);
函数功能：
     主要用于获取在信号屏蔽期间来过但没有处理的信号，将这些来过的信号设置到参数指定的信号集中
1.6 sigaction函数
    => signal函数的增强版
    #include <signal.h>
     int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);
第一个参数：信号名称/信号值
      可以选择任何一个有效信号，除了SIGKILL和SIGSTOP
第二个参数：设置针对上述信号的处理方式
struct sigaction 
{
   void (*sa_handler)(int);
=> 函数指针，主要用于设置信号的处理方式
=> SIG_DFL，SIG_IGN，自定义函数的地址
   void (*sa_sigaction)(int, siginfo_t *, void *);
=> 函数指针类型，用于设置信号的处理方式，是否选用该成
     员，取决于sa_flags;
   sigset_t   sa_mask;
=> 主要用于设置在执行信号处理函数期间屏蔽的信号集
=> 默认屏蔽与触发信号处理函数相同的信号
   
   int sa_flags;
=> SA_SIGINFO  使用第二个函数指针来设置信号处理方式 
=> SA_NODEFER 解除对触发信号处理函数相同信号的屏蔽
=> SA_RESETHAND 一旦信号处理函数调用后恢复信号的
      默认处理方式(也就是自定义处理一次)
   void     (*sa_restorer)(void);
=> 函数指针类型，保留成员，暂时不使用
};     
第三个参数：用于获取之前的处理方式
函数功能：
     主要用于检查/修改指定信号的处理方式
其中结构体中的第二个成员的第二个形参类型如下：
struct siginfo_t
{
     ...
     pid_t    si_pid;      /* 发送信号的进程号 */
     sigval_t si_value;    /* 发送信号伴随的附加数据 */
     ... 
};
作业：
     查询和理解sigaction和sigqueue函数
明日预报：
     (1)信号的处理
     (2)进程间的通信
   
 
复习：
1.信号的处理
1.1 信号的处理方式
(1)默认处理，绝大多数信号的默认处理方式都是终止进程
(2)忽略处理
(3)自定义处理
     signal() - 设置对信号的处理方式
父子进程对信号处理方式的比较
    (1)对于fork函数创建的子进程来说，完全照搬父进程对信号的处理方式；
    (2)对于vfork函数和execl函数创建的子进程来说，父进程默认，子进程也默认；父进程忽略，子进程也忽略；父进程自定义，子进程默认处理；
1.2 发送信号的主要方式
(1)采用键盘发送(只能发送部分特殊的信号)
(2)采用程序出错发送(只能发送部分特殊的信号)
(3)使用kill命令   
     kill -信号值 进程号
(4)采用系统函数发送信号
     kill()/raise()/alarm()/sigqueue()
1.3 信号集的概念和操作
     信号集本质就是若干个信号组成的集合
     数据类型：sigset_t类型， 128个字节，采用每一个二进制位来代表一个信号
     sigemptyset() - 清空信号集
     sigfillset() - 填满信号集
     sigaddset() - 添加指定信号到信号集
     sigdelset() - 删除指定的信号
     sigismember() - 判断信号是否存在于信号集中
1.4 信号的屏蔽
     sigprocmask() - 设置/检查/修改屏蔽的信号集
     sigpending() - 获取信号屏蔽期间来过的信号     
1.5 sigaction函数
     是signal函数的增强版，设置对信号的处理方式
--------------------------------------------------------------------------
今天内容：
     (1)信号的处理
     (2)进程间通信的方式
1.信号的处理
1.1 sigaction函数
     #include <signal.h>
     int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);
第一个参数：信号名称/信号值
      可以选择任何一个有效信号，除了SIGKILL和SIGSTOP
第二个参数：设置针对上述信号的处理方式
struct sigaction 
{
   void (*sa_handler)(int);
=> 函数指针，主要用于设置信号的处理方式
=> SIG_DFL，SIG_IGN，自定义函数的地址
   void (*sa_sigaction)(int, siginfo_t *, void *);
=> 函数指针类型，用于设置信号的处理方式，是否选用该成
     员，取决于sa_flags;
   sigset_t   sa_mask;
=> 主要用于设置在执行信号处理函数期间屏蔽的信号集
=> 默认屏蔽与触发信号处理函数相同的信号
   
   int sa_flags;
=> SA_SIGINFO  使用第二个函数指针来设置信号处理方式 
=> SA_NODEFER 解除对触发信号处理函数相同信号的屏蔽
=> SA_RESETHAND 一旦信号处理函数调用后恢复信号的
      默认处理方式(也就是自定义处理一次)
   void     (*sa_restorer)(void);
=> 函数指针类型，保留成员，暂时不使用
};     
第三个参数：用于获取之前的处理方式
函数功能：
     主要用于检查/修改指定信号的处理方式
其中结构体中的第二个成员的第二个形参类型如下：
struct siginfo_t
{
     ...
     pid_t    si_pid;      /* 发送信号的进程号 */
     sigval_t si_value;    /* 发送信号伴随的附加数据 */
     ... 
};
1.2 sigqueue函数
    #include <signal.h>
     int sigqueue(pid_t pid, int sig, const union sigval value);
第一个参数：进程的编号(给哪个进程发信号)
第二个参数：信号值/信号名称(发送什么样的信号)
第三个参数：发送信号时伴随的附加数据
     union sigval 
     {
          int   sival_int;
          void *sival_ptr;
     };
函数功能：
      主要用于发送信号和附加数据到指定的进程中
1.3 计时器
     在linux系统中，系统会为每一个进程维护3种计时器：真实计时器、虚拟计时器、以及实用计时器，其中一般使用真实计时器更多一些；
     #include <sys/time.h>
     int getitimer(int which, struct itimerval *curr_value);
     int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);
第一个参数：计时器的类型(哪一种)
     ITIMER_REAL - 通过统计进程消耗的真实时间来传递SIGALRM信号进行工作的(重点)
     ITIMER_VIRTUAL - 通过统计进程消耗的用户态时间来传递SIGVTALRM信号进行工作的(了解)
     ITIMER_PROF - 通过统计进程消耗的用户态时间和内核态时间的总和来传递SIGPROF信号进行工作的(了解)
第二个参数：结构体指针，用于设置计时器的新值
struct itimerval 
{
     struct timeval it_interval; /* 间隔时间 */
     struct timeval it_value;    /*  启动时间 */
};
struct timeval 
{
     long tv_sec;  /* 秒  = 10^6 微秒*/
     long tv_usec;/* 微秒  */
};
    
第三个参数：结构体指针，用于返回计算器之前的旧值
函数功能：
     主要用于获取/设置计时器的参数值
2.进程间的通信方式
2.1 基本概念
    两个/多个进程之间的数据交互叫做进程间的通信
2.2 通信方式
    (1)文件
    (2)信号
    (3)管道
    (4)共享内存
    (5)消息队列(重点)
    (6)信号量集
    (7)网络(重点)
     ... ...
    其中(4)(5)(6)统称为 XSI IPC通信方式
     (X/open System Interface Inter-Process Communication)
3.使用管道实现进程间的通信
3.1 基本概念
     使用管道通信本质上还是以文件作为通信的媒介，只不过管道是一种比较特殊的文件而已
     管道分为两种：有名管道  和 无名管道
     有名管道：可以用于任意两个进程之间的通信
     无名管道 : 主要用于父子进程之间的通信
3.2 使用有名管道实现进程间的通信
     使用mkfifo命令/函数可以创建有名管道文件
如：
     mkfifo  a.pipe
  => 创建有名管道a.pipe文件
     touch  a.txt
  => 创建普通文件a.txt
     echo  hello  > a.txt
  => 将字符串hello写入到文件a.txt，可以写入的
     echo  hello  > a.pipe
  => 将字符串hello写入文件a.pipe，不可以写入的
     再开另外一个终端，写入以下指令：
     cat  a.pipe
  => 读取管道文件中的内容，此时数据hell可以读取成功
       对面的写入数据也会解除阻塞
     #include <sys/types.h>
     #include <sys/stat.h>
     int mkfifo(const char *pathname, mode_t mode);
 => 主要用于创建一个有名管道文件，权限由第二个参数指定
3.3 使用无名管道实现进程间的通信
    #include <unistd.h>
    int pipe(int pipefd[2]);
函数功能：
    主要用于创建无名管道文件，可以提供进程间通信的一种单向数据通道，通过参数可以返回两个文件描述符，其中pipefd[0]表示读端，pipefd[1]表示写端
注意：
     管道文件的特殊性就在于只是用于作为数据通信的桥梁，但是管道文件自身并不会存放任何数据
     使用管道实现进程间的通信是属于比较古老的方式，以后很少使用
4.使用共享内存实现进程间的通信
4.1 基本概念
      所谓共享内存本质就是一块由系统内核指定并维护的内存区域，该区域可以共享在多个进程之间，因此多个进程可以通过该共享内存作为媒介来实现进程间的通信
4.2 通信模型
(1)获取key值，使用ftok函数
(2)创建/获取共享内存，使用shmget函数
(3)挂接共享内存，使用shmat函数
(4)使用共享内存
(5)脱接共享内存，使用shmdt函数
(6)如果不再使用则删除共享内存，使用shmctl函数
4.3 相关函数的解析
(1)ftok函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     key_t  ftok(const  char *pathname, int proj_id);
第一个参数：字符串形式的路径名
      要求必须关联一个存在并且可以访问的文件
第二个参数：项目的编号，要求非0，取低八位二进制
返回值：成功返回key_t类型的key值，失败返回-1
函数功能：
      主要用于根据路径名和项目编号来生成key值
注意：
      使用相同的路径名和相同的项目编号，最终生成的key值也相同
(2)shmget函数
     #include <sys/ipc.h>
     #include <sys/shm.h>
     int shmget(key_t key, size_t size, int shmflg);
第一个参数：key值，ftok函数的返回值
第二个参数：共享内存的大小，
       如果获取已经存在的共享内存，则实参传0即可
第三个参数：共享内存的操作标志
       IPC_CREAT - 创建
       IPC_EXCL - 与IPC_CREAT搭配使用，如果共享内存已
                          经存在，则创建失败
       0 - 获取一个已经存在的共享内存
返回值：成功返回共享内存的ID，失败返回-1
函数功能：
      主要用于创建/获取一块共享内存
注意：
      使用shmget函数创建新的共享内存时，需要使用低位二进制来指定共享内存的权限信息，如按位或 0664
(3)shmat函数
     #include <sys/types.h>
     #include <sys/shm.h>
      void *shmat(int shmid, const void *shmaddr, int shmflg);
第一个参数：共享内存的ID，shmget函数的返回值
第二个参数：共享内存的地址，给NULL由系统指定
第三个参数：共享内存的操作标志，默认给0即可
返回值：成功返回挂接共享内存的地址，失败返回(void*)-1
函数功能：
     主要用于挂接共享内存到当前进程中
(4)shmdt函数
     #include <sys/types.h>
     #include <sys/shm.h>
     int shmdt(const void *shmaddr);
函数功能：
     主要用于脱接当前进程中的共享内存，参数为shmat函数的返回值
(5)shmctl函数
     #include <sys/ipc.h>
     #include <sys/shm.h>
     int shmctl(int shmid, int cmd, struct shmid_ds *buf);
第一个参数：共享内存的ID，shmget函数的返回值
第二个参数：具体的操作命令
     IPC_RMID - 删除共享内存，此时第三个参数给NULL即可
第三个参数：结构体指针
函数功能：
      主要用于对指定的共享内存进行控制
4.4 相关的基本命令
     ipcs  -m  表示查看当前系统中的所有共享内存
     ipcrm  -m  共享内存的ID  表示删除指定的共享内存
5.使用消息队列实现进程间的通信
5.1 基本概念
    本质上就是将数据打包成消息，然后将消息放到消息队列中，让多个进程访问同一个消息队列，从而实现进程间的通信
5.2 基本模型
(1)获取key值，使用ftok函数
(2)创建/获取消息队列，使用msgget函数
(3)发送/接收消息队列中的消息，使用msgsnd/msgrcv函数
(4)如果不再使用消息队列则删除，使用msgctl函数
5.3 相关函数的解析
(1)msgget函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgget(key_t key, int msgflg);
第一个参数：key值，ftok函数的返回值
第二个参数：操作标志
      IPC_CREAT  -  创建
      IPC_EXCL  -  与IPC_CREAT搭配使用，若存在创建失败
       0  -  获取一个已经存在的消息队列
返回值：成功返回消息队列的ID，失败返回-1
函数功能：
      主要用于创建/获取一个消息队列
注意：
     当创建新的消息队列时，需要在第二个参数中指定权限信息，如按位或 0664等
(2)msgsnd函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：消息的首地址，消息的一般格式如下：
struct msgbuf 
{
    long mtype;      /* 消息的类型, must be > 0 */
    char mtext[1];  /* 消息的内容，可以是其他结构*/
};
第三个参数：消息的大小
     用于指定消息内容的大小，不包括消息的类型
第四个参数：消息的发送标志，默认给0即可
     IPC_NOWAIT  -  不会产生阻塞现象
函数功能：
      主要用于将指定的消息发送到指定的消息队列中
作业：
     查询剩余的两个功能函数
明日预报：
     (1)使用消息队列实现进程间的通信
     (2)使用信号量集实现进程的通信
     (3)综合小项目：模拟ATM的功能
 
 
复习：
1.信号的处理
    sigaction() -  主要用于设置信号的处理方式
    sigqueue() - 主要用于发送信号和附加数据到指定进程
    setitimer()/getitimer() - 设置/获取计时器的相关信息
2.进程间通信的方式
   (1)文件
   (2)信号
   (3)管道
   (4)共享内存
   (5)消息队列(重点)
   (6)信号量集
   (7)网络(重点)
   ...
   其中(4)(5)(6)统称为 XSI IPC通信方式
   
3.使用管道实现进程间的通信
3.1 基本概念
     使用管道通信本质还是以文件作为通信的媒介，只不过该文件比较特殊，文件本身不会存放任何数据
     管道分为：有名管道  和 无名管道
3.2 使用有名管道实现进程间的通信
     mkfifo  xxx.pipe
     echo hello > xxx.pipe
     cat xxx.pipe
     mkfifo() - 创建有名管道
3.3 使用无名管道实现进程间的通信
     pipe() - 主要用于创建无名管道，返回两个描述符
4.使用共享内存实现进程间的通信
(1)获取key值，使用ftok函数
(2)创建/获取共享内存，使用shmget函数
(3)挂接共享内存，使用shmat函数
(4)使用共享内存
(5)脱接共享内存，使用shmdt函数
(6)如果不再使用，则删除共享内存，使用shmctl函数
ipcs -m   查看系统中的共享内存
ipcrm -m 共享内存的ID  表示删除指定的共享内存
5.使用消息队列实现进程间的通信
(1)获取key值，使用ftok函数
(2)创建/获取消息队列，使用msgget函数
(3)发送/接受消息，使用msgsnd/msgrcv函数
(4)如果不再使用，则删除消息队列，使用msgctl函数
----------------------------------------------------------------------------
今天内容：
    (1)使用消息队列实现进程间的通信
    (2)使用信号量集实现进程间的通信
    (3)综合小项目：银行账户管理系统
1.使用消息队列实现进程间的通信
1.1 相关函数的解析
(1)msgget函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgget(key_t key, int msgflg);
第一个参数：key值，ftok函数的返回值
第二个参数：操作标志
      IPC_CREAT  -  创建
      IPC_EXCL  -  与IPC_CREAT搭配使用，若存在创建失败
       0  -  获取一个已经存在的消息队列
返回值：成功返回消息队列的ID，失败返回-1
函数功能：
      主要用于创建/获取一个消息队列
注意：
     当创建新的消息队列时，需要在第二个参数中指定权限信息，如按位或 0664等
(2)msgsnd函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：消息的首地址，消息的一般格式如下：
struct msgbuf 
{
    long mtype;      /* 消息的类型, must be > 0 */
    char mtext[1];  /* 消息的内容，可以是其他结构*/
};
第三个参数：消息的大小
     用于指定消息内容的大小，不包括消息的类型
第四个参数：消息的发送标志，默认给0即可
     IPC_NOWAIT  -  不会产生阻塞现象
函数功能：
      主要用于将指定的消息发送到指定的消息队列中
(3)msgrcv函数
    #include <sys/types.h>
    #include <sys/ipc.h>
    #include <sys/msg.h>
    ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：存放消息的首地址
第三个参数：消息的大小，不包括消息的类型
第四个参数：消息的类型
    0  - 表示始终读取消息队列中的第一个消息
  >0  - 表示始终读取消息队列中第一个类型为msgtyp的消息
  <0  - 表示始终读取消息类型<=msgtyp绝对值的消息，其
           中最小的类型优先读取
第五个参数：接受消息的方式，默认给0，产生阻塞现象
返回值：成功返回实际接收的数据大小，失败返回-1
函数功能：
      主要用于从指定的消息队列中接收消息
(4)msgctl函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgctl(int msqid, int cmd, struct msqid_ds *buf);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：具体的操作命令
      IPC_RMID  - 删除消息队列，第三个参数给NULL即可
第三个参数：结构体指针
函数功能：
     主要用于操作指定的消息队列
1.2 基本命令
    ipcs  -q  表示查看系统中存在的消息队列
    ipcrm  -q  消息队列的ID   表示删除指定的消息队列
2.使用信号量集实现进程间的通信
2.1 基本概念
(1)什么是信号量？
      信号量本质就是一种计数器，用于控制同时访问同一个共享资源的进程个数/线程个数
(2)什么是信号量集？
      信号量集本质就是信号量的集合，也就是由若干个信号量组成的集合，主要用于控制多种共享资源各自同时被访问的进程/线程个数
(3)信号量的工作方式
    a.将信号量初始化为最大值；
    b.如果有进程申请到资源，则信号量的值减1；
    c.当信号量的值变为0时，申请资源的进程进入阻塞状态；
    d.如果有进程释放资源，则信号量的值加1；
    e.当信号量的值 > 0时，阻塞的进程继续抢占资源；
2.2 使用信号量集通信的基本模型
(1)获取key值，使用ftok函数
(2)创建/获取信号量集，使用semget函数
(3)初始化信号量集，使用semctl函数
(4)操作信号量集，使用semop函数
(5)如果不再使用，则删除信号量集，使用semctl函数
2.3 相关函数的解析
(1)semget函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semget(key_t key, int  nsems,  int semflg);
第一个参数：key值，ftok函数的返回值
第二个参数：信号量集的大小(信号量的个数)
       0  -  获取已经存在的信号量集
第三个参数：操作的标志
      IPC_CREAT  -  创建
      IPC_EXCL  - 与IPC_CREAT搭配使用，存在则创建失败
       0  -  获取已经存在的信号量集
返回值：成功返回信号量集的ID，失败返回-1
函数功能：
      主要用于创建/获取信号量集
注意：
     当创建新的信号量集时需要指定权限，如：0664等
(2)semctl函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semctl(int semid, int semnum, int cmd, ...);
第一个参数：信号量集的ID，semget函数的返回值
第二个参数：信号量集的下标(一般从0开始)
第三个参数：具体的操作命令
      IPC_RMID  -  删除信号量集，此时忽略第二个参数，不
                           需要第四个参数
      SETVAL  -  使用函数的第四个参数给信号量集中下标为
                        semnum的信号量进行初始化
第四个参数：可变长参数，是否需要取决于cmd
函数功能：
      主要用于控制指定的信号量集，具体功能取决于cmd
(3)semop函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semop(int semid, struct sembuf *sops, unsigned nsops);
第一个参数：信号量集的ID，semget函数的返回值
第二个参数：结构体指针，可以指向结构体变量，也可以指向
          结构体数组的首地址，结构体类型如下：
struct sembuf
{
    unsigned short sem_num;  /* 信号量的下标 */
    short  sem_op;   /* 信号量的操作 
         正数表示增加  0表示不变   负数表示减少  */
    short  sem_flg;  /* 操作标志，默认给0即可*/
};
第三个参数：结构体指针指向的结构体个数
函数功能：
      主要用于对指定的信号量执行指定的操作
2.4 基本命令
     ipcs  -s  表示查看当前系统中的信号量集
     ipcs  -a  表示查看当前系统中所有的IPC对象，包括共享内存，消息队列以及信号量集
     ipcrm  -s  信号量集的ID   表示删除指定的信号量集
3.综合小项目
3.1 项目名称
     银行账户管理系统(模拟ATM的功能)
3.2 项目功能
     开户、销户、存款、取款、查询、转帐、退出
3.3 项目架构
     采用C(Client)/S(Server)架构进行项目的架构  
客户端：
     提供界面让用户选择具体的业务，将用户的选择交给服务器进行处理，等待服务器的处理结果，并且显示给用户；
服务器：
    接受客户端发来的业务功能，通过访问数据库的方式进行处理，再将最终的处理结果交给客户端；
3.4 项目的详细设计
(1)客户端和服务器之间如何通信？？
     提供两个消息队列来实现通信
          消息队列一： 客户端  =>  服务器
          消息队列二： 服务器  =>  客户端
(2)不同的业务之间如何区分？？
     提供8种不同的消息类型
           6种不同的业务类型  + 成功  +  失败
(3)账户的数据类型和消息的数据类型应该如何设计？？
     采用结构体类型
     账户的信息：帐号、账户名称、密码、余额
     消息的信息：消息的类型   +   消息的内容(账户信息)
(4)以开户为例分析一下项目的执行流程
客户端：
    a.提供字符界面由用户选择具体的业务编号；
       => 使用printf打印界面即可
    b.根据用户的选择进入不同的分支处理；
       => 采用switch-case多分支结构
    c.提示用户输入用户名、密码以及余额信息；
       => 使用scanf函数进行读取即可
    d.将用户提供的信息和业务编号打包成完整的消息，
        发送到消息队列一中；
       => 打包消息的结构体变量，使用msgsnd发送即可
    e.等待服务器的处理结果，接收消息队列二中的消息；
       => 使用msgrcv函数进行接收，根据接收到的消息类型
             判断成功或失败，将结果打印出来
服务器：        
    a.创建两个消息队列；
      => 使用msgget函数
    b.接收消息队列一中的消息，并且判断消息的类型
      => 使用msgrcv函数，判断消息类型是否为开户的类型
    c.自动生成帐号，补充完整开户的用户信息，写入文件
       => 调用generator_id函数，使用write函数写入
       => 将每个用户信息保存在每个独立的文件中
       => 使用账户作为文件名确保唯一性，使用sprintf函数 
   d.根据用户信息写入是否成功，来修改对应的消息类型
       => 开户成功可以修改消息类型为7，否则修改为8
   e.将处理结果打包成完整的消息，发送到消息队列二中；
       => 使用msgsnd函数进行发送
   f.服务器应该24小时启动，除非手动去关闭；
       => 使用while(1)无限循环
       => 使用ctrl+c来关闭服务器，销毁两个消息队列
3.5 项目的要求
     (1)要求采用多文件的结构进行编程，而在每个文件中采用多个函数各自封装独立功能的方式进行编程；
     (2)要求实现开户的功能即可，有余力的同学考虑其他功能
3.6 项目的提示
     vi bank.h  -  定义用户信息和消息的数据类型
     vi client.c  -  编写打印字符界面的功能函数 ....
     vi server.c  -  编写创建消息队列的功能函数  ...
     vi dao.c  -  编写自动生成帐号的功能函数 ...
     ....
     最后支持Makfile文件
     
     
今天内容：
     (1)网络的基本常识
     (2)基于socket的一对一通信模型
     (3)基于tcp协议的通信模型
1.网络的基本常识
如：
    目前比较主流的网络通讯软件：QQ  微信  MSN  阿里旺旺 飞信 ... ...    
1.1 七层网络模型 和 常用的协议
(1)七层网络模型
     ISO将网络协议从逻辑上划分为7层，来保障数据传递过程中的可靠性、安全性等，具体的7层网络模型如下：
应用层 - 主要为应用程序的通信服务的，将数据交给应用程序
表示层 - 主要将数据按照统一的格式进行封装和打包等
会话层 - 对话，主要用于控制会话何时开始、何时结束等
传输层 - 主要对数据进行错误检查和重新排序等
网络层 - 主要用于选择具体的网络协议进行数据的传递
数据链路层 - 主要用于将打包好的数据转换为高低电平信号
物理层 - 主要指具体的交换机设备等
(2)常用的协议
    TCP - 传输控制协议，面向连接，该协议提供可靠的全双
               工的子节流
    UDP - 用户数据报协议，非面向连接，没有tcp协议可靠但
               是速度比较快
    IP  -  互联网协议，是上述两种协议的底层协议
1.2 IP地址 和 子网掩码的概念
(1)IP地址的概念和分类
     IP地址本质就是在互联网中的唯一地址标识，其数据类型为32位二进制组成的整数(ipv4)，当然也有128位二进制组成的整数(ipv6)
     日常生活中描述IP地址的主要形式为: 点分十进制表示法，也就是将每8位二进制转换为一个十进制整数，不同的十进制整数之间通过小数点分隔；
如：
     0x01020304  =>  1.2.3.4
查看IP地址的方式:
     windows系统中： ipconfig    ipconfig/all
     linux系统中： ifconfig    /sbin/ifconfig
     IP地址主要分为两部分：  网络地址  +  主机地址，根据网络地址和主机地址的划分，将IP地址分为以下4类：
     A类：0 + 7位网络地址 +  24位主机/本地地址
     B类：10 + 14位网络地址 + 16位主机/本地地址
     C类：110 + 21位网络地址 + 8位主机/本地地址
     D类：1110 + 28位多播地址
(2)子网掩码的概念
     子网掩码本质就是用于帮助IP划分具体的网络地址和主机地址，也可以用于判断两个IP地址是否在同一个局域网中，具体的划分方法为：按位&运算进行
如：
    IP地址：172.30.100.41
 子网掩码：255.255.255.0   &
-----------------------------------------------
                172.30.100   -  网络地址 
                             41   -  主机地址
练习：
     判断以下两个IP地址是否在同一个局域网中？？？
     166.111.160.1   和  166.111.161.45
      子网掩码全部为：255.255.254.0
解析：
     IP地址：166.111.160.1 
  子网掩码：255.255.254.0   &
-----------------------------------------------
                166.111.160   -  网络地址
    IP地址：166.111.161.45
 子网掩码：255.255.254.0   &
-----------------------------------------------
                166.111.160   -  网络地址
综上所述：
     上述两个IP地址在同一个局域网中
1.3 端口号和字节序的概念
(1)端口号
     IP地址 - 互联网中的地址标识，通过该地址可以定位主机
     端口号 - 主要用于定位某一台主机上的具体进程
     端口号的数据类型是：unsigned short类型，范围是：0 ~ 65535，其中0 ~ 1024之间的端口由系统占用，因此编程指定端口号时，建议从1025开始使用
     网络编程中需要提供：IP地址  +  端口号
(2)字节序的概念
小端系统：低位内存地址存放低位数据的系统
大端系统：低位内存地址存放高位数据的系统
如：
     对于十六进制的数据 0x12345678来说
小端系统中按照地址从小到大依次：0x78 0x56 0x34 0x12
大端系统中按照地址从小到大依次：0x12 0x34 0x56 0x78
一般性原则：
     对于多字节整数来说，为了避免不同的操作系统中存放字节序的不同而造成的数据不一致性问题，习惯上将所有发送出去的多字节整数先转换为网络字节序再发送，而将所有从网络上收到的多字节整数先转换为主机字节序再解析，而网络字节序本质就是大端系统的字节序
2.基于Socket的一对一通信模型
2.1 基本概念
    Socket  -  本意为插座的意思，表示逻辑上的通信载体
2.2 基本模型
服务器：
    (1)创建socket，使用socket函数
    (2)准备通信地址，使用结构体变量
    (3)绑定socket和	通信地址，使用bind函数
    (4)进行通信，使用read/write函数
    (5)关闭socket，使用close函数
客户端：
    (1)创建socket，使用socket函数
    (2)准备通信地址，是服务器的地址
    (3)连接socket和通信地址，使用connect函数
    (4)进行通信，使用read/write函数
    (5)关闭socket，使用close函数
2.3 相关函数的解析
(1)socket函数
     #include <sys/types.h>
     #include <sys/socket.h>
     int  socket(int  domain, int type, int protocol);
第一个参数：协议族/域，决定本地通信还是网络通信
     AF_UNIX/AF_LOCAL  -  实现本地通信
     AF_INET  -  实现基于ipv4网络协议的通信
     AF_INET6  -  实现基于ipv6网络协议的通信
第二个参数：通信的类型，决定具体的通信协议
     SOCK_STREAM  -  提供有序的、可靠的、双向的面向连
            接的字节流通信，本质就是基于tcp协议的通信模式
     SOCK_DGRAM  -  提供不可靠的，非面向连接的数据报
            通信，本质就是基于udp协议的通信模式
第三个参数：特殊的协议，直接给0即可
返回值：成功返回socket的描述符，失败返回-1
函数功能：
      主要用于创建端点来实现进程间的通信
(2)通信地址的结构体类型
a.通用的通信地址
   struct sockaddr 
   {
        sa_family_t sa_family;
        char        sa_data[14];
   };
   该结构体主要用于函数的形参类型，很少定义结构体变量
b.实现本地通信的通信地址
   #include <sys/un.h>
   struct sockaddr_un
   {
         sa_family_t  sun_family;//地址族，相当socket函数
                   中的第一个参数
         char  sun_path[];//socket文件的路径名
   };
   该结构体专门用于准备本地通信的通信地址
c.实现网络通信的通信地址
   #include <netinet/in.h>
   struct sockaddr_in
   {
        sa_family_t  sin_family; //地址族 AF_INET
        in_port_t       sin_port ;// 端口号
        struct in_addr  sin_addr;// ip地址
   };
   struct in_addr
   {
        in_addr_t  s_addr; 
   };
   该结构体专门用于准备网络通信的通信地址
(3)bind函数
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>
    int bind(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：通信地址的首地址，需要类型转换
第三个参数：通信地址的大小，使用sizeof计算即可
函数功能：
      主要用于socket和通信地址
(4)connect函数
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>
     int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
函数功能：
     主要用于连接socket和通信地址，参数和返回值参考bind函数即可
(5)字节序的转换函数
     #include <arpa/inet.h>
     uint32_t htonl(uint32_t hostlong);
 => 主要用于将32位的主机字节序转换为网络字节序
     uint16_t htons(uint16_t hostshort);
 => 主要用于将16位的主机字节序转换为网络字节序
     uint32_t ntohl(uint32_t netlong);
 => 主要用于将32位的网络字节序转换为主机字节序
     uint16_t ntohs(uint16_t netshort);
 => 主要用于将16位的网络字节序转换为主机字节序
(6)IP地址的转换函数
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    in_addr_t inet_addr(const char *cp);
 => 主要用于将字符串形式的IP地址转换为整数类型
    char *inet_ntoa(struct in_addr in);
 => 主要用于将结构体类型的IP地址转换为字符串类型
作业：
     练习和理解基于socket的通信模型
明日预报：
     (1)基于tcp的网络通信模型
     (2)tcp和udp协议的区别
     (3)基于udp的网络通信模型
 
复习：
1.网络的基本常识
1.1 七层网络模型和常用的网络协议
     七层网络模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
     TCP  -  传输控制协议，面向连接的协议，提供可靠的全双工的字节流通信
     UDP  -  用户数据报协议，非面向连接，没有tcp可靠但是传输速度比较快
     IP   -  互联网协议，上述协议的底层协议
1.2 IP地址和子网掩码
    IP地址本质就是互联网中的唯一地址标识，是32位二进制组成的整数(ipv4)，还有128位二进制组成的整数(ipv6)
    日常生活中，采用点分十进制表示法描述IP地址
    IP地址分为:  网络地址  +  主机地址
    子网掩码 -  主要用于划分IP地址的网络地址和主机地址
         IP地址 &  子网掩码
1.3 端口号和字节序
    IP地址 -  定位具体的某一台主机
    端口号 - 定位具体主机中的某一个进程
   端口号的数据类型是：unsigned short类型，范围是：0 ~ 65535，其中0 ~ 1024被系统占用
小端系统：将低位数据存放在低位内存地址的系统
大端系统：将地位数据存放在高位内存地址的系统
2.基于socket的一对一通信模型
服务器：
      (1)创建socket，使用socket函数
      (2)准备通信地址，使用结构体类型
      (3)绑定socket和通信地址，使用bind函数
      (4)进行通信，使用read/write函数
      (5)关闭socket，使用close函数
客户端：
      (1)创建socket，使用socket函数
      (2)准备通信地址，使用服务器的地址
      (3)连接socket和通信地址，使用connect函数
      (4)进行通信，使用read/write函数
      (5)关闭socket，使用close函数
-----------------------------------------------------------------------------
今天内容：
     (1)基于tcp协议的网络通信模型
     (2)tcp协议和udp协议的比较
     (3)基于udp协议的网络通信模型
1.基于tcp协议的网络通信模型(重点)
1.1 通信模型
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)监听，使用listen函数
     (5)响应客户端的连接请求，使用accept函数
     (6)进行通信，使用read/write函数
     (7)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用服务器的地址
     (3)连接socket和通信地址，使用connect函数
     (4)进行通信，使用read/write函数
     (5)关闭socket，使用close函数
1.2 相关函数的解析
(1)listen函数
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>
    int listen(int sockfd, int backlog);
第一个参数：socket描述符，socket函数的返回值
第二个参数：指定等待连接队列的最大长度
        (允许在该socket上等待被连接的最大个数)
函数功能：
     主要用于将第一个参数指定的socket标记为被动的socket，也就是该socket专门用于使用accept函数去响应即将到来的连接请求，不再作为通信使用
(2)accept函数
     #include <sys/types.h> 
     #include <sys/socket.h>
     int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：结构体指针，用于存放客户端的通信地址
第三个参数：通信地址的大小
返回值：成功返回用于通信的socket的描述符，失败返回-1
函数功能：
      主要用于响应等待被处理队列中的第一个连接请求
注意：
      socket函数返回的描述符 主要用于监听和响应
      accept函数返回的描述符 主要用于通信的
练习：
     使用tcp协议的编程模型实现一对多的通信
a.要求服务器可以不断地响应客户端的连接请求；
b.要求服务器可以同时和多个客户端进行通信；
c.要求针对每一个客户端可以进行不断地通信；
d.要求当客户端发来"bye"时，表示客户端下线，终止对应
    的子进程；
e.要求使用信号2来关闭服务器；
f. 要求客户端发送的消息由用户手动输入；
2.tcp协议和udp协议的比较
2.1 tcp协议的概念和特性
    tcp - 传输控制协议，是一种面向连接的协议，类似打电话
         建立连接   =>  进行通信   =>  断开连接
         在通信的整个过程中全程需要保持连接
优点和缺点：      
     (1)保证了数据传输的可靠性和有序性，也就是当数据接受
方没有反馈确认信息时，数据发送方会重新发送数据，并且对发送的数据进行编号，接受方可以根据编号进行排序
     (2)属于全双工的字节流通信方式
     (3)数据的接受方可以控制数据发送方的流量大小
     (4)服务器的压力比较大，资源的占用率比较高，发送的速度也会比较慢；
    
2.2 udp协议的概念和特性
    udp - 用户数据报协议，非面向连接的协议，类似发短信
    在通信的整个过程中不需要全程保持连接
优点和缺点：
    (1)服务器端的压力比较小，资源的占用率比较低，发送的速度比较快；
    (2)不能保证数据的可靠性和有序性，数据报也会丢失；
    (3)属于全双工的数据报通信方式
    (4)数据的接受方不能控制数据发送方的流量大小
3.基于udp协议的通信模型(重点)
3.1 通信模型
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)进行通信，使用sendto/recvfrom函数 
     (5)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用服务器的地址
     (3)进行通信，使用sendto/recvfrom函数 
     (4)关闭socket，使用close函数
3.2 相关函数的解析
(1)sendto函数
    #include <sys/types.h>
    #include <sys/socket.h>
     ssize_t send(int sockfd, const void *buf, size_t len, int flags);
     ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：被发送数据的首地址
第三个参数：被发送数据的大小
第四个参数：发送的标志，默认给0表示产生阻塞
第五个参数：数据接受方的通信地址
第六个参数：数据接受方通信地址的大小
返回值：成功返回实际发送的数据大小，失败返回-1
函数功能：
      主要用于将指定的消息发送到指定的地址上
(2)recvfrom函数
     #include <sys/types.h>
     #include <sys/socket.h>
     ssize_t recv(int sockfd, void *buf, size_t len, int flags);
     ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：存放接受到数据的缓冲区首地址
第三个参数：接受的数据大小
第四个参数：接受的标志，默认给0即可
第五个参数：保存数据发送方的通信地址(来电显示)
第六个参数：通信地址的大小
返回值：成功返回实际接受的数据大小，失败返回-1
函数功能：
      主要用于接受指定的数据并提供来电显示的功能
注意：
     在vi的命令模式下，执行命令：
           :n1,n2 >  表示将n1行到n2行之间的代码向右缩进
           :n1,n2 <  表示将n1行到n2行之间的代码向左缩进
           :n1,n2  co  n3  表示将n1行到n2行之间的代码拷贝
                            到n3行的下面
           :n1,n2  mo  n3  表示将n1行到n2行之间的代码剪切
                            到n3行的下面
     虽然read/write函数也可以实现接受和发送消息，但是在以后的网络编程中要求优先使用send/recv/sendto/recvfrom函数，尽量不去使用read/write函数
作业：
     使用udp协议的通信模型编程实现一个时间服务器，也就是只要服务器收到客户端发来的消息，则将当前服务器的系统时间发送给该客户端
明日预报：
    (1)多线程的编程
         
复习：
1.基于tcp协议的通信模型(重点)
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)监听，使用listen函数
     (5)响应客户端的连接请求，使用accept函数
     (6)进行通信，使用send/recv函数
     (7)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用服务器的地址
     (3)连接，使用connect函数
     (4)进行通信，使用send/recv函数
     (5)关闭socket，使用close函数
2.基于udp协议的通信模型(重点)
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)进行通信，使用recvfrom/sendto/recv/send函数
     (5)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，服务器的地址
     (3)进行通信，使用sendto/recvfrom/send/recv函数
     (4)关闭socket，使用close函数
作业：   
-----------------------------------------------------------------------------
今天内容：
     (1)多线程的编程
     (2)综合小项目
1.多线程的编程
1.1 基本概念
      线程本质就是进程内部的程序流，隶属于进程，目前主流的操作系统都支持多进程，而在每一个进程的内部又可以支持多线程，从而实现并行处理的效果
      进程是重量级的，每个进程都需要独立的内存空间，新建进程对资源的消耗是比较大的；而线程是轻量级的，共享所在进程的内存资源，但是每个线程都有一个独立的栈区；
1.2 线程的创建
(1)pthread_create函数
     #include <pthread.h>
     int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);
第一个参数：整数指针，用于存放新线程的线程编号
第二个参数：线程的属性，给NULL选择默认的属性
第三个参数：函数指针类型，新线程的处理函数
第四个参数：作为第三个参数指向函数的实参
返回值：成功返回0，失败返回具体的错误编号
函数功能：
      主要用于在当前正在调用的进程中启动新线程，让新线程去执行第三个参数指向的函数，函数执行完毕后，线程结束
注意：
       Compile and link with -pthread.
(2)多线程执行的关系
     执行main函数的线程  叫做  主线程
     使用pthread_create函数创建出来的新线程 叫做 子线程
     多线程创建完毕之后各自独立运行，执行的先后次序取决于操作系统，多线程之间相互独立也会相互影响，因为主线程结束时main函数结束，而main函数结束表示整个进程结束，一旦整个进程结束，则整个进程内部的所有线程结束
(3)pthread_self函数
     #include <pthread.h>
     pthread_t pthread_self(void);
函数功能：
     主要用于获取当前正在调用线程的编号，通过返回值返回
     Compile and link with -pthread.
练习：
     使用malloc函数申请4个字节的动态内存，提示用户输入一个半径存放到动态内存中，使用pthread_create函数创建子线程，在线程处理函数中计算圆形的周长和面积并且打印出来，等待子线程结束后，释放动态内存
1.3 线程的汇合和分离
(1)pthread_join函数
     #include <pthread.h>
     int pthread_join(pthread_t thread, void **retval);
第一个参数：线程的编号(等待哪一个线程)
第二个参数：该参数不为空时，将目标线程的退出状态信息拷
       贝到*retval指向的位置中
返回值：成功返回0，失败返回错误编号
函数功能：
      主要用于等待参数一指向的线程终止，并且获取终止的退出状态信息，同时回收该线程的所有资源，当然前提是thread指向的线程可以被等待
      Compile and link with -pthread.
练习：
     使用pthread_create函数创建子线程，在子线程中计算1 ~ 100之间的和并存放在sum变量中，要求将最终的计算结果返回给主线程，主线程通过pthread_join函数进行接受并打印出来
(2)pthread_detach函数
     #include <pthread.h>
     int pthread_detach(pthread_t thread);
函数功能：
     主要用于将参数指定的线程设置为分离状态，一个分离状态的线程终止时，它的资源会被自动地释放给系统不需要其他线程的帮助/等待/加入，其他线程调用pthread_join也无法等待
     Compile and link with -pthread
1.4 线程的终止和取消
(1)pthread_exit函数
    #include <pthread.h>
    void pthread_exit(void *retval);
函数功能：
     主要用于终止当前正在调用的线程，该函数的参数作为当前终止线程的退出状态信息，在同一个进程中的其他线程可以通过pthread_join来获取该参数值
     Compile and link with -pthread.
(2)pthread_cancel函数
     #include <pthread.h>
     int pthread_cancel(pthread_t thread);
函数功能：
//给thread线程发送终止信号
     主要用于给参数指定的线程发送取消的请求，是否取消以及何时取消取决于线程的属性信息:state  和  type
     Compile and link with -pthread.
     #include <pthread.h>
     int pthread_setcancelstate(int state, int *oldstate);
第一个参数：设置新的取消状态
     PTHREAD_CANCEL_ENABLE - 表示可以被取消(默认)
     PTHREAD_CANCEL_DISABLE - 表示不可以被取消
第二个参数：用于带出旧的取消状态，给NULL表示不获取
     int pthread_setcanceltype(int type, int *oldtype);
第一个参数：设置新的取消类型
     PTHREAD_CANCEL_DEFERRED - 延迟取消(默认)
     PTHREAD_CANCEL_ASYNCHRONOUS - 立即取消
第二个参数：用于带出旧的取消类型，给NULL表示不获取
     Compile and link with -pthread.
2.线程的同步问题
2.1 基本概念
    当一个进程中有多个线程时，多线程之间共享所在进程的资源，如果多个线程同时访问同一个共享资源时，需要相互协调，以防止数据出现不一致和不完整的问题，线程之间的协调和通信叫做线程的同步问题
2.2 实现线程同步的具体方案
     让多个线程依次串行访问共享资源即可
2.3 使用互斥量/互斥锁实现线程的同步
(1)定义互斥量
     pthread_mutex_t  mutex;
(2)初始化互斥量
     pthread_mutex_init(&mutex,NULL);
(3)使用互斥量进行加锁
     pthread_mutex_lock(&mutex);
(4)使用共享资源
(5)使用互斥量进行解锁
     pthread_mutex_unlock(&mutex);
(6)如果不再使用，销毁互斥量
     pthread_mutex_destroy(&mutex);     
2.4 使用信号量实现线程的同步问题
(1)基本概念
     信号量本质就是一个计数器，主要用于控制同时访问共享资源的进程/线程个数
     当信号量的值为1时，效果等同于互斥量；
(2)使用流程
    #include <semaphore.h>
    a.定义信号量
       sem_t sem;
    b.初始化信号量
       sem_init(&sem,0,最大的初始值);
    c.获取一个信号量(信号量的值减1)
       sem_wait(&sem);
    d.使用共享资源
    e.释放一个信号量(信号量的值加1)
       sem_post(&sem);
    f.如果不再使用，删除信号量
       sem_destroy(&sem);
3.综合小项目
     采用C/S架构通过tcp通信模型和多线程实现聊天室
服务器：
     (1)要求服务器可以不断地响应客户端的连接请求
          => 使用while(1)无限循环
          => 将每一个连接上来的客户端通信地址和对应的描述
                 符保存起来，采用数组/链表都可以
     (2)要求服务器可以同时和多个客户端通信
          => 使用多线程的技术来实现
     (3)要求服务器针对每一个客户端可以不断地通信
          => 使用while(1)无限循环
     (4)要求客户端发来"bye"时，表示客户端已下线
          => 进行字符串比较，终止对应的线程pthread_exit
          => 从数组/链表中删除已经下线的客户端信息
     (5)要求服务器可以将接受到的消息转发给其他所有客户端
          => 使用send函数对上述保存过的每一个描述符进行
                发送数据即可
          => 注意跳过已经下线的客户端
     (6)使用信号2来关闭服务器
          => 对信号2进行自定义处理
客户端：
     (1)要求每一个客户端启动时需要指定一个昵称
     (2)要求客户端不断地和服务器进行通信，发送的内容由
          用户手动输入
     (3)要求客户端收发功能独立运行，采用多线程技术
     (4)当客户端发送"bye"时，表示客户端下线
扩展功能：
     (1)编程实现传输文件的功能
     (2)使用网络编程和多线程技术重构银行项目
1.自我介绍
   马如忠     ruzhongMa    小马哥    
   marz@tedu.cn 
   赠送一句话：
        程序员是代码喂出来的   
   永久性的作业：
        苦练指法！
   
2. 课程的简介
2.1 课程阶段的简介
     Unix/linux系统下的基本命令
  => 主要学习Unix/linux中常用的命令
  => 依赖于具体的操作系统，但是部分命令与windows相同
  
     标准C语言的学习
  => 主要学习标准C语言的基本语法
  => 不依赖于具体的操作系统，绝大部分程序可以在任意系
       统中使用
     
     数据结构和算法
  => 主要学习常用的数据结构和算法，理解编程的思想
  => 不依赖于具体的编程语言，也不依赖于具体的操作系统
     Unix/linux系统下的高级C编程
  => 主要学习操作系统的基本原理以及常用的API函数
  => 依赖于具体的编程语言，也依赖于具体的操作系统
  => 用时 15天 左右
  目前主流的主机操作系统：
       unix系列/linux系列/windows系列
       windows系列： Xp/vista/win7/win8/win8.1/win10
     
   目前主流的移动终端操作系统：
        android/ios/window10
 
2.2 Unix/linux系统下高级C编程的主要内容
    (1)Unix/linux系统下的开发方式和编程基础
    (2)Unix/linux系统下的内存管理技术
    (3)Unix/linux系统下的文件管理和目录操作
    (4)Unix/linux系统下的进程管理  
    (5)Unix/linux系统下的信号处理
    (6)Unix/linux系统下的进程间通信技术
    (7)Unix/linux系统下的网络编程技术
    (8)Unix/linux系统下的多线程技术
----------------------------------------------------------------------------
今天内容：
    (1)Unix/linux系统的简介
    (2)gcc编译器的使用
    (3)多文件结构的编程
    (4)常用的预处理指令
    (5)环境变量的概念和使用
1.Unix/linux系统的简介
1.1 Unix系统的简介
      在1969年左右，编写操作系统时采用的汇编语言，编写和维护都非常不方便，贝尔实验室  汤普逊 研发了一门语言叫做B语言， 贝尔实验室 丹尼斯-里奇 在B语言的基础上做了修改和扩展，叫做 New B语言，后来改名为C语言
      C语言诞生于1972年，在编程语言排行榜上占据重要
的地位    
      Unix系统诞生于1970年，具有多用户、多任务以及支持多种处理器的特点  
1.2 linux系统的简介
     linux系统是一款  自由免费开放源代码的类Unix操作系统
     ubuntu 系统是一款linux系列的操作系统，每六个月会发布一个版本，分别是：4月 和  10月
     当前教学环境： ubuntu  12.04版本   32位的操作系统
     
2.gcc的使用
2.1 基本概念
    gcc 原名叫做 GNU C Compiler(编译器)，只支持对C语言的编译处理，后来对该编译器做了扩展，支持了更多的编程语言，如C++等，因此改名为 GNU  Compiler Collection
2.2 基本功能(重点)
     编程时采用的是高级语言，如C语言等，高级语言编写的程序代码无法被计算机直接执行，需要将高级语言转换为汇编语言，再将汇编语言转换为机器指令，最后链接生成可执行文件才能被计算机执行，而上述过程主要包含以下四步走：
(1)预处理/预编译
    - 主要用于实现头文件的扩展和宏替换等
(2)编译
    - 主要用于将高级语言翻译成汇编语言，得到汇编文件
(3)汇编
    - 主要用于将汇编语言翻译成机器指令，得到目标文件
(4)链接
    - 主要用于将目标文件和库文件进行链接，得到可执行文件
2.3 常用的编译选项
(1)熟练掌握的选项
     gcc/cc -E  xxx.c
  => 表示对高级源代码文件进行预处理操作，默认输出到控
        制台上，使用-o选项来改变输出位置为 xxx.i
      
     gcc/cc -S xxx.i
  => 表示将预处理文件经过编译翻译成汇编语言文件(xxx.s)
     gcc/cc -c xxx.s
  => 表示将汇编语言文件翻译成机器语言文件(xxx.o)
     gcc/cc xxx.o
  => 表示链接目标文件和库文件生成可执行文件(a.out)
     gcc/cc xxx.c
  => 表示编译链接生成可执行文件(需要执行上述4步走)
练习：
     gcc/cc -E xxx.c -o xxx.i
     gcc/cc -S xxx.i/xxx.c
     gcc/cc -c xxx.s/xxx.i/xxx.c
     gcc/cc xxx.o/xxx.s/xxx.i/xxx.c
(2)熟悉的选项
     -std   表示用于指定具体的C标准
     -v      表示用于查看编译器的版本信息
     -Wall 表示尽可能多地显示所有的警告信息
     -Werror 表示把警告当作错误进行处理
(3)了解的选项
     -g  表示生成调试信息
     -x   表示用于指定源代码的编程语言
     -O  表示进行优化处理
(4)扩展的选项
     man  命令/函数名称/gcc/cc 
     作业： 装个英文词典 -  星际译王 
2.4 常见的文件后缀
     .h  - 头文件             .c  - 源文件
     .i   - 预处理文件       .s  - 汇编文件
     .o  - 目标文件            
     .a  - 静态库文件        .so - 共享库文件
3.多文件结构的编程
3.1 多文件结构的主要组成
     .h - 头文件，主要存放结构体的定义，函数的声明等
     .c - 源文件，主要存放函数的定义等
     .a - 静态库文件，主要对功能函数的打包
     .so - 共享库文件，主要对功能函数的打包
3.2 头文件的详细内容(重点)
(1)头文件卫士
    #ifndef xxxx
    #define xxx
    #endif //xxx
(2)包含其他头文件
    #include <stdio.h>
    ... ...
(3)进行宏定义
    #define PI 3.14
    ... ...
(4)结构体的定义以及对类型起别名
    typedef struct 
    {
	 link lk;
    } stack;
(5)外部变量/函数的声明
    extern int num;
    void show(void);
    ... ...
注意：
    变量/函数的定义不能放在头文件中，因为当多个.c包含该头文件时，在一起编译链接的情况下会引发重定义的错误信息
例子：
     采用多文件的结构进行编程，要求根据用户输入的半径计算出圆形的周长和面积
     周长： 2 * PI * r 
     面积： PI * r * r
作业：
     练习从高级源代码到可执行文件的生成步骤
明日预报：
    (1)常用的预处理指令
    (2)环境变量的概念和使用
    (3)库文件的概念和使用
 
      
 
           
  
   
复习：
1.Unix/linux系统的简介
1.1 Unix系统的简介
     C语言诞生于1972年，在编程语言排行榜上占据重要
的地位
     Unix系统诞生于1970年，具有支持多用户、多任务、以及多种处理器的特点
1.2 linux系统的简介
     linux系统是一款  免费自由开发源代码的类Unix操作系统
    
2.gcc编译器的使用
2.1 基本概念
     原名叫做GNU C Compiler  该名为 GNU Compiler Collection
2.2 基本功能
     根据高级语言编写的源代码，来生成最终的可执行文件
(1)预处理/预编译   -E   
(2)编译  -S
(3)汇编   -c
(4)链接   gcc/cc xxx.o
2.3 常用的编译选项
     -E    -S   -c   -o 
     -std   -v   -Wall   -Werror
     -g   -x   -O
     man gcc/cc
2.4 常用的文件后缀
     .h     .c    .i     .s     .o     .a     .so
3.多文件结构的编程
3.1 多文件结构的主要组成
      .h   .c   .a    .so
3.2 头文件中的详细内容
(1)头文件卫士
     #ifndef ...
     #define ...
     #endif
(2)包含其他头文件
     #include <stdio.h>
(3)进行宏定义
     #define PI 3.14
(4)结构体的定义以及对类型其别名
     typedef struct
     {
          int id;
          char name[20];
     }Student; 
(5)外部变量/函数的声明
     extern int num;
     void show(void);
----------------------------------------------------------------------------
今天内容：
    (1)常用的预处理指令
    (2)环境变量的概念和使用
    (3)库文件的概念和使用
1.常用的预处理指令
1.1 复习标C中学过的预处理指令
     #include   包含...
     #define     定义...
     #undef      取消宏定义
     #ifdef        如果定义...
     #ifndef      如果没有定义...
     #if             如果...
     #elif          否则如果...
     #else         否则...
     #endif        结束如果
     ... ...
1.2 学习常用的新指令
     #line  整数n
 => 主要用于将下一行的行号修改为第n行
 => 可以用于控制调试阶段出错的行号
     #warning  字符串
  => 表示在预处理阶段产生一个警告信息
     #error 字符串
  => 表示在预处理阶段产生一个错误信息
  => 可以用于在调试阶段产生错误/警告信息
思考：
     #if   和 普通的if之间有什么区别呢？？
       #if  - 在编译期间做检查和判断
         if   - 在运行阶段做检查和判断
     #pragma GCC dependency 文件名
 => 表示当前文件依赖于指定的文件名，如果指定的文件最后
       一次修改时间晚于当前文件，则产生警告信息
 => 可以用于在调试阶段去监控具体的文件
老杨：vi show.c
       void show(void)
       {
             printf("我是帅哥我怕谁\n");
       }
小马哥：vi main.c
       #pragma GCC dependency "show.c"
       int main(void)
       {
             show();
             return 0;
       }
       #pragma GCC poison 标识符
   => 主要用于将指定的标识符设置为毒药，一旦使用该标识
        符则产生错误信息
         
      #pragma pack(整数n)
   => 表示设置结构体按照n的整数倍进行对齐和补齐
   => 主要用于通过上述方式来节省内存空间
        
1.3 常用的预定义宏
    __FILE__  -  用于获取预定义宏所在的文件名   %s
    __LINE__  -  用于获取预定义宏所在的行号      %d
    __DATE__ -  用于获取预定义宏所在文件的最后一次
                       编译日期  %s
    __TIME__ -  用于获取预定义宏所在文件的最后一次
                       编译时间  %s
    ... ...
2.环境变量的概念和使用
2.1 基本概念
      环境变量 - 一般是指在操作系统中用来指定操作系统运行的相关参数的特殊变量，也就是说环境变量就是用于存放系统/软件环境 相关参数信息的 特殊变量
      Path/PATH本质就是一种环境变量，路径存放在该环境变量中的应用程序/软件 可以通过文件名直接运行，从而省略路径信息
2.2 配置方法
(1)Windows Xp系统中的配置方法
      我的电脑 => 右键，选择属性  => 高级  =>  环境变量 => 系统变量中，找到Path,点击编辑  =>  在Path变量值的最后增加分号，再添加新路径  => 一路点击确定即可
      其中分号就是一个路径分隔符，用于划分不同的路径
      (切记 不要删除Path变量中之前的变量值)
(2)linux系统中的配置方法
      打开终端输入：  
           export PATH=$PATH:.
                $PATH - 表示获取环境变量PATH原来的数值
                     ：    - 表示路径分隔符，用于划分不同的路径
                       .  - 表示当前目录
      执行上述指令之后，表示把当前目录所在的路径追加到环境变量PATH的变量值末尾
      上述配置方法只对当前终端有效，新开的终端无法使用，为了配置永久性生效，vi ~/.bashrc文件中，编写以下代码：
      export PATH=$PATH:.
      保存退出之后，使用source ~/.bashrc文件，让配置文件中的指令立即生效
处理意外情况的方法：
     打开主目录，在主目录中使用快捷键 ctrl + h来显示所有的隐藏目录和文件，找到.bashrc文件，点击鼠标右键，选择使用文件编辑器的方式打开，修改文件内容后，保存关闭即可
2.3 编程相关的常用环境变量
     CPATH/C_INCLUDE_PATH 
  - 主要用于存放C语言头文件所在的路径
     CPLUS_INCLUDE_PATH 
  - 主要用于存放C++语言头文件所在的路径
     LIBRARY_PATH 
  - 主要用于存放库文件路径，解决编译链接时的问题
     LD_LIBRARY_PATH
  - 主要用于存放共享库所在的路径，解决运行时的问题
练习：
     采用多文件的结构进行编程，编写以下3个文件：
        add.h - 声明一个计算两个int类型参数和并返回的函数
        add.c  - 实现头文件中声明的函数
        main.c - 调用自定义的函数即可
2.4 查找头文件的主要方式
(1)#include <>
     - 表示在系统默认的路径中查找该头文件中
     - /usr/include/ ...
     - 可以使用命令whereis 来查找具体的头文件
(2)#include ""
     - 表示优先在当前目录中查找该头文件，查找不成功时，
       也会去系统默认的路径中进行查找
(3)配置环境变量CPATH/C_INCLUDE_PATH
       export CPATH=$CPATH:..
(4)采用编译选项进行指定(重点)
       gcc/cc xxx.c -I 头文件所在的路径
       gcc/cc xxx.c -I ..
注意：
      方法(1)(2)的缺点在于：一旦头文件的位置发生改变，则需要修改源程序来解决问题
      方法(3)的缺点在于：当有多个项目需要配置环境变量时，可能会引起冲突
      方法(4)的优势在于既不需要修改源程序，也不会引起多个项目的冲突问题，因此优先采用此方法
3.库文件的概念和使用
      在大型项目中，如果每个功能函数都存放在一个独立的.o文件中，那么项目管理变成灾难问题，因此采用库文件来解决该文件，具体的解决方案如下：一般按照功能模块将多个.o文件打包成一个/多个库文件，编写者只需要提供库文件和头文件即可
     库文件主要分为两种： 静态库文件(.a) 和共享库文件(.so)
3.1 静态库的概念和特性
(1)基本概念
     静态库本质就是由若干个.o文件打包生成的.a文件
     链接静态库的方式就是将库中被调用的代码指令复制到调用模块中，体现在最终的可执行文件中
(2)基本特性
优点：
      a.不需要跳转，因此效率会比较高
      b.可以脱离静态库文件
缺点：
      a.最终生成的可执行文件会比较大
      b.修改和维护都非常不方便
注意：
      使用ldd a.out的方式查看所以来的库文件
      使用gcc/cc -static xxx.c的方式强制要求按照静态库的方式进行链接处理，最终生成的可执行文件比较大
作业：
     复习uc讲过的内容
明日预报：
     (1)库文件的概念和使用
     (2)C语言中的错误处理
     (3)环境表的概念和使用
      
   
 
     
               
     
    
 
复习：
1.常用的预处理指令
   #line 整数n
   #warning 字符串
   #error 字符串
   
   #pragma GCC dependency 文件名
   #pragma GCC poison 标识符
   #pragma pack(整数n)   
2.环境变量的概念和使用
2.1 基本概念
   环境变量 - 用于存放系统/软件环境参数信息的特殊变量
   Path/PATH 就是一种环境变量，存放应用程序/软件的路径信息，启动应用程序/软件 只需要文件名即可
2.2 配置方法
(1)Xp系统
     我的电脑  => 右键，选择属性  => 高级  => 环境变量 => 系统变量Path，点击编辑，在变量值的末尾增加分号，添加新路径  =>  一路点击确定即可
(2)linux系统中配置方法
     终端中： export PATH=$PATH:.
      vi ~/.bashrc文件
      source ~/.bashrc
2.3 常用的环境变量
     CPATH/C_INCLUDE_PATH
     CPLUS_INCLUDE_PATH
     LIBRARY_PATH 
     LD_LIBRARY_PATH
     
2.4 查找头文件的主要方式
(1)#include <>
(2)#include ""
(3)配置环境变量CPATH  
     export CPATH=$CPATH:..
(4)gcc/cc xxx.c -I 头文件所在的路径(重点)
3.库文件的概念和使用
3.1 静态库的概念和特性
(1)基本概念
     静态库本质就是由若干个.o文件打包生成的.a文件
     链接静态库的方式本质就是将被调用的代码指令复制到调用模块中，体现在最终的可执行文件中
(2)基本特性
优点：
     a.不需要跳转，执行效率高
     b.可以脱离静态库文件
缺点：
     a.最终生成的可执行文件会比较大
     b.修改和维护都不方便
----------------------------------------------------------------------------
今天内容：
    (1)库文件的概念和使用
    (2)C语言中的错误处理
    (3)环境表的概念和使用
1.库文件的概念和使用
1.1 静态库的生成和调用步骤
(1)生成步骤
    a.编写源程序xxx.c，如：vi add.c
    b.只编译不链接生成目标文件xxx.o
       如： cc -c add.c
    c.生成静态库文件
        ar -r/*插入*/ lib库名.a 目标文件名
        ar -r libadd.a add.o
(2)调用步骤
    a.编写测试源程序xxx.c，如：vi main.c
    b.只编译不链接生成目标文件xxx.o
       如： cc -c main.c
    c.链接静态库文件生成可执行文件，链接方式有以下三种：
       1)直接链接
            cc 目标文件 静态库文件名
            如：cc main.o libadd.a
       2)采用编译选项进行链接(重点)
            cc 目标文件 -l 库名 -L 库文件所在的路径
            如：cc main.o -l add -L .
       3)通过配置环境变量LIBRARY_PATH进行链接
             export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add
1.2 共享库的基本概念和特性
(1)基本概念
     共享库本质就是由若干个.o文件打包生成的.so文件
     共享库和静态库的最大不同就是：链接共享库时并不会把被调用的代码指令复制到调用模块中，而是将被调用的代码指令在共享库中的相对地址嵌入到调用模块中
(2)基本特性
优点：
      a.共享库占用的空间比较小，也就是可执行文件比较小
      b.修改和维护都非常方便
缺点：
      a.需要跳转执行，因此执行效率比较低
      b.不可以脱离共享库文件
注意：
     目前主流的开发都采用共享库文件
1.3 共享库的生成和调用步骤
(1)生成步骤
    a.编写源程序xxx.c，如：vi add.c
    b.只编译不链接生成目标文件xxx.o
      如： cc -c -fpic/*小模式*/ add.c
    c.生成共享库文件
       gcc/cc  -shared/*共享的*/ 目标文件 -o lib库名.so
      如:   cc -shared add.o -o libadd.so 
(2)调用步骤
    a.编写测试源程序xxx.c，如：vi main.c
    b.只编译不链接生成目标文件xxx.o
       如： cc -c main.c
    c.链接共享库文件生成可执行文件，链接方式有以下三种：
       1)直接链接
            cc 目标文件 共享库文件名
            如：cc main.o libadd.so
       2)采用编译选项进行链接(重点)
            cc 目标文件 -l 库名 -L 库文件所在的路径
            如：cc main.o -l add -L .
       3)通过配置环境变量LIBRARY_PATH进行链接
             export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add    
注意：
     调用共享库文件时需要配置环境变量LD_LIBRARY_PATH
，具体的配置方法如下：
     export  LD_LIBRARY_PATH=$LD_LIBRARY_PATH:. 
注意：
    当同一个目录中具有相同库名的静态库和共享库时，使用gcc/cc编译链接时会自动优先选择共享库进行链接，如果希望链接静态库则使用-static选项来强制要求
1.4 共享库的动态加载
     #include <dlfcn.h>
     编译链接时需要指定选项  -ldl
(1)dlopen函数     
     void *dlopen(const char *filename, int flag);
第一个参数：字符串形式的文件名
第二个参数：具体的操作标志
      RTLD_LAZY - 延迟加载
      RTLD_NOW - 立即加载
返回值：成功返回共享库的句柄信息/地址，失败返回NULL
函数功能：
      主要用于加载第一个参数指定的共享库到内存中
(2)dlsym函数
     void *dlsym(void *handle,  const  char *symbol);
第一个参数：共享库的句柄，dlopen函数的返回值
第二个参数：字符串形式的符号，一般指函数名
返回值：成功返回函数名所对应的内存地址，失败返回NULL
函数功能：
      主要用于查找指定共享库中指定函数被加载到内存中地址
(3)dlclose函数
     int dlclose(void *handle);
函数功能：
     主要用于关闭/卸载参数指定的共享库，成功返回0，失败
     返回非0
(4)dlerror函数
     char *dlerror(void);
函数功能：
     主要用于获取dlopen/dlsym/dlclose函数执行期间产生的最近一个错误信息通过返回值返回，如果没有产生错误，则返回值为NULL
2.C语言中的错误处理
如：
     int main(void)
     {
           return 0; //表示程序正常结束
          // return -1;  // 表示程序出错结束
     }
2.1 C语言中的错误表现形式(错了吗？)
     一般来说，C语言中函数的错误表现形式如下：
     (1)对于返回值类型为int类型的函数来说，并且函数的计算结果不可能是负数时，使用返回-1表示出错，使用其他数据表示正常结束
     (2)对于返回值类型为int类型的函数来说，如果函数的计算结果可能是负数时，使用指针作为函数的参数将函数的计算结果带出去，而函数的返回值专门用于表示函数是否出错，习惯上使用-1表示出错，0表示正常结束
     (3)对于返回值类型为指针类型的函数来说，使用返回NULL表示函数出错，其他数据表示正常结束
     (4)如果不考虑函数是否出错，则返回值类型使用void即可
例子：
      按照上述要求，编写以下四个功能函数
      (1)要求返回1~10之间的随机数，如果随机数是5，则返回错误
      (2)比较两个int类型参数的大小，返回其中的最大值，如果两个参数相等，则返回错误
      (3)比较传入的字符串是否为"error"，如果是则返回错误，否则返回”ok“
      (4)打印传入的字符串即可
2.2 错误的编号（为什么错了？）
     errno本质就是一个int类型的全局变量，当函数调用出错时，会自动将错误的原因编号设置到errno中，因此可以通过errno的值来获取具体的错误原因
     #include <errno.h>
     该头文件中包含了errno全局变量的外部声明，以及常见的错误编号宏定义
     /etc/shadow - 存放了真实的密码信息，不过有加密
     /etc/passwd - 存放了当前系统的所有用户信息
文件的内容解析如下：
     tarena:  x:     1000   :  1000:
     用户名：密码：用户ID： 用户组ID
     tarena,,,:/home/tarena:  /bin/bash     
     注释信息 :    用户主目录    : shell的类型
作业：
     (1)查询函数strerror 和 perror的使用
     (2)编写两个功能函数，分别打印实心的菱形和空心的菱形，将这两个函数所在的.c文件分别打包成静态库和共享库进行调用，再练习一下共享库的动态加载
           *                        *
         ***                     * *
       *****                  *    *
         ***                     * *
           *                         *
明日预报：
     (1)C语言中的错误处理
     (2)环境表的概念和使用
     (3)内存管理技术
     
复习：
1.库文件的概念和使用
1.1 静态库的生成和调用步骤
(1)生成步骤
    a. vi add.c
    b. cc -c add.c
    c. ar -r libadd.a add.o
(2)调用步骤
    a. vi main.c
    b. cc -c main.c
    c. 链接的方式有三种：
        1) cc main.o libadd.a
        2) cc main.o -l add -L . 
        3) export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add
1.2 共享库的基本概念和特性
(1)基本概念
     共享库与静态库的最大不同之处：不会拷贝被调用的代码指令，而是将被调用代码指令在共享库中的相对地址拷贝到调用模块中
(2)基本特性
优点：
      a.共享库占用的空间比较小，可执行文件比较小
      b.修改和维护都比较方便
缺点：
      a.执行效率低
      b.不可以脱离共享库文件
1.3 共享库的生成和调用步骤
(1)生成步骤
    a. vi add.c
    b. cc -c -fpic add.c
    c.  cc -shared add.o -o libadd.so
(2)调用步骤
    a. vi main.c
    b. cc -c main.c
    c. 链接的方式有三种：
        1) cc main.o libadd.so
        2) cc main.o -l add -L . 
        3) export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add
注意：
    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.
1.4 共享库的动态加载
    #include <dlfcn.h>
     编译链接时需要指定 -ldl
    dlopen() - 打开/加载共享库文件
    dlsym() - 获取共享库中指定的函数地址
    dlclose() - 关闭/卸载共享库文件
    dlerror() - 获取具体的错误原因
2.C语言中的错误处理
2.1 C语言中的错误表现形式(错了吗？)
    (1)对于返回值类型为int类型的函数来说，并且函数的计算结果不可能是负数时，则返回-1代表错误，返回其他数据代表正常结束
    (2)对于返回值类型为int类型的函数来说，并且函数的计算结果可能是负数时，需要使用指针作为函数的参数将函数的计算结果带出去，而函数的返回值专门表示成功还是失败，使用-1表示错误，0表示成功
    (3)对于返回值类型为指针类型的函数来说，使用返回NULL表示错误
    (4)如果不考虑函数是否出错，则返回值类型给void
2.2 错误编号(为什么错了？)
     #include <errno.h>
     errno本质就是一个int类型的全局变量
     /etc/passwd - 包含了当前系统的用户信息
     /etc/shadow - 包含了系统中的真实密码信息
作业：
---------------------------------------------------------------------------
今天内容：
    (1)C语言中的错误处理
    (2)环境表的概念和使用
    (3)内存管理技术
1.C语言中的错误处理
1.1 错误信息
(1)strerror函数
     #include <string.h>
     char *strerror(int errnum);
函数功能：
     主要用于根据参数指定的错误编号翻译成对应的错误信息，通过返回值返回，当错误编号不合法时，返回“Unknown error nnn”
(2)perror函数(重点)
     #include <stdio.h>
     void perror(const char *s);
函数功能：
     主要用于向标准错误输出上打印最后一个错误信息，如果参数不为空时，则参数的内容原样输出，后面跟着一个冒号，一个空格，再跟着错误信息，并且最后自动换行
(3)printf函数(了解)
    printf("%m\n");  => 打印具体的错误信息
注意：
    判断函数是否出错需要根据函数的返回值进行判断，在明确函数已经出错的情况下，可以通过errno来获取具体的错误原因，但是不能直接使用errno来作为判断函数是否出错的依据，因为errno是个全局变量，errno的数值会随时发生改变，尤其在多线程编程中
2.环境表的概念和使用
2.1 基本概念
     环境表本质就是环境变量的集合，每个进程内部都拥有一张独立的环境表，用于记录和当前进程相关的环境变量信息
     环境表本质就是一个字符指针数组，并且以空指针作为字符指针数组的结尾标志，其中每个指针都是指向一个格式为"环境变量名=环境变量值"的字符串的首地址，而整个环境表的首地址记录在一个全局变量char** environ中，因此可以通过全局变量environ来获取整个环境表中的信息
2.2 基本操作
(1)getenv函数
     #include <stdlib.h>
     char *getenv(const char *name);
函数功能：
     主要用于获取参数指定的环境变量名所对应的环境变量值
，如果环境变量不存在，则返回NULL
(2)setenv函数
     #include <stdlib.h>
     int setenv(const char *name, const char 
*value, int overwrite);
第一个参数：环境变量名
第二个参数：环境变量值
第三个参数：是否修改的标志位
      非0 - 可以修改
        0 - 不可以修改
返回值：成功返回0，失败返回-1
函数功能：
      主要用于增加环境变量/修改环境变量的变量值，也就是如果环境变量不存在则增加，如果环境变量存在则是否修改取决于第三个参数
(3)unsetenv函数
    #include <stdlib.h>
    int unsetenv(const char *name);
函数功能：
      主要用于从环境表中删除参数指定的环境变量，如果该环境变量不存在，则函数的调用依然是成功的，环境表也不会发生改变
(4)putenv函数
     #include <stdlib.h>
     int putenv(char *string);
函数功能：
     主要用于增加环境变量/修改环境变量的值，参数的格式为：name=value，也就是说环境变量不存在则增加，存在则修改，成功返回0，失败返回非0
(5)clearenv函数
     #include <stdlib.h>
     int clearenv(void);
函数功能：
     主要用于清空整个环境表中所有的环境变量对，并且将全局变量environ也置为空指针，成功返回0，失败返回非0
2.3 main函数的原型
    int main(int argc,char* argv[],char* envp[])
第一个参数：记录命令行参数的个数
第二个参数：字符指针数组，用于记录每个命令行参数的地址
第三个参数：字符指针数组，用于记录当前进程的环境表信息
执行程序的方式为  a.out a.txt b.txt时：
      argc = 3;
      argv[0] = a.out
      argv[1] = a.txt
      argv[2] = b.txt
   
注意：
    由于历史的原因，main函数的第三个参数并不一定会被所有的系统支持，因此建议使用全局变量environ来访问环境表
实际案例：
     实现从文件argv[1]到文件argv[2]的拷贝
a.打开文件argv[1]和argv[2]
b.读取文件argv[1]中的内容写入到文件argv[2]中
c.关闭文件argv[1]和argv[2]        
     a.out a.txt b.txt     
  => 实现从a.txt到b.txt的拷贝
     a.out b.txt c.txt
  => 实现从b.txt到c.txt的拷贝
3.内存管理技术
3.1 程序和进程的基本概念
     程序 - 本质就是指存放在磁盘上的可执行文件
     进程 - 本质就是指运行在内存中的程序
     同一个程序可以同时启动多个进程
3.2 进程中的内存区域划分
如：
    int num;  // 全局变量   初始值是0    BSS段
    int main(void)
    {
         int num; // 局部变量  初始值是随机数   栈区
         return 0;
    }         
(1)代码区(Text)
    - 主要用于存放功能代码，函数指针指向该区域
(2)只读常量区(Text)
    - 主要用于存放字符串常量，const修饰的已经初始化的全
       局变量 和 静态局部变量
(3)全局区/数据区(Data)
    - 主要用于存放没有const修饰的已经初始化的全局变量和
       静态局部变量      
(4)BSS段(Data)
    - 主要用于存放没有const修饰的没有初始化的全局变量和
      静态局部变量
    - 该区域会在main函数执行之前执行自动清零的操作
(5)堆区(Heap)
    - 主要指使用malloc/calloc/realloc/free函数操作的
       内存区域
    - 该区域中的内存由程序员手动申请和手动释放
(6)栈区(Stack)
    - 主要用于存放局部变量(包括函数的形参),const修饰的
      局部变量以及块变量
    - 该区域中的内存由操作系统自动管理
综上所述：
     进程中的内存区域按照地址从小到大依次是：代码区、只读常量区、全局区、BSS段、堆区、栈区
     一般来说，堆区的内存地址按照从小到大依次分配，而栈区的内存地址按照从大到小依次进行分配
作业：
     根据图片以及程序来分析和理解进程中的内存区域划分
明日预报：
    (1)内存管理技术
     
    
       
复习：
1.C语言中的错误处理
     strerror() - 根据指定的错误编号翻译成对应的错误信息
     perror() - 打印错误信息
     printf("%m\n"); - 打印错误信息
2.环境表的概念和使用
2.1 基本概念
      环境表本质就是环境变量的集合，每个进程都拥有一张独立的环境表，用于记录属于当前进程的环境信息
      环境表本质是一个以NULL指针为结尾的字符指针数组，环境表的首地址记录在 全局变量 char** environ;
2.2 基本操作
     getenv() - 获取环境变量的值
     setenv() - 增加/修改环境变量
     unsetenv() - 删除环境变量
     putenv() - 增加/修改环境变量
     clearenv() - 清空整个环境表
2.3 main函数的原型
    int main(int argc,char* argv[],char* envp[])
3.内存管理技术
3.1 程序和进程的概念
     程序 - 存放在磁盘上的可执行文件
     进程 - 运行在内存中的程序
     程序可以同时启动多个进程
3.2 进程的内存区域划分
     内存地址从小到大：代码区、只读常量区、全局区/数据区、BSS段、堆区、栈区
作业：
----------------------------------------------------------------------------
今天内容：
     (1)内存管理技术
1.内存管理技术
1.1 存放常量字符串的不同形式之间的比较
如：
    char* pc = "hello";
    char ps[] = "hello";
      对于记录常量字符串的字符指针来说，指针的指向可以改变，但是指针指向的内容不可以改变；
      对于记录常量字符串的字符数组来说，数组名的指向不可以改变，但是数组名指向的内容可以改变；
      对于记录动态内存区域的指针来说，指针的指向和指针指向的内容都可以改变；
1.2 虚拟内存管理技术
    在Unix/linux系统中都采用虚拟内存管理技术对内存空间进行管理，即：每个进程都有0 ~ 4G-1的虚拟地址空间(虚拟的，并不是真实存在的)，由操作系统负责把虚拟地址和真实的物理内存地址映射起来，因此，不同进程中的地址空间看起来是一样的，但是所对应的物理内存却是不一样的
     其中0 ~ 3G-1之间的地址空间叫做用户空间，3G ~ 4G-1之间的地址空间叫做内核空间，绝大多数用户程序都运行在用户空间，内核空间只有内核才可以访问，当然内核也提供了相关的函数用于访问内核空间
     内存地址的基本单位是字节，但是内存映射的基本单位是内存页，目前主流的操作系统中一个内存页的大小是4Kb，也就是4096个字节
      ... ...
     1Pb = 1024Tb
     1Tb = 1024Gb
     1Gb = 1024Mb
     1Mb = 1024Kb
     1Kb = 1024byte(字节)
     1byte = 8 bit(二进制位)
1.3 段错误的由来
    (1)试图使用没有经过映射的虚拟地址时，可能引发段错误
    (2)试图对没有操作权限的内存空间进行操作时，可能引发段错误
1.4 使用malloc函数申请动态内存
(1)使用malloc函数申请的动态内存时的注意事项
     使用malloc函数申请动态内存时，malloc函数除了申请指定的内存空间之外，还可能申请额外的12个字节用于存储动态内存的管理信息，包括动态内存的大小，是否可用等信息，因此以后使用malloc函数申请的动态内存时，切记不要对动态内存进行越界访问，以避免对管理信息的破坏
(2)使用malloc函数申请动态内存的一般性原则
     一般来说，当使用malloc函数申请比较小块的动态内存时，操作系统会一次性映射33个内存页大小的存储空间，本质就是为了提高效率
    #include <unistd.h>
    #include <sys/types.h>
    getpid() - 主要用于获取当前进程的进程号
    
     cat  /proc/进程号/maps 
      - 表示查看指定进程的内存映射情况
具体的察看结果有六列：地址范围、操作权限、偏移量、设备
      编号、I节点的编号、具体的进程名称/内存区域名称
1.5 使用free函数释放动态内存
     一般来说，使用free函数释放动态内存时，释放多少则减去多少，当把所有动态内存全部释放完毕时，系统还会保留33个内存页，本质上还是为了提高效率
1.6 内存管理的相关函数
(1)getpagesize函数
     #include <unistd.h>
     int getpagesize(void);
函数功能：
     主要用于获取当前系统中一个内存页的大小，目前主流的操作系统都是4096个字节
(2)sbrk函数
     #include <unistd.h>
     void *sbrk(intptr_t increment);
函数的功能：
     主要用于根据参数指定的值来调整动态内存空间的大小
     当参数 > 0时：
          申请动态内存，成功返回申请到的内存空间的首地址
     当参数 = 0时：
          动态内存空间不变，成功返回当前动态内存的末尾地址
     当参数 < 0时：
          释放动态内存，成功返回释放之前的内存空间末尾地址
      函数调用失败时，返回(void*)-1
注意：
     使用sbrk函数申请内存比释放内存简单
     一般来说，使用sbrk函数申请比较小的内存时，操作系统会一次性映射1个内存页的大小，当申请的内存空间超过1个内存页时，系统会再次映射1个内存页的大小，当使用sbrk函数释放1个字节的内存时，系统可能会一次性释放1个内存页，当所有的动态内存被释放时，系统不会保留动态内存，因此相对于malloc函数来说更节省内存空间，但是效率没有malloc函数高
作业：
     查询并尝试使用brk函数
明日预报：
    (1)内存管理技术
    (2)文件管理
    
 
   
    
    
 
复习：
     ... ...
今天内容：
     (1)内存管理
     (2)文件管理
1.内存管理
1.1 内存管理的相关函数
(1)brk函数
     #include <unistd.h>
     int brk(void *addr);
函数功能：
     主要用于将动态内存的末尾地址调整到参数指定的位置，也就是根据具体的范围来调整动态内存的大小
     参数位置  > 末尾位置
         - 申请动态内存
     参数位置  = 末尾地址
         - 动态内存空间不变
     参数位置 < 末尾位置
         - 释放动态内存
注意：
     使用brk函数释放内存比申请内存方便，因此一般情况下和sbrk函数搭配使用，sbrk函数专门用于申请内存空间，brk函数专门用于释放内存空间
练习：
     使用sbrk函数和brk函数搭配使用，首先申请一个int类型的存储空间，存放数据66，在申请一个double类型的存储空间，存放数据3.14，最后申请10个字节的字符串空间，存放那个数据"hello"，打印以上内存空间中的数据，最后释放所有的内存空间
(2)mmap函数
     #include <sys/mman.h>
     void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
第一个参数：建立映射的起始地址，给NULL则由内核指定
第二个参数：映射的长度/大小
第三个参数：映射的权限
     PROT_EXEC - 可执行
     PROT_READ - 可读
     PROT_WRITE - 可写
     PROT_NONE - 不可访问
第四个参数：映射的标志
     MAP_SHARED - 共享的
     MAP_PRIVATE - 私有的
     MAP_ANONYMOUS - 映射到物理内存
第五个参数：文件描述符，暂时给0即可
第六个参数：文件中的偏移量，暂时给0即可
返回值：成功返回映射的首地址，失败返回MAP_FAILED
函数功能：
     主要用于建立文件/设备到内存中的映射
(3)munmap函数
     int munmap(void *addr, size_t length);
第一个参数：映射的起始地址，mmap函数的返回值
第二个参数：映射的长度/大小
函数功能：
      主要用于解除指定的映射关系
1.2 内存管理的层次关系
应用程序 - 业务逻辑
     |
STL标准模版库 - 使用容器和内存分配器，自动管理
     |
标准C++语言 - 使用运算符new申请，使用delete释放
     |
标准C语言  -  使用malloc函数申请,使用free函数释放
     |
POSIX标准  -  使用sbrk函数申请，使用brk函数释放 
     |
linux系统   - 使用mmap函数建立映射，munmap解除映射
                                                                          用户层
--------------------------------------------------------------------------
                                                                          内核层
操作系统内核 - vmalloc函数等
     |
... ...
2.文件管理
2.1 基本概念
     在linux系统中，几乎把所有的一切都统称为文件，包括目录和输入输出设备等等，因此对文件的绝大部分操作都适用于各种输入输出设备等
   
     /dev/null   -  空设备文件
如：
     echo hello
  => 终端中会输出 hello
     echo hello > a.txt
  => 将hello 写入到文件a.txt中
     echo hello > /dev/null
  => 丢弃命令的执行结果
     cat  /dev/null > a.txt
  => 表示清空文件中的内容
2.2 基本操作(重中之重)
复习标C中文件操作函数：
      fopen()/fclose()/fread()/fwrite()/fseek()
学习UC中文件操作函数：
      open()/close()/read()/write()/lseek()
(1)open函数
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    int open(const char *pathname, int flags);
    int open(const char *pathname, int flags, mode_t mode);
    int creat(const char *pathname, mode_t mode);
第一个参数：字符串形式的文件路径和文件名
第二个参数：文件的操作标志
      必须包含以下标志位中的一个
          O_RDONLY  -  只读
          O_WRONLY -  只写
          O_RDWR  -  可读可写
     还可以按位或以下的标志位：
          O_APPEND  -  以追加的方式打开文件
          O_CREAT  -  若文件不存在则创建，若存在则打开
          O_EXCL - 与O_CREAT搭配使用，若文件不存在则
                           创建，若文件存在则创建失败
          O_TRUNC - 若文件存在，则清空文件中的内容
第三个参数：文件的权限信息
      当创建一个新文件时，则需要该参数指定文件的权限信
      息，如：0664，当打开一个已经存在的文件时，不需要
      该参数，此时使用第一个open版本函数
返回值：成功返回文件描述符，失败返回-1
函数功能：
     主要用于打开/创建一个文件/设备
ls -l a.out的执行结果如下：
        -            rwx         rwx           r-x               1 
    文件的类型 属主权限 属组权限  其他用户权限  硬链接数
     tarena   tarena     7431        11月 20 14:43   a.out
    属主名称 属组名称  文件的大小 最后一次修改时间 文件名
其中的文件的类型主要有：
    -  表示普通规则文件
    d  表示目录文件
    ...
其中的权限信息主要有：
    r  表示可读   数字值为 4
    w 表示可写   数字值为 2
    x  表示可执行 数字值为1
    -  表示没有此权限  数字值为0
作业：
    查询文件基本操作的其他函数
明日预报：
    (1)文件的管理
复习：
1.文件管理
1.1 文件的基本操作
    open() - 打开/创建一个文件
    close() - 关闭文件
    read() - 读取文件中的内容
    write() - 向文件中写入数据
    lseek() - 调整文件的读写位置
1.2 标C和UC文件操作的比较
      标C的文件操作函数效率更高一些，因为函数内部提供了输入输出缓冲区，当数据积累到一定数量之后才会访问内核，才会写入数据到文件中
      使用time命令获取程序的执行时间
      UC文件操作可以通过自定义缓冲区的方式来提高效率，但不是缓冲区越大则效率越高
1.3 文件描述符的工作原理
作业：
--------------------------------------------------------------------------
今天内容：
     (1)文件的管理       
1.文件的管理
1.1 dup/dup2函数
     #include <unistd.h>
     int dup(int oldfd);
函数功能：
     主要用于对参数oldfd进行复制，成功返回新的文件描述符，失败返回-1
     #include  <unistd.h>
      int dup2(int oldfd, int newfd);
函数功能：
     主要用于实现从oldfd到newfd的复制，如果必要的话先强制关闭newfd再占用，成功返回新的描述符，失败返回-1
注意：
    使用dup/dup2函数复制文件描述符，本质就是复制文件描述符所对应的文件表地址，也就是让多个文件描述符同时对应同一个文件而已
1.2 fcntl函数
    #include <unistd.h>
    #include <fcntl.h>
    int fcntl(int fd, int cmd, ... /* arg */ );
第一个参数：文件描述符，open函数的返回值
第二个参数：操作的命令(执行一个什么样的操作)
     F_DUPFD - 实现复制文件描述符的功能，与dup2所不同
             的是，不会强制关闭占用的描述符，寻找>=第三个
             参数的描述符进行复制
    F_GETFD/F_SETFD - 获取/设置文件描述符的标志
    F_GETFL/F_SETFL - 获取/设置文件状态标志
    F_SETLK/F_SETLKW/F_GETLK - 实现文件锁的功能
第三个参数：可变长参数，是否需要取决于cmd
       实现文件锁的功能时，该参数是一个指向以下结构体的结构体指针，结构体类型如下：
struct flock 
{
     ...
     short l_type;/*锁的类型：F_RDLCK(读锁), F_WRLCK(写锁), F_UNLCK(解锁) */
     short l_whence;  /*锁定的起始位置:              SEEK_SET, SEEK_CUR, SEEK_END */
     off_t l_start;   /*针对起始位置的偏移量*/
     off_t l_len;     /*锁定的字节数*/
     pid_t l_pid;     /*加锁的进程号(F_GETLK使用)，否则默认给-1即可
};
返回值：
    F_DUPFD - 成功返回新的文件描述符，失败返回-1
    F_GETFD - 成功返回文件描述符的标志值，失败返回-1
    F_GETFL - 成功返回文件的状态值，失败返回-1
    其他命令成功返回0，失败返回-1
函数功能：
     (1)复制文件描述符(了解)
     (2)操作文件描述符标志(了解)
     (3)操作文件状态标志(了解)
     (4)实现建议锁/文件锁的功能(重点)
1.3 使用fcntl函数实现文件锁的功能
(1)文件锁的由来
     当有多个进程同时对同一个文件进行读写操作时，可能会产生数据的覆盖问题，也就是多个进程同时读文件可以进行，但是只要有一个进程在执行写操作，那么其他进程既不能读也不能写，为了实现上述效果，可以通过文件锁机制来实现
      文件锁本质就是一把读锁和一把写锁，其中读锁是一把共享锁，允许其他进程加读锁，不允许其他进程加写锁；而写锁是一把互斥锁，不允许其他进程加读锁和写锁(君子协定)
          
(2)F_SETLK作为函数的实参
      当锁的类型为F_RDLCK/F_WRLCK时，实现加锁功能
      当锁的类型为F_UNLCK时，实现解锁功能
练习：
     vi 04write.c文件，编程向文件b.txt中写入字符串内容"hello"，并且判断写入是否成功
总结：
     根据例子代码可知，给文件加完写锁之后还是可以向文件中写入数据内容的，结果说明文件锁是独立于文件的，也就是文件锁并不能控制对文件的读写操作，只能控制其他进程能否加锁成功，换句话说，如果给文件加了一把锁，可以导致第二次加锁失败(两个读锁除外)
  
思考：
    如果希望通过文件锁来控制对文件的读写操作,如何处理？
解决方案：
    为了实现上述效果，可以在每次进行读写操作之前尝试加读写锁，根据能否加上读写锁来决定能否进行读写操作，从而使得文件锁对文件的读写操作产生了约束
释放文件锁的方式：
     a.将锁的类型改为F_UNLCK，然后重新设置即可
     b.使用close函数关闭文件后，文件描述符对对应的文件
        上所有属于当前进程的文件锁都会释放
     c.进程结束，会自动释放所有该进程增加的文件锁
练习：
    vi 06unlock.c文件，首先对文件b.txt中的前10个字节加写锁，然后占用20秒之后开始解锁，解锁的方式为修改锁的类型，然后再占用20秒之后关闭文件，结束进程
(3)F_SETLKW作为函数的实参
      功能与F_SETLK类似，所不同的是如果当前锁加不上时，会进入阻塞状态一直等待，直到可以加上锁为止
(4)F_GETLK作为函数的实参
      如果第三个参数所描述的锁可以放置到文件上，则不去放置该锁，而是将锁的类型改为F_UNLCK，结构体中的其他成员保持不变；
      如果第三个参数所描述的锁不可以被放置到文件上，则使用文件上已经存在的锁信息去替换参数锁信息，并且将l_pid设置为真正给文件加锁的进程所对应的进程号；
 
1.4 access函数
      #include <unistd.h>
      int access(const char *pathname, int mode);
第一个参数：字符串形式的路径和文件名
第二个参数：操作模式
      F_OK  表示判断文件是否存在
      R_OK  表示判断文件是否可读
      W_OK  表示判断文件是否可写
      X_OK  表示判断文件是否可执行
函数功能：
     主要用于检查文件的存在性以及对应的权限信息      
作业：
     编写函数generator_id()实现生成递增帐号的功能
     a.out  100000   
     a.out  100001
     a.out  100002
     ... ...
明日预报：
    (1)文件管理
    (2)目录管理
    (3)进程管理
 
复习：
1.文件的管理
    dup/dup2函数  - 主要用于复制文件描述符
    fcntl函数 - 主要用于操作文件描述符
    access函数 - 主要用于判断文件是否存在以及拥有权限 
作业：
-----------------------------------------------------------------------------
今天内容：
     (1)文件的管理
     (2)目录的管理
     (3)进程的管理
1.文件的管理
1.1 常用的文件管理函数
(1)stat/fstat函数(重点)
     #include <sys/types.h>
     #include <sys/stat.h>
     #include <unistd.h>
     int stat(const char *path, struct stat* buf);
     int fstat(int fd, struct stat *buf);
第一个参数：文件的路径名/文件描述符
第二个参数：结构体指针
struct stat
{
      ...
      mode_t    st_mode;/*文件的类型和权限信息*/
      off_t     st_size;    /*文件的大小信息*/
      time_t    st_mtime;   /*文件的最后一次修改时间*/
      ...
      // 其中off_t本质就是long int类型
      // 其中time_t本质就是long int类型
};
函数功能：
     主要用于获取参数指定文件的状态信息
     #include <time.h>
     char *ctime(const time_t *timep);
  => 主要用于将整数类型的时间转换为字符串形式的时间
     struct tm *localtime(const time_t *timep);
  => 主要用于将整数类型的时间转换为结构体指针类型时间
     struct tm 
     {
         int tm_sec; /* 秒 */
         int tm_min;/* 分 */
         int tm_hour;/* 时 */
         int tm_mday;/* 日 */
         int tm_mon; /* 月 +1 */
         int tm_year; /* 年 +1900 */
         int tm_wday;/* 星期 */
         int tm_yday; /* 一年中的第几天 */
         int tm_isdst; /* 夏令时 了解 */
    };
扩展：
    获取一个文件大小的方法主要有三种：
        a.使用fseek函数将文件读写位置重置到末尾，使用
            ftell函数来获取文件的大小
        b.使用lseek函数将文件读写位置重置到末尾，通过返
            回值获取文件的大小
        c. 使用stat/fstat函数可以获取文件的大小
(2)chmod/fchmod函数
     #include <sys/stat.h>
      int  chmod(const  char  *path,  mode_t mode);
      int fchmod(int fd, mode_t mode);
第一个参数：文件的路径名/文件的描述符
第二个参数：文件的权限信息
函数功能：
      主要用于修改指定文件的权限信息
(3)truncate/ftruncate函数(重点)
     #include <unistd.h>
     #include <sys/types.h>
     int truncate(const char  *path,  off_t length);
     int ftruncate(int fd, off_t length);
第一个参数：文件的路径名/文件描述符
第二个参数：文件的最新长度
函数功能：
      主要用于修改文件的大小信息
注意：
      如果文件变小了，则多余的数据会被丢弃，如果文件变大了，则文件会被扩展，扩展出来的空间读取到的数据是'\0'
(4)umask函数(了解)
     #include <sys/types.h>
     #include <sys/stat.h>
     mode_t umask(mode_t mask);
函数功能：
     主要用于设置文件创建时的权限屏蔽字为：mask & 0777，通过返回值返回之前旧的权限屏蔽字
(5)又见mmap/munmap函数
     建立文件到虚拟内存地址之间的映射
  => 通过映射的机制可以将对文件的读写操作转换为对内存
        地址的读写操作，因此又多了一种访问文件的方式     
(6)其他功能函数
     link() - 主要用于创建硬链接
     unlink() - 主要用于删除硬链接
     rename() - 主要用于重命名
     remove() - 主要用于删除文件
     ... ... 
2.目录的管理
2.1 常用的管理函数
(1)opendir函数
     #include <sys/types.h>
     #include <dirent.h>
     DIR *opendir(const char *name);   
函数功能：
     主要用于打开参数指定的目录，成功返回目录的首地址，失败返回NULL
(2)readdir函数
     #include <dirent.h>
     struct dirent *readdir(DIR *dirp);
函数功能：
     主要用于读取参数指向的目录中的内容，成功返回目录指针，失败返回NULL，结构体的类型如下：
struct dirent
{
      ...
      unsigned char  d_type;/* 文件的类型 */
      char   d_name[256]; /* 文件名称 */
};
(3)closedir函数
     #include <sys/types.h>
     #include <dirent.h>
     int closedir(DIR *dirp);
函数功能：
     主要用于关闭参数指定的目录
练习：
     编程实现递归打印指定目录中的所有内容，要求子目录中的内容也要打印出来
2.2 其他目录管理函数
    mkdir() - 创建目录
    rmdir() - 删除目录
    chdir() - 切换目录
    getcwd() - 获取当前工作目录的绝对路径
    ... ...
3.进程的管理
3.1 基本概念和基本命令
(1)基本概念
     程序 - 存放在磁盘上的可执行文件
     进程 - 运行在内存中的程序
     同一个程序可以启动多个进程
(2)基本命令
     ps  -  查看当前终端启动的进程信息(进程的快照)
ps命令的执行结果如下：
     PID  -  进程的编号(重点)
     TTY  - 终端的次要装置号码(了解)
     TIME - 消耗CPU的时间(了解)
     CMD - 进程的名称(重点)
     ps -aux 表示显示所有包含其他使用者的进程信息
     ps -aux|more  表示分屏显示进程信息
ps -aux | more的执行结果如下(了解)：
     USER  -  用户名称
     PID - 进程号
     %CPU -  占用CPU的百分比
     %MEM  - 占用内存的百分比
     VSZ - 虚拟内存的大小
     RSS - 真实物理内存的大小
     TTY - 终端的次要装置号码     
     STAT - 进程的状态信息
     START - 进程的启动时间
     TIME - 消耗CPU的时间
     COMMAND -  进程的名称
进程的常见状态有(了解)：
     S  - 休眠状态，为了减轻CPU的压力
     s  -  进程的领导者，拥有子进程
     Z  -   僵尸进程(已经结束但是资源没有释放的进程)
     R  -  正在运行的进程
     O  -  可以运行的进程
     T  -   挂起的进程
     <  -  优先级比较高的进程
     N  -   优先级比较低的进程
     ...  ... 
    
     ps -ef  表示以全格式的方式显示所有进程信息
     ps -ef | more  表示以分屏方式显示进程信息
ps -ef | more的执行结果如下(了解):
      UID  -  用户的编号
      PID  -  进程的编号 
      PPID -  父进程的编号
      C  - 占用CPU的百分比
      STIME - 进程的启动时间
      TTY  - 终端的次要装置号码          
      TIME - 消耗CPU的时间
      CMD  - 进程的名称
  
      kill -9 进程号   表示杀死指定的进程 
  
      目前主流的操作系统支持多进程，在操作系统中，如果进程A启动了进程B，那么进程A就叫做进程B的父进程，进程B就叫做进程A的子进程
      操作系统中进程0(系统级的进程)负责启动进程1(init)和进程2，其他所有的进程都是直接/间接  由 进程1/进程2 启动的，所有的进程组成了树形结构
作业：
      查询和尝试使用文件和目录的其他管理函数
明日预报：
     (1)进程的管理
     (2)信号的处理
     
    
     
 
    
复习：
1.文件的管理
    stat()/fstat() - 主要用于获取文件的状态信息
    chmod()/fchmod() - 主要用于修改文件的权限信息
    truncate()/ftruncate() - 主要用于修改文件的大小
    umask()  -  主要用于设置文件创建时的权限屏蔽字
    mmap()/munmap() - 建立虚拟地址到文件的映射
    link()/unlink()/rename()/remove()/... ...
2.目录的管理
    opendir() - 打开目录
    readdir() - 读取目录中的内容
    closedir() - 关闭目录
    mkdir()/rmdir()/chdir()/getcwd()/ ... ...   
  
3.进程的管理
3.1 基本概念和基本命令
     ps  -  查看当前终端所启动的进程  PID   CMD
     ps -aux  -  显示所有包含其他使用者的进程信息
     ps -ef  -  以全格式的方式显示进程信息
     kill -9 进程号  表示杀死指定的进程
     目前主流的操作系统都支持多进程，如果进程A启动了进程B，则进程A叫做进程B的父进程，进程B叫做进程A的子进程
     进程0(系统级进程)负责启动了进程1(init)和进程2，其他所有的进程都是直接/间接 由 进程1/进程2 启动的，最终组成了树形结构   
-----------------------------------------------------------------------------
今天内容：
     (1)进程的管理
     (2)信号的处理
1.进程的管理
1.1 各种ID的获取
    #include <sys/types.h>
    #include <unistd.h>
    getpid()  -  获取当前进程的进程编号，返回pid_t
    getppid()  -  获取当前进程父进程的进程编号,返回pid_t
    getuid()  -  获取当前用户的编号，返回uid_t
    getgid()  -  获取当前用户所在用户组的编号，返回gid_t
注意：
    PID - 进程的编号，操作系统通过该编号唯一标识指定的进程，但是进程号的分配采用延迟重用的策略，在任意时刻都保证了进程号的唯一性
    pid_t本质就是int类型，进程号都是非负整数
    uid_t本质就是unsigned int类型
    gid_t本质就是unsigned int类型
      
1.2 进程的创建
(1)fork函数
     #include <unistd.h>
     pid_t fork(void);
函数功能：
     主要用于通过复制当前正在调用进程的方式来创建子进程，调用成功时父进程返回子进程的进程号，子进程返回0，调用失败时父进程返回-1，没有子进程存在
注意：
     使用fork函数创建子进程后，父子进程之间的执行顺序取决于操作系统的调度算法
(2)父子进程的代码执行方式
    a.对于fork函数之前的代码，由父进程执行一次；
    b.对于fork函数之后的代码，由父子进程各自执行一次；
    c.fork函数的返回值 由父子进程各自返回一次，父进程返
       回子进程的进程号，子进程返回0，因此可以通过函数的
       返回值来区分父子进程
(3)父子进程之间的关系
    a.父进程启动了子进程，父子进程同时执行，如果子进程先结束，子进程会给父进程发信号，父进程负责回收子进程的资源；
    b.如果父进程先结束，则子进程会变成孤儿进程，子进程会变更父进程(重新设定父进程,init进程)，init进程因为收养孤儿进程，因此被称为孤儿院；
    c.如果子进程先结束，但是父进程由于各种原因没有收到子进程发来的信号，则不会负责回收其资源，那么子进程就会变成僵尸进程；
(4)父子进程之间内存资源的关系
     对于fork函数创建的子进程来说，子进程会复制父进程中除了代码区之外的其他内存区域，而代码区和父进程共享
(5)扩展
    a.如何使用fork函数创建4个进程？？？
          fork();
          fork();
      4个进程：1个父进程 + 2个子进程 + 1个孙子进程
   b. 如何使用fork函数创建3个进程？？？
          pid = fork();
          if(0 != pid)
         {
                fork();
         }    
      3个进程：1个父进程  +  2个子进程
   c. 俗称"fork炸弹"
        while(1)
        {
              fork();
        }
1.3 进程的终止
(1)正常终止进程的方式
    a.执行到了main函数的return 0；
    b.调用exit()函数
    c.调用_exit()/_Exit()函数
    d.最后一个线程返回
    e.最后一个线程调用pthread_exit()函数
(2)非正常终止进程的方式
    a.采用信号来终止进程，如：ctrl+c
    b.最后一个线程被其他线程调用pthread_cancel函数取消
(3)终止进程相关函数的解析
    #include <unistd.h>
    void _exit(int status);   => UC函数
    #include <stdlib.h>
    void _Exit(int status);   => 标C函数
函数功能：
     主要用于立即终止当前正在调用的进程，自动关闭所有属于该进程的文件描述符，让该进程的所有子进程变更父进程为init进程，该进程也会其父进程发送SIGCHILD信号来回收该进程的资源
     参数值会被返回给当前进程的父进程作为当前进程的退出状态信息，父进程若要收集退出状态信息，则需要调用wait系列函数来处理
     #include <stdlib.h>
     void exit(int status);
函数功能：
      主要用于引起正在调用进程的终止，参数status & 0377之后的结果会被返回给父进程作为当前进程的退出状态信息
      在终止进程之前会自动调用所有由atexit()和on_exit()函数注册过的函数
      
      #include <stdlib.h>
      int atexit(void (*function)(void));
函数功能：
      主要用于注册参数指定的功能函数，注册过的函数会在进程正常终止时调用，而进程正常终止的方式为：调用exit()函数和从main函数中返回
      该函数调用成功时返回0，失败返回非0
1.4 进程的等待
(1)wait函数
     #include <sys/types.h>
     #include <sys/wait.h>
     pid_t wait(int *status);
函数功能：
     主要用于挂起当前正在调用的进程，直到该进程的一个子进程终止为止
     当参数不为空时，就将获取到的进程退出状态信息存放到参数status所指向的存储空间中，为了解析该退出状态信息，需要使用以下的带参宏：
     WIFEXITED(*status) - 如果进程正常终止则返回真，所谓正常终止就是指：调用exit()/_exit()/从main函数中返回
     WEXITSTATUS(*status) - 获取子进程的退出状态信息
     成功返回终止子进程的进程号，失败返回-1
(2)waitpid函数
     #include <sys/types.h>
     #include <sys/wait.h>
     pid_t waitpid(pid_t pid, int  *status,int options);
第一个参数：进程的编号
    <-1 等待进程组ID为pid绝对值的任意一个子进程(了解)
     -1  等待任意一个子进程(重点)
     0   等待和正在调用进程在同一个进程组的任意子进程
          (了解)
    >0  等待进程号为pid的子进程(重点)
第二个参数：指针作为函数的参数，获取进程的退出状态
第三个参数：等待的方式，默认给0，表示等不到会阻塞
    WNOHANG - 没有子进程终止时立即返回，不会阻塞
返回值：成功返回终止子进程的进程号，失败返回-1
函数功能：
      主要用于等待指定的进程状态发生改变
注意：
      The call wait(&status) is equivalent to:
      waitpid(-1, &status, 0);
1.5 进程的其他管理函数
(1)vfork函数
     #include <sys/types.h>
     #include <unistd.h>
     pid_t vfork(void);
函数功能：
     与fork函数类似，都是创建当前正在调用进程的子进程，有关创建的详细信息、返回值以及常见的错误信息请参考fork函数即可
     与fork函数不同之处在于，不会复制父进程中的内存区域，而是直接占用，导致父进程会被挂起直到子进程终止，或者子进程调用exec系列函数为止，所以vfork函数保证了子进程先于父进程执行
      使用vfork函数创建的子进程终止时只能调用_exit函数，而不能从当前函数返回 或者 调用exit函数
(2)exec系列函数
    #include <unistd.h> 
    int execl(const char *path, const char*arg, ...);
第一个参数：字符串形式的路径名
第二个参数：字符串形式的参数，一般指定可执行文件名
第三个参数：可变长参数，是否需要取决于前两个参数
函数功能：
      主要用于执行指定的文件
如：
    使用execl函数执行ls -l 命令时的用法如下：
        execl("/bin/ls","ls","-l",NULL);
注意：
       vfork函数本身没有太大的实际意义，一般需要与exec系列函数搭配使用，这样可以使得父子进程去执行完全不同的代码段
       fork函数也可以和exec系列函数搭配使用，但是效率相对比较低，因此一般情况下很少这样使用
(3)system函数
     #include <stdlib.h>
     int system(const char *command);
函数功能：
     主要用于执行参数指定的shell命令，但是在实际项目开发中可能更多地被用于执行shell脚本和可执行文件
2.中断的概念和分类
      中断就是指暂停执行当前正在执行的程序转而执行其他程序或者处理意外情况的过程
      中断分为：硬件中断  和 软件中断
3.信号的处理
3.1 基本概念和特点
(1)基本概念
      信号本质就是一种软件中断,它既可以作为进程间通信的一种方式，又可以中断一个正常运行的进程，它更多地被用于处理意外情况
(2)基本特点
    a.信号是异步的，也就是进程并不知道信号何时会到达;
    b.进程既可以处理信号，也可以发送信号给指定的进程;
    c.每个信号都有一个名字，并且用SIG开头;
3.2 信号的基本命令和分类
      kill -l  表示查看当前系统所支持的所有信号
      一般来说，在linux系统中支持的信号范围是：1 ~ 64，不保证信号是连续的，而unix系统与linux系统有所不同，一般支持的范围是 1 ~ 48;
      在linux系统中，其中 1 ~ 31之间的信号叫做不可靠信号，不支持排队，信号随时可能会丢失，也叫做非实时信号；
      其中34 ~ 64之间的信号叫做可靠信号，支持排队，信号不会丢失，也叫做实时信号；
要求掌握的信号：
      SIGINT    2   使用ctrl+c产生该信号   进程终止
      SIGQUIT  3   使用ctrl+\产生该信号   进程终止
      SIGKILL   9   使用kill -9产生该信号   进程终止
作业：
      查询signal函数并且尝试使用
明日预报：
      (1)信号的处理
   
   
 
复习：
1.进程的管理
1.1 各种ID的获取
      getpid() - 获取当前进程的进程号
      getppid() - 获取当前进程的父进程进程号
      getuid() - 获取用户的编号
      getgid() - 获取用户组的编号
      pid_t 本质就是 int 类型， 系统采用延迟重用
1.2 进程的创建
     fork() - 复制当前进程的方式来创建子进程
     
     子进程会复制父进程中除了代码区之外的其他内存区域，而代码区和父进程共享
     
     fork();
     fork();
     pid = fork();
     if(0 != pid)
     {
          fork();
     }
   
    while(1) {  fork();}
1.3 进程的终止
(1)正常终止进程的方式
     a.执行了main函数中的return
     b.调用exit()函数
     c.调用_exit()/_Exit()函数
     d.最后一个线程返回
     e.最后一个线程调用了pthread_exit()函数
(2)非正常终止进程的方式
     a.使用信号终止进程
     b.最后一个线程被其他线程调用pthread_cancel()函数
1.4 进程的等待
     wait() - 等待任意一个子进程结束
     waitpid() - 等待指定的子进程结束    
1.5 进程的其他管理函数
     vfork() - 创建子进程
     execl() - 执行指定的文件
     system() - 执行指定的shell命令
2.信号的处理
2.1 基本概念和特性
    信号本质就是一种软中断，它既可以作为进程间通信的机制，又可以终止一个正在执行的进程，更多地被用于处理意外情况
2.2 基本概念和分类
    在linux系统中支持的信号是 1 ~ 64，不保证连续，其中 1 ~ 31之间的信号叫做不可靠信息，不支持排队，信号可能会丢失，也叫做非实时信号；其中34 ~ 64之间的信号叫做可靠信号，支持排队，信号不会丢失，也叫做实时信号    
     kill -l
掌握的信号：
     SIGINT   2   ctrl+c    默认处理方式为终止进程
     SIGQUIT  3  ctrl+\    终止进程
     SIGKILL   9  kill -9    终止进程
作业：
     查询和解析signal函数
----------------------------------------------------------------------------
今天内容：
     (1)信号的处理
1.信号的处理
1.1 信号的处理方式
(1)默认处理，绝大多数信号的处理方式为终止进程
(2)忽略处理
(3)自定义处理  
注意：
     其中信号SIGKILL只能采用默认处理方式
     每个用户只能处理属于该用户的信号，只能给该用户的进程发送信号，其中root用户可以给几乎所有进程发信号
     #include <signal.h>
     typedef void (*sighandler_t)(int);
     sighandler_t     signal(int    signum,
          sighandler_t handler);
函数原型解析：
     typedef void (*sighandler_t)(int);
 =>  typedef void (*)(int)  sighandler_t;
 =>  typedef void (*p)(int)  sighandler_t;
     sighandler_t     signal(int    signum,
          sighandler_t handler);
 => void (*)(int)  signal(int    signum,
           void (*)(int) handler);
 =>  void (*)(int)  signal(int    signum,
           void (*handler)(int) );
 =>  void (*signal(int    signum,
           void (*handler)(int)) )(int);
 =>  signal首先是一个函数
        具有两个参数：一个是int类型，一个是函数指针类型
        函数的返回值类型也是函数指针类型
 =>  函数指针是一个 指向 int类型参数 void类型返回值的 
            函数的 指针
函数功能解析：
     第一个参数：信号的名称/信号值(处理哪个信号)
     第二个参数：函数指针类型
          SIG_IGN - 忽略处理
          SIG_DFL - 默认处理
          自定义函数地址 - 自定义处理
    返回值：成功返回之前的处理方式，失败返回SIG_ERR
    函数功能：
          主要用于设置信号的处理方式
练习：
    编程打印进程号，设置对信号SIGINT进行自定义处理，对信号SIGQUIT进行忽略处理，设置完毕之后使用fork函数创建子进程，打印子进程的进程号后进入无限循环，父进程直接结束，在另一个终端中采用kill命令发送信号进行测试
总结：
     (1)对于fork函数创建的子进程来说，完全照搬父进程对信号的处理方式，也就是父进程自定义，子进程自定义；父进程默认，子进程也默认；父进程忽略，子进程也忽略处理；
     (2)对于vfork函数和execl函数启动的进程来说，父进程默认，子进程也默认；父进程忽略，子进程也忽略；父进程自定义处理，子进程采用默认处理；
1.2 信号的发送方式
(1)采用键盘方式发送(只能发送部分特殊的信号)
      SIGINT   2   采用ctrl+c来发送
      ... ...
(2)采用程序出错方式发送(只能发送部分特殊的信号)
      段错误  本质就是SIGSEGV信号   11
      ... ...
(3)使用kill命令发送信号(可以发送所有信号)
      kill -信号值 进程号
   => 表示给指定的进程发送指定的信号
(4)采用系统函数发送信号(重点)
      kill()/raise()/alarm()/sigqueue()
1.3 发送信号的系统函数解析
(1)kill函数
    #include <sys/types.h>
    #include <signal.h>
    int kill(pid_t pid, int sig);
第一个参数：进程号(给谁发信号)
    >0 表示发送信号到进程号为pid的进程(重点)
      0 表示发送信号给和当前进程在同一个进程组的每个进程
          (了解)
     -1 表示发送信号给当前进程可以发送的每个进程，除了进
           程init(了解)
   <-1 表示发送信号给进程组ID为-pid的每个进程(了解)
第二个参数：信号值/信号名称(发送什么样的信号)
     0 表示不会发送信号，而是判断进程/进程组是否存在
函数功能：
     主要用于给指定的进程发送指定的信号
(2)raise函数
     #include <signal.h>
     int raise(int sig);
函数功能：
     主要用于给当前正在调用的进程/线程发送参数指定的信号，对于单线程的进程来说，等价于kill(getpid(),sig)
     成功返回0，失败返回非0
     #include <unistd.h>
     unsigned int sleep(unsigned int seconds);
函数功能：
     主要用于按照参数指定的秒数进行睡眠，直到参数指定的秒数到了或者被一个不能忽略的信号打断，如果睡够了则返回值为0，如果没有睡够则返回还没有来得及睡的秒数(也就是剩余的秒数)
(3)alarm函数
     #include <unistd.h>
     unsigned int alarm(unsigned int seconds);
函数功能：
     主要用于在经过参数指定的秒数之后发送SIGALRM信号给当前正在调用的进程
     每次设置新闹钟之后会取消之前的闹钟，参数为0时不会设置新闹钟，专门用于取消闹钟
    成功返回之前闹钟剩余的秒数，如果之前没有闹钟则返回0
(4)sigqueue函数
     等到讲完sigaction函数之后回来再讲
1.4 信号集的基本概念和操作
(1)基本概念
     信号集本质就是由若干个信号组成的集合，当前系统支持的信号范围是 1 ~ 64，不保证连续
分析：
     采用最节省内存方式描述信号集，数据类型该如何设计？
     char str[64];     需要64个字节
     采用每一个二进制位代表一个信号，则需要64个二进制位，那么也就是8个字节，类型为：long long int;
总结：
     信号集的数据类型是sigset_t类型，大小是128个字节，但是底层采用每一个二进制位来代表一个信号;
typedef struct
{
     unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
typedef __sigset_t sigset_t;
(2)基本操作
     #include <signal.h>
     sigemptyset() - 清空信号集//成功0失败-1
     sigfillset() - 填满信号集//成功0失败-1
     sigaddset() - 增加指定的信号到信号集中//成功0失败-1
     sigdelset() - 删除信号集中指定的信号//成功0失败-1
     sigismember() - 判断指定的信号是否存在
	 //返回1：说明指定的信号存在,
	 //返回0：说明指定的信号不存在
	 //返回-1：说明出错
1.5 信号的屏蔽
(1)sigprocmask函数
     #include <signal.h>
     int   sigprocmask(int    how,    const sigset_t *set, sigset_t *oldset);
第一个参数：屏蔽方式
      SIG_BLOCK - ABC  CDE => ABCDE(原+新)
      SIG_UNBLOCK - ABC  CDE => AB(原-新)
      SIG_SETMASK - ABC  CDE => CDE(新替换原，重点)
第二个参数：屏蔽的信号集
第三个参数：获取之前的屏蔽集
函数功能：
      主要用于获取/修改屏蔽的信号集
(2)sigpending函数
     #include <signal.h>
     int sigpending(sigset_t *set);
函数功能：
     主要用于获取在信号屏蔽期间来过但没有处理的信号，将这些来过的信号设置到参数指定的信号集中
1.6 sigaction函数
    => signal函数的增强版
    #include <signal.h>
     int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);
第一个参数：信号名称/信号值
      可以选择任何一个有效信号，除了SIGKILL和SIGSTOP
第二个参数：设置针对上述信号的处理方式
struct sigaction 
{
   void (*sa_handler)(int);
=> 函数指针，主要用于设置信号的处理方式
=> SIG_DFL，SIG_IGN，自定义函数的地址
   void (*sa_sigaction)(int, siginfo_t *, void *);
=> 函数指针类型，用于设置信号的处理方式，是否选用该成
     员，取决于sa_flags;
   sigset_t   sa_mask;
=> 主要用于设置在执行信号处理函数期间屏蔽的信号集
=> 默认屏蔽与触发信号处理函数相同的信号
   
   int sa_flags;
=> SA_SIGINFO  使用第二个函数指针来设置信号处理方式 
=> SA_NODEFER 解除对触发信号处理函数相同信号的屏蔽
=> SA_RESETHAND 一旦信号处理函数调用后恢复信号的
      默认处理方式(也就是自定义处理一次)
   void     (*sa_restorer)(void);
=> 函数指针类型，保留成员，暂时不使用
};     
第三个参数：用于获取之前的处理方式
函数功能：
     主要用于检查/修改指定信号的处理方式
其中结构体中的第二个成员的第二个形参类型如下：
struct siginfo_t
{
     ...
     pid_t    si_pid;      /* 发送信号的进程号 */
     sigval_t si_value;    /* 发送信号伴随的附加数据 */
     ... 
};
作业：
     查询和理解sigaction和sigqueue函数
明日预报：
     (1)信号的处理
     (2)进程间的通信
   
 
复习：
1.信号的处理
1.1 信号的处理方式
(1)默认处理，绝大多数信号的默认处理方式都是终止进程
(2)忽略处理
(3)自定义处理
     signal() - 设置对信号的处理方式
父子进程对信号处理方式的比较
    (1)对于fork函数创建的子进程来说，完全照搬父进程对信号的处理方式；
    (2)对于vfork函数和execl函数创建的子进程来说，父进程默认，子进程也默认；父进程忽略，子进程也忽略；父进程自定义，子进程默认处理；
1.2 发送信号的主要方式
(1)采用键盘发送(只能发送部分特殊的信号)
(2)采用程序出错发送(只能发送部分特殊的信号)
(3)使用kill命令   
     kill -信号值 进程号
(4)采用系统函数发送信号
     kill()/raise()/alarm()/sigqueue()
1.3 信号集的概念和操作
     信号集本质就是若干个信号组成的集合
     数据类型：sigset_t类型， 128个字节，采用每一个二进制位来代表一个信号
     sigemptyset() - 清空信号集
     sigfillset() - 填满信号集
     sigaddset() - 添加指定信号到信号集
     sigdelset() - 删除指定的信号
     sigismember() - 判断信号是否存在于信号集中
1.4 信号的屏蔽
     sigprocmask() - 设置/检查/修改屏蔽的信号集
     sigpending() - 获取信号屏蔽期间来过的信号     
1.5 sigaction函数
     是signal函数的增强版，设置对信号的处理方式
--------------------------------------------------------------------------
今天内容：
     (1)信号的处理
     (2)进程间通信的方式
1.信号的处理
1.1 sigaction函数
     #include <signal.h>
     int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);
第一个参数：信号名称/信号值
      可以选择任何一个有效信号，除了SIGKILL和SIGSTOP
第二个参数：设置针对上述信号的处理方式
struct sigaction 
{
   void (*sa_handler)(int);
=> 函数指针，主要用于设置信号的处理方式
=> SIG_DFL，SIG_IGN，自定义函数的地址
   void (*sa_sigaction)(int, siginfo_t *, void *);
=> 函数指针类型，用于设置信号的处理方式，是否选用该成
     员，取决于sa_flags;
   sigset_t   sa_mask;
=> 主要用于设置在执行信号处理函数期间屏蔽的信号集
=> 默认屏蔽与触发信号处理函数相同的信号
   
   int sa_flags;
=> SA_SIGINFO  使用第二个函数指针来设置信号处理方式 
=> SA_NODEFER 解除对触发信号处理函数相同信号的屏蔽
=> SA_RESETHAND 一旦信号处理函数调用后恢复信号的
      默认处理方式(也就是自定义处理一次)
   void     (*sa_restorer)(void);
=> 函数指针类型，保留成员，暂时不使用
};     
第三个参数：用于获取之前的处理方式
函数功能：
     主要用于检查/修改指定信号的处理方式
其中结构体中的第二个成员的第二个形参类型如下：
struct siginfo_t
{
     ...
     pid_t    si_pid;      /* 发送信号的进程号 */
     sigval_t si_value;    /* 发送信号伴随的附加数据 */
     ... 
};
1.2 sigqueue函数
    #include <signal.h>
     int sigqueue(pid_t pid, int sig, const union sigval value);
第一个参数：进程的编号(给哪个进程发信号)
第二个参数：信号值/信号名称(发送什么样的信号)
第三个参数：发送信号时伴随的附加数据
     union sigval 
     {
          int   sival_int;
          void *sival_ptr;
     };
函数功能：
      主要用于发送信号和附加数据到指定的进程中
1.3 计时器
     在linux系统中，系统会为每一个进程维护3种计时器：真实计时器、虚拟计时器、以及实用计时器，其中一般使用真实计时器更多一些；
     #include <sys/time.h>
     int getitimer(int which, struct itimerval *curr_value);
     int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);
第一个参数：计时器的类型(哪一种)
     ITIMER_REAL - 通过统计进程消耗的真实时间来传递SIGALRM信号进行工作的(重点)
     ITIMER_VIRTUAL - 通过统计进程消耗的用户态时间来传递SIGVTALRM信号进行工作的(了解)
     ITIMER_PROF - 通过统计进程消耗的用户态时间和内核态时间的总和来传递SIGPROF信号进行工作的(了解)
第二个参数：结构体指针，用于设置计时器的新值
struct itimerval 
{
     struct timeval it_interval; /* 间隔时间 */
     struct timeval it_value;    /*  启动时间 */
};
struct timeval 
{
     long tv_sec;  /* 秒  = 10^6 微秒*/
     long tv_usec;/* 微秒  */
};
    
第三个参数：结构体指针，用于返回计算器之前的旧值
函数功能：
     主要用于获取/设置计时器的参数值
2.进程间的通信方式
2.1 基本概念
    两个/多个进程之间的数据交互叫做进程间的通信
2.2 通信方式
    (1)文件
    (2)信号
    (3)管道
    (4)共享内存
    (5)消息队列(重点)
    (6)信号量集
    (7)网络(重点)
     ... ...
    其中(4)(5)(6)统称为 XSI IPC通信方式
     (X/open System Interface Inter-Process Communication)
3.使用管道实现进程间的通信
3.1 基本概念
     使用管道通信本质上还是以文件作为通信的媒介，只不过管道是一种比较特殊的文件而已
     管道分为两种：有名管道  和 无名管道
     有名管道：可以用于任意两个进程之间的通信
     无名管道 : 主要用于父子进程之间的通信
3.2 使用有名管道实现进程间的通信
     使用mkfifo命令/函数可以创建有名管道文件
如：
     mkfifo  a.pipe
  => 创建有名管道a.pipe文件
     touch  a.txt
  => 创建普通文件a.txt
     echo  hello  > a.txt
  => 将字符串hello写入到文件a.txt，可以写入的
     echo  hello  > a.pipe
  => 将字符串hello写入文件a.pipe，不可以写入的
     再开另外一个终端，写入以下指令：
     cat  a.pipe
  => 读取管道文件中的内容，此时数据hell可以读取成功
       对面的写入数据也会解除阻塞
     #include <sys/types.h>
     #include <sys/stat.h>
     int mkfifo(const char *pathname, mode_t mode);
 => 主要用于创建一个有名管道文件，权限由第二个参数指定
3.3 使用无名管道实现进程间的通信
    #include <unistd.h>
    int pipe(int pipefd[2]);
函数功能：
    主要用于创建无名管道文件，可以提供进程间通信的一种单向数据通道，通过参数可以返回两个文件描述符，其中pipefd[0]表示读端，pipefd[1]表示写端
注意：
     管道文件的特殊性就在于只是用于作为数据通信的桥梁，但是管道文件自身并不会存放任何数据
     使用管道实现进程间的通信是属于比较古老的方式，以后很少使用
4.使用共享内存实现进程间的通信
4.1 基本概念
      所谓共享内存本质就是一块由系统内核指定并维护的内存区域，该区域可以共享在多个进程之间，因此多个进程可以通过该共享内存作为媒介来实现进程间的通信
4.2 通信模型
(1)获取key值，使用ftok函数
(2)创建/获取共享内存，使用shmget函数
(3)挂接共享内存，使用shmat函数
(4)使用共享内存
(5)脱接共享内存，使用shmdt函数
(6)如果不再使用则删除共享内存，使用shmctl函数
4.3 相关函数的解析
(1)ftok函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     key_t  ftok(const  char *pathname, int proj_id);
第一个参数：字符串形式的路径名
      要求必须关联一个存在并且可以访问的文件
第二个参数：项目的编号，要求非0，取低八位二进制
返回值：成功返回key_t类型的key值，失败返回-1
函数功能：
      主要用于根据路径名和项目编号来生成key值
注意：
      使用相同的路径名和相同的项目编号，最终生成的key值也相同
(2)shmget函数
     #include <sys/ipc.h>
     #include <sys/shm.h>
     int shmget(key_t key, size_t size, int shmflg);
第一个参数：key值，ftok函数的返回值
第二个参数：共享内存的大小，
       如果获取已经存在的共享内存，则实参传0即可
第三个参数：共享内存的操作标志
       IPC_CREAT - 创建
       IPC_EXCL - 与IPC_CREAT搭配使用，如果共享内存已
                          经存在，则创建失败
       0 - 获取一个已经存在的共享内存
返回值：成功返回共享内存的ID，失败返回-1
函数功能：
      主要用于创建/获取一块共享内存
注意：
      使用shmget函数创建新的共享内存时，需要使用低位二进制来指定共享内存的权限信息，如按位或 0664
(3)shmat函数
     #include <sys/types.h>
     #include <sys/shm.h>
      void *shmat(int shmid, const void *shmaddr, int shmflg);
第一个参数：共享内存的ID，shmget函数的返回值
第二个参数：共享内存的地址，给NULL由系统指定
第三个参数：共享内存的操作标志，默认给0即可
返回值：成功返回挂接共享内存的地址，失败返回(void*)-1
函数功能：
     主要用于挂接共享内存到当前进程中
(4)shmdt函数
     #include <sys/types.h>
     #include <sys/shm.h>
     int shmdt(const void *shmaddr);
函数功能：
     主要用于脱接当前进程中的共享内存，参数为shmat函数的返回值
(5)shmctl函数
     #include <sys/ipc.h>
     #include <sys/shm.h>
     int shmctl(int shmid, int cmd, struct shmid_ds *buf);
第一个参数：共享内存的ID，shmget函数的返回值
第二个参数：具体的操作命令
     IPC_RMID - 删除共享内存，此时第三个参数给NULL即可
第三个参数：结构体指针
函数功能：
      主要用于对指定的共享内存进行控制
4.4 相关的基本命令
     ipcs  -m  表示查看当前系统中的所有共享内存
     ipcrm  -m  共享内存的ID  表示删除指定的共享内存
5.使用消息队列实现进程间的通信
5.1 基本概念
    本质上就是将数据打包成消息，然后将消息放到消息队列中，让多个进程访问同一个消息队列，从而实现进程间的通信
5.2 基本模型
(1)获取key值，使用ftok函数
(2)创建/获取消息队列，使用msgget函数
(3)发送/接收消息队列中的消息，使用msgsnd/msgrcv函数
(4)如果不再使用消息队列则删除，使用msgctl函数
5.3 相关函数的解析
(1)msgget函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgget(key_t key, int msgflg);
第一个参数：key值，ftok函数的返回值
第二个参数：操作标志
      IPC_CREAT  -  创建
      IPC_EXCL  -  与IPC_CREAT搭配使用，若存在创建失败
       0  -  获取一个已经存在的消息队列
返回值：成功返回消息队列的ID，失败返回-1
函数功能：
      主要用于创建/获取一个消息队列
注意：
     当创建新的消息队列时，需要在第二个参数中指定权限信息，如按位或 0664等
(2)msgsnd函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：消息的首地址，消息的一般格式如下：
struct msgbuf 
{
    long mtype;      /* 消息的类型, must be > 0 */
    char mtext[1];  /* 消息的内容，可以是其他结构*/
};
第三个参数：消息的大小
     用于指定消息内容的大小，不包括消息的类型
第四个参数：消息的发送标志，默认给0即可
     IPC_NOWAIT  -  不会产生阻塞现象
函数功能：
      主要用于将指定的消息发送到指定的消息队列中
作业：
     查询剩余的两个功能函数
明日预报：
     (1)使用消息队列实现进程间的通信
     (2)使用信号量集实现进程的通信
     (3)综合小项目：模拟ATM的功能
 
 
复习：
1.信号的处理
    sigaction() -  主要用于设置信号的处理方式
    sigqueue() - 主要用于发送信号和附加数据到指定进程
    setitimer()/getitimer() - 设置/获取计时器的相关信息
2.进程间通信的方式
   (1)文件
   (2)信号
   (3)管道
   (4)共享内存
   (5)消息队列(重点)
   (6)信号量集
   (7)网络(重点)
   ...
   其中(4)(5)(6)统称为 XSI IPC通信方式
   
3.使用管道实现进程间的通信
3.1 基本概念
     使用管道通信本质还是以文件作为通信的媒介，只不过该文件比较特殊，文件本身不会存放任何数据
     管道分为：有名管道  和 无名管道
3.2 使用有名管道实现进程间的通信
     mkfifo  xxx.pipe
     echo hello > xxx.pipe
     cat xxx.pipe
     mkfifo() - 创建有名管道
3.3 使用无名管道实现进程间的通信
     pipe() - 主要用于创建无名管道，返回两个描述符
4.使用共享内存实现进程间的通信
(1)获取key值，使用ftok函数
(2)创建/获取共享内存，使用shmget函数
(3)挂接共享内存，使用shmat函数
(4)使用共享内存
(5)脱接共享内存，使用shmdt函数
(6)如果不再使用，则删除共享内存，使用shmctl函数
ipcs -m   查看系统中的共享内存
ipcrm -m 共享内存的ID  表示删除指定的共享内存
5.使用消息队列实现进程间的通信
(1)获取key值，使用ftok函数
(2)创建/获取消息队列，使用msgget函数
(3)发送/接受消息，使用msgsnd/msgrcv函数
(4)如果不再使用，则删除消息队列，使用msgctl函数
----------------------------------------------------------------------------
今天内容：
    (1)使用消息队列实现进程间的通信
    (2)使用信号量集实现进程间的通信
    (3)综合小项目：银行账户管理系统
1.使用消息队列实现进程间的通信
1.1 相关函数的解析
(1)msgget函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgget(key_t key, int msgflg);
第一个参数：key值，ftok函数的返回值
第二个参数：操作标志
      IPC_CREAT  -  创建
      IPC_EXCL  -  与IPC_CREAT搭配使用，若存在创建失败
       0  -  获取一个已经存在的消息队列
返回值：成功返回消息队列的ID，失败返回-1
函数功能：
      主要用于创建/获取一个消息队列
注意：
     当创建新的消息队列时，需要在第二个参数中指定权限信息，如按位或 0664等
(2)msgsnd函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：消息的首地址，消息的一般格式如下：
struct msgbuf 
{
    long mtype;      /* 消息的类型, must be > 0 */
    char mtext[1];  /* 消息的内容，可以是其他结构*/
};
第三个参数：消息的大小
     用于指定消息内容的大小，不包括消息的类型
第四个参数：消息的发送标志，默认给0即可
     IPC_NOWAIT  -  不会产生阻塞现象
函数功能：
      主要用于将指定的消息发送到指定的消息队列中
(3)msgrcv函数
    #include <sys/types.h>
    #include <sys/ipc.h>
    #include <sys/msg.h>
    ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：存放消息的首地址
第三个参数：消息的大小，不包括消息的类型
第四个参数：消息的类型
    0  - 表示始终读取消息队列中的第一个消息
  >0  - 表示始终读取消息队列中第一个类型为msgtyp的消息
  <0  - 表示始终读取消息类型<=msgtyp绝对值的消息，其
           中最小的类型优先读取
第五个参数：接受消息的方式，默认给0，产生阻塞现象
返回值：成功返回实际接收的数据大小，失败返回-1
函数功能：
      主要用于从指定的消息队列中接收消息
(4)msgctl函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgctl(int msqid, int cmd, struct msqid_ds *buf);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：具体的操作命令
      IPC_RMID  - 删除消息队列，第三个参数给NULL即可
第三个参数：结构体指针
函数功能：
     主要用于操作指定的消息队列
1.2 基本命令
    ipcs  -q  表示查看系统中存在的消息队列
    ipcrm  -q  消息队列的ID   表示删除指定的消息队列
2.使用信号量集实现进程间的通信
2.1 基本概念
(1)什么是信号量？
      信号量本质就是一种计数器，用于控制同时访问同一个共享资源的进程个数/线程个数
(2)什么是信号量集？
      信号量集本质就是信号量的集合，也就是由若干个信号量组成的集合，主要用于控制多种共享资源各自同时被访问的进程/线程个数
(3)信号量的工作方式
    a.将信号量初始化为最大值；
    b.如果有进程申请到资源，则信号量的值减1；
    c.当信号量的值变为0时，申请资源的进程进入阻塞状态；
    d.如果有进程释放资源，则信号量的值加1；
    e.当信号量的值 > 0时，阻塞的进程继续抢占资源；
2.2 使用信号量集通信的基本模型
(1)获取key值，使用ftok函数
(2)创建/获取信号量集，使用semget函数
(3)初始化信号量集，使用semctl函数
(4)操作信号量集，使用semop函数
(5)如果不再使用，则删除信号量集，使用semctl函数
2.3 相关函数的解析
(1)semget函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semget(key_t key, int  nsems,  int semflg);
第一个参数：key值，ftok函数的返回值
第二个参数：信号量集的大小(信号量的个数)
       0  -  获取已经存在的信号量集
第三个参数：操作的标志
      IPC_CREAT  -  创建
      IPC_EXCL  - 与IPC_CREAT搭配使用，存在则创建失败
       0  -  获取已经存在的信号量集
返回值：成功返回信号量集的ID，失败返回-1
函数功能：
      主要用于创建/获取信号量集
注意：
     当创建新的信号量集时需要指定权限，如：0664等
(2)semctl函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semctl(int semid, int semnum, int cmd, ...);
第一个参数：信号量集的ID，semget函数的返回值
第二个参数：信号量集的下标(一般从0开始)
第三个参数：具体的操作命令
      IPC_RMID  -  删除信号量集，此时忽略第二个参数，不
                           需要第四个参数
      SETVAL  -  使用函数的第四个参数给信号量集中下标为
                        semnum的信号量进行初始化
第四个参数：可变长参数，是否需要取决于cmd
函数功能：
      主要用于控制指定的信号量集，具体功能取决于cmd
(3)semop函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semop(int semid, struct sembuf *sops, unsigned nsops);
第一个参数：信号量集的ID，semget函数的返回值
第二个参数：结构体指针，可以指向结构体变量，也可以指向
          结构体数组的首地址，结构体类型如下：
struct sembuf
{
    unsigned short sem_num;  /* 信号量的下标 */
    short  sem_op;   /* 信号量的操作 
         正数表示增加  0表示不变   负数表示减少  */
    short  sem_flg;  /* 操作标志，默认给0即可*/
};
第三个参数：结构体指针指向的结构体个数
函数功能：
      主要用于对指定的信号量执行指定的操作
2.4 基本命令
     ipcs  -s  表示查看当前系统中的信号量集
     ipcs  -a  表示查看当前系统中所有的IPC对象，包括共享内存，消息队列以及信号量集
     ipcrm  -s  信号量集的ID   表示删除指定的信号量集
3.综合小项目
3.1 项目名称
     银行账户管理系统(模拟ATM的功能)
3.2 项目功能
     开户、销户、存款、取款、查询、转帐、退出
3.3 项目架构
     采用C(Client)/S(Server)架构进行项目的架构  
客户端：
     提供界面让用户选择具体的业务，将用户的选择交给服务器进行处理，等待服务器的处理结果，并且显示给用户；
服务器：
    接受客户端发来的业务功能，通过访问数据库的方式进行处理，再将最终的处理结果交给客户端；
3.4 项目的详细设计
(1)客户端和服务器之间如何通信？？
     提供两个消息队列来实现通信
          消息队列一： 客户端  =>  服务器
          消息队列二： 服务器  =>  客户端
(2)不同的业务之间如何区分？？
     提供8种不同的消息类型
           6种不同的业务类型  + 成功  +  失败
(3)账户的数据类型和消息的数据类型应该如何设计？？
     采用结构体类型
     账户的信息：帐号、账户名称、密码、余额
     消息的信息：消息的类型   +   消息的内容(账户信息)
(4)以开户为例分析一下项目的执行流程
客户端：
    a.提供字符界面由用户选择具体的业务编号；
       => 使用printf打印界面即可
    b.根据用户的选择进入不同的分支处理；
       => 采用switch-case多分支结构
    c.提示用户输入用户名、密码以及余额信息；
       => 使用scanf函数进行读取即可
    d.将用户提供的信息和业务编号打包成完整的消息，
        发送到消息队列一中；
       => 打包消息的结构体变量，使用msgsnd发送即可
    e.等待服务器的处理结果，接收消息队列二中的消息；
       => 使用msgrcv函数进行接收，根据接收到的消息类型
             判断成功或失败，将结果打印出来
服务器：        
    a.创建两个消息队列；
      => 使用msgget函数
    b.接收消息队列一中的消息，并且判断消息的类型
      => 使用msgrcv函数，判断消息类型是否为开户的类型
    c.自动生成帐号，补充完整开户的用户信息，写入文件
       => 调用generator_id函数，使用write函数写入
       => 将每个用户信息保存在每个独立的文件中
       => 使用账户作为文件名确保唯一性，使用sprintf函数 
   d.根据用户信息写入是否成功，来修改对应的消息类型
       => 开户成功可以修改消息类型为7，否则修改为8
   e.将处理结果打包成完整的消息，发送到消息队列二中；
       => 使用msgsnd函数进行发送
   f.服务器应该24小时启动，除非手动去关闭；
       => 使用while(1)无限循环
       => 使用ctrl+c来关闭服务器，销毁两个消息队列
3.5 项目的要求
     (1)要求采用多文件的结构进行编程，而在每个文件中采用多个函数各自封装独立功能的方式进行编程；
     (2)要求实现开户的功能即可，有余力的同学考虑其他功能
3.6 项目的提示
     vi bank.h  -  定义用户信息和消息的数据类型
     vi client.c  -  编写打印字符界面的功能函数 ....
     vi server.c  -  编写创建消息队列的功能函数  ...
     vi dao.c  -  编写自动生成帐号的功能函数 ...
     ....
     最后支持Makfile文件
     
     
今天内容：
     (1)网络的基本常识
     (2)基于socket的一对一通信模型
     (3)基于tcp协议的通信模型
1.网络的基本常识
如：
    目前比较主流的网络通讯软件：QQ  微信  MSN  阿里旺旺 飞信 ... ...    
1.1 七层网络模型 和 常用的协议
(1)七层网络模型
     ISO将网络协议从逻辑上划分为7层，来保障数据传递过程中的可靠性、安全性等，具体的7层网络模型如下：
应用层 - 主要为应用程序的通信服务的，将数据交给应用程序
表示层 - 主要将数据按照统一的格式进行封装和打包等
会话层 - 对话，主要用于控制会话何时开始、何时结束等
传输层 - 主要对数据进行错误检查和重新排序等
网络层 - 主要用于选择具体的网络协议进行数据的传递
数据链路层 - 主要用于将打包好的数据转换为高低电平信号
物理层 - 主要指具体的交换机设备等
(2)常用的协议
    TCP - 传输控制协议，面向连接，该协议提供可靠的全双
               工的子节流
    UDP - 用户数据报协议，非面向连接，没有tcp协议可靠但
               是速度比较快
    IP  -  互联网协议，是上述两种协议的底层协议
1.2 IP地址 和 子网掩码的概念
(1)IP地址的概念和分类
     IP地址本质就是在互联网中的唯一地址标识，其数据类型为32位二进制组成的整数(ipv4)，当然也有128位二进制组成的整数(ipv6)
     日常生活中描述IP地址的主要形式为: 点分十进制表示法，也就是将每8位二进制转换为一个十进制整数，不同的十进制整数之间通过小数点分隔；
如：
     0x01020304  =>  1.2.3.4
查看IP地址的方式:
     windows系统中： ipconfig    ipconfig/all
     linux系统中： ifconfig    /sbin/ifconfig
     IP地址主要分为两部分：  网络地址  +  主机地址，根据网络地址和主机地址的划分，将IP地址分为以下4类：
     A类：0 + 7位网络地址 +  24位主机/本地地址
     B类：10 + 14位网络地址 + 16位主机/本地地址
     C类：110 + 21位网络地址 + 8位主机/本地地址
     D类：1110 + 28位多播地址
(2)子网掩码的概念
     子网掩码本质就是用于帮助IP划分具体的网络地址和主机地址，也可以用于判断两个IP地址是否在同一个局域网中，具体的划分方法为：按位&运算进行
如：
    IP地址：172.30.100.41
 子网掩码：255.255.255.0   &
-----------------------------------------------
                172.30.100   -  网络地址 
                             41   -  主机地址
练习：
     判断以下两个IP地址是否在同一个局域网中？？？
     166.111.160.1   和  166.111.161.45
      子网掩码全部为：255.255.254.0
解析：
     IP地址：166.111.160.1 
  子网掩码：255.255.254.0   &
-----------------------------------------------
                166.111.160   -  网络地址
    IP地址：166.111.161.45
 子网掩码：255.255.254.0   &
-----------------------------------------------
                166.111.160   -  网络地址
综上所述：
     上述两个IP地址在同一个局域网中
1.3 端口号和字节序的概念
(1)端口号
     IP地址 - 互联网中的地址标识，通过该地址可以定位主机
     端口号 - 主要用于定位某一台主机上的具体进程
     端口号的数据类型是：unsigned short类型，范围是：0 ~ 65535，其中0 ~ 1024之间的端口由系统占用，因此编程指定端口号时，建议从1025开始使用
     网络编程中需要提供：IP地址  +  端口号
(2)字节序的概念
小端系统：低位内存地址存放低位数据的系统
大端系统：低位内存地址存放高位数据的系统
如：
     对于十六进制的数据 0x12345678来说
小端系统中按照地址从小到大依次：0x78 0x56 0x34 0x12
大端系统中按照地址从小到大依次：0x12 0x34 0x56 0x78
一般性原则：
     对于多字节整数来说，为了避免不同的操作系统中存放字节序的不同而造成的数据不一致性问题，习惯上将所有发送出去的多字节整数先转换为网络字节序再发送，而将所有从网络上收到的多字节整数先转换为主机字节序再解析，而网络字节序本质就是大端系统的字节序
2.基于Socket的一对一通信模型
2.1 基本概念
    Socket  -  本意为插座的意思，表示逻辑上的通信载体
2.2 基本模型
服务器：
    (1)创建socket，使用socket函数
    (2)准备通信地址，使用结构体变量
    (3)绑定socket和	通信地址，使用bind函数
    (4)进行通信，使用read/write函数
    (5)关闭socket，使用close函数
客户端：
    (1)创建socket，使用socket函数
    (2)准备通信地址，是服务器的地址
    (3)连接socket和通信地址，使用connect函数
    (4)进行通信，使用read/write函数
    (5)关闭socket，使用close函数
2.3 相关函数的解析
(1)socket函数
     #include <sys/types.h>
     #include <sys/socket.h>
     int  socket(int  domain, int type, int protocol);
第一个参数：协议族/域，决定本地通信还是网络通信
     AF_UNIX/AF_LOCAL  -  实现本地通信
     AF_INET  -  实现基于ipv4网络协议的通信
     AF_INET6  -  实现基于ipv6网络协议的通信
第二个参数：通信的类型，决定具体的通信协议
     SOCK_STREAM  -  提供有序的、可靠的、双向的面向连
            接的字节流通信，本质就是基于tcp协议的通信模式
     SOCK_DGRAM  -  提供不可靠的，非面向连接的数据报
            通信，本质就是基于udp协议的通信模式
第三个参数：特殊的协议，直接给0即可
返回值：成功返回socket的描述符，失败返回-1
函数功能：
      主要用于创建端点来实现进程间的通信
(2)通信地址的结构体类型
a.通用的通信地址
   struct sockaddr 
   {
        sa_family_t sa_family;
        char        sa_data[14];
   };
   该结构体主要用于函数的形参类型，很少定义结构体变量
b.实现本地通信的通信地址
   #include <sys/un.h>
   struct sockaddr_un
   {
         sa_family_t  sun_family;//地址族，相当socket函数
                   中的第一个参数
         char  sun_path[];//socket文件的路径名
   };
   该结构体专门用于准备本地通信的通信地址
c.实现网络通信的通信地址
   #include <netinet/in.h>
   struct sockaddr_in
   {
        sa_family_t  sin_family; //地址族 AF_INET
        in_port_t       sin_port ;// 端口号
        struct in_addr  sin_addr;// ip地址
   };
   struct in_addr
   {
        in_addr_t  s_addr; 
   };
   该结构体专门用于准备网络通信的通信地址
(3)bind函数
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>
    int bind(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：通信地址的首地址，需要类型转换
第三个参数：通信地址的大小，使用sizeof计算即可
函数功能：
      主要用于socket和通信地址
(4)connect函数
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>
     int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
函数功能：
     主要用于连接socket和通信地址，参数和返回值参考bind函数即可
(5)字节序的转换函数
     #include <arpa/inet.h>
     uint32_t htonl(uint32_t hostlong);
 => 主要用于将32位的主机字节序转换为网络字节序
     uint16_t htons(uint16_t hostshort);
 => 主要用于将16位的主机字节序转换为网络字节序
     uint32_t ntohl(uint32_t netlong);
 => 主要用于将32位的网络字节序转换为主机字节序
     uint16_t ntohs(uint16_t netshort);
 => 主要用于将16位的网络字节序转换为主机字节序
(6)IP地址的转换函数
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    in_addr_t inet_addr(const char *cp);
 => 主要用于将字符串形式的IP地址转换为整数类型
    char *inet_ntoa(struct in_addr in);
 => 主要用于将结构体类型的IP地址转换为字符串类型
作业：
     练习和理解基于socket的通信模型
明日预报：
     (1)基于tcp的网络通信模型
     (2)tcp和udp协议的区别
     (3)基于udp的网络通信模型
 
复习：
1.网络的基本常识
1.1 七层网络模型和常用的网络协议
     七层网络模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
     TCP  -  传输控制协议，面向连接的协议，提供可靠的全双工的字节流通信
     UDP  -  用户数据报协议，非面向连接，没有tcp可靠但是传输速度比较快
     IP   -  互联网协议，上述协议的底层协议
1.2 IP地址和子网掩码
    IP地址本质就是互联网中的唯一地址标识，是32位二进制组成的整数(ipv4)，还有128位二进制组成的整数(ipv6)
    日常生活中，采用点分十进制表示法描述IP地址
    IP地址分为:  网络地址  +  主机地址
    子网掩码 -  主要用于划分IP地址的网络地址和主机地址
         IP地址 &  子网掩码
1.3 端口号和字节序
    IP地址 -  定位具体的某一台主机
    端口号 - 定位具体主机中的某一个进程
   端口号的数据类型是：unsigned short类型，范围是：0 ~ 65535，其中0 ~ 1024被系统占用
小端系统：将低位数据存放在低位内存地址的系统
大端系统：将地位数据存放在高位内存地址的系统
2.基于socket的一对一通信模型
服务器：
      (1)创建socket，使用socket函数
      (2)准备通信地址，使用结构体类型
      (3)绑定socket和通信地址，使用bind函数
      (4)进行通信，使用read/write函数
      (5)关闭socket，使用close函数
客户端：
      (1)创建socket，使用socket函数
      (2)准备通信地址，使用服务器的地址
      (3)连接socket和通信地址，使用connect函数
      (4)进行通信，使用read/write函数
      (5)关闭socket，使用close函数
-----------------------------------------------------------------------------
今天内容：
     (1)基于tcp协议的网络通信模型
     (2)tcp协议和udp协议的比较
     (3)基于udp协议的网络通信模型
1.基于tcp协议的网络通信模型(重点)
1.1 通信模型
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)监听，使用listen函数
     (5)响应客户端的连接请求，使用accept函数
     (6)进行通信，使用read/write函数
     (7)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用服务器的地址
     (3)连接socket和通信地址，使用connect函数
     (4)进行通信，使用read/write函数
     (5)关闭socket，使用close函数
1.2 相关函数的解析
(1)listen函数
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>
    int listen(int sockfd, int backlog);
第一个参数：socket描述符，socket函数的返回值
第二个参数：指定等待连接队列的最大长度
        (允许在该socket上等待被连接的最大个数)
函数功能：
     主要用于将第一个参数指定的socket标记为被动的socket，也就是该socket专门用于使用accept函数去响应即将到来的连接请求，不再作为通信使用
(2)accept函数
     #include <sys/types.h> 
     #include <sys/socket.h>
     int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：结构体指针，用于存放客户端的通信地址
第三个参数：通信地址的大小
返回值：成功返回用于通信的socket的描述符，失败返回-1
函数功能：
      主要用于响应等待被处理队列中的第一个连接请求
注意：
      socket函数返回的描述符 主要用于监听和响应
      accept函数返回的描述符 主要用于通信的
练习：
     使用tcp协议的编程模型实现一对多的通信
a.要求服务器可以不断地响应客户端的连接请求；
b.要求服务器可以同时和多个客户端进行通信；
c.要求针对每一个客户端可以进行不断地通信；
d.要求当客户端发来"bye"时，表示客户端下线，终止对应
    的子进程；
e.要求使用信号2来关闭服务器；
f. 要求客户端发送的消息由用户手动输入；
2.tcp协议和udp协议的比较
2.1 tcp协议的概念和特性
    tcp - 传输控制协议，是一种面向连接的协议，类似打电话
         建立连接   =>  进行通信   =>  断开连接
         在通信的整个过程中全程需要保持连接
优点和缺点：      
     (1)保证了数据传输的可靠性和有序性，也就是当数据接受
方没有反馈确认信息时，数据发送方会重新发送数据，并且对发送的数据进行编号，接受方可以根据编号进行排序
     (2)属于全双工的字节流通信方式
     (3)数据的接受方可以控制数据发送方的流量大小
     (4)服务器的压力比较大，资源的占用率比较高，发送的速度也会比较慢；
    
2.2 udp协议的概念和特性
    udp - 用户数据报协议，非面向连接的协议，类似发短信
    在通信的整个过程中不需要全程保持连接
优点和缺点：
    (1)服务器端的压力比较小，资源的占用率比较低，发送的速度比较快；
    (2)不能保证数据的可靠性和有序性，数据报也会丢失；
    (3)属于全双工的数据报通信方式
    (4)数据的接受方不能控制数据发送方的流量大小
3.基于udp协议的通信模型(重点)
3.1 通信模型
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)进行通信，使用sendto/recvfrom函数 
     (5)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用服务器的地址
     (3)进行通信，使用sendto/recvfrom函数 
     (4)关闭socket，使用close函数
3.2 相关函数的解析
(1)sendto函数
    #include <sys/types.h>
    #include <sys/socket.h>
     ssize_t send(int sockfd, const void *buf, size_t len, int flags);
     ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：被发送数据的首地址
第三个参数：被发送数据的大小
第四个参数：发送的标志，默认给0表示产生阻塞
第五个参数：数据接受方的通信地址
第六个参数：数据接受方通信地址的大小
返回值：成功返回实际发送的数据大小，失败返回-1
函数功能：
      主要用于将指定的消息发送到指定的地址上
(2)recvfrom函数
     #include <sys/types.h>
     #include <sys/socket.h>
     ssize_t recv(int sockfd, void *buf, size_t len, int flags);
     ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：存放接受到数据的缓冲区首地址
第三个参数：接受的数据大小
第四个参数：接受的标志，默认给0即可
第五个参数：保存数据发送方的通信地址(来电显示)
第六个参数：通信地址的大小
返回值：成功返回实际接受的数据大小，失败返回-1
函数功能：
      主要用于接受指定的数据并提供来电显示的功能
注意：
     在vi的命令模式下，执行命令：
           :n1,n2 >  表示将n1行到n2行之间的代码向右缩进
           :n1,n2 <  表示将n1行到n2行之间的代码向左缩进
           :n1,n2  co  n3  表示将n1行到n2行之间的代码拷贝
                            到n3行的下面
           :n1,n2  mo  n3  表示将n1行到n2行之间的代码剪切
                            到n3行的下面
     虽然read/write函数也可以实现接受和发送消息，但是在以后的网络编程中要求优先使用send/recv/sendto/recvfrom函数，尽量不去使用read/write函数
作业：
     使用udp协议的通信模型编程实现一个时间服务器，也就是只要服务器收到客户端发来的消息，则将当前服务器的系统时间发送给该客户端
明日预报：
    (1)多线程的编程
         
复习：
1.基于tcp协议的通信模型(重点)
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)监听，使用listen函数
     (5)响应客户端的连接请求，使用accept函数
     (6)进行通信，使用send/recv函数
     (7)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用服务器的地址
     (3)连接，使用connect函数
     (4)进行通信，使用send/recv函数
     (5)关闭socket，使用close函数
2.基于udp协议的通信模型(重点)
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)进行通信，使用recvfrom/sendto/recv/send函数
     (5)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，服务器的地址
     (3)进行通信，使用sendto/recvfrom/send/recv函数
     (4)关闭socket，使用close函数
作业：   
-----------------------------------------------------------------------------
今天内容：
     (1)多线程的编程
     (2)综合小项目
1.多线程的编程
1.1 基本概念
      线程本质就是进程内部的程序流，隶属于进程，目前主流的操作系统都支持多进程，而在每一个进程的内部又可以支持多线程，从而实现并行处理的效果
      进程是重量级的，每个进程都需要独立的内存空间，新建进程对资源的消耗是比较大的；而线程是轻量级的，共享所在进程的内存资源，但是每个线程都有一个独立的栈区；
1.2 线程的创建
(1)pthread_create函数
     #include <pthread.h>
     int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);
第一个参数：整数指针，用于存放新线程的线程编号
第二个参数：线程的属性，给NULL选择默认的属性
第三个参数：函数指针类型，新线程的处理函数
第四个参数：作为第三个参数指向函数的实参
返回值：成功返回0，失败返回具体的错误编号
函数功能：
      主要用于在当前正在调用的进程中启动新线程，让新线程去执行第三个参数指向的函数，函数执行完毕后，线程结束
注意：
       Compile and link with -pthread.
(2)多线程执行的关系
     执行main函数的线程  叫做  主线程
     使用pthread_create函数创建出来的新线程 叫做 子线程
     多线程创建完毕之后各自独立运行，执行的先后次序取决于操作系统，多线程之间相互独立也会相互影响，因为主线程结束时main函数结束，而main函数结束表示整个进程结束，一旦整个进程结束，则整个进程内部的所有线程结束
(3)pthread_self函数
     #include <pthread.h>
     pthread_t pthread_self(void);
函数功能：
     主要用于获取当前正在调用线程的编号，通过返回值返回
     Compile and link with -pthread.
练习：
     使用malloc函数申请4个字节的动态内存，提示用户输入一个半径存放到动态内存中，使用pthread_create函数创建子线程，在线程处理函数中计算圆形的周长和面积并且打印出来，等待子线程结束后，释放动态内存
1.3 线程的汇合和分离
(1)pthread_join函数
     #include <pthread.h>
     int pthread_join(pthread_t thread, void **retval);
第一个参数：线程的编号(等待哪一个线程)
第二个参数：该参数不为空时，将目标线程的退出状态信息拷
       贝到*retval指向的位置中
返回值：成功返回0，失败返回错误编号
函数功能：
      主要用于等待参数一指向的线程终止，并且获取终止的退出状态信息，同时回收该线程的所有资源，当然前提是thread指向的线程可以被等待
      Compile and link with -pthread.
练习：
     使用pthread_create函数创建子线程，在子线程中计算1 ~ 100之间的和并存放在sum变量中，要求将最终的计算结果返回给主线程，主线程通过pthread_join函数进行接受并打印出来
(2)pthread_detach函数
     #include <pthread.h>
     int pthread_detach(pthread_t thread);
函数功能：
     主要用于将参数指定的线程设置为分离状态，一个分离状态的线程终止时，它的资源会被自动地释放给系统不需要其他线程的帮助/等待/加入，其他线程调用pthread_join也无法等待
     Compile and link with -pthread
1.4 线程的终止和取消
(1)pthread_exit函数
    #include <pthread.h>
    void pthread_exit(void *retval);
函数功能：
     主要用于终止当前正在调用的线程，该函数的参数作为当前终止线程的退出状态信息，在同一个进程中的其他线程可以通过pthread_join来获取该参数值
     Compile and link with -pthread.
(2)pthread_cancel函数
     #include <pthread.h>
     int pthread_cancel(pthread_t thread);
函数功能：
//给thread线程发送终止信号
     主要用于给参数指定的线程发送取消的请求，是否取消以及何时取消取决于线程的属性信息:state  和  type
     Compile and link with -pthread.
     #include <pthread.h>
     int pthread_setcancelstate(int state, int *oldstate);
第一个参数：设置新的取消状态
     PTHREAD_CANCEL_ENABLE - 表示可以被取消(默认)
     PTHREAD_CANCEL_DISABLE - 表示不可以被取消
第二个参数：用于带出旧的取消状态，给NULL表示不获取
     int pthread_setcanceltype(int type, int *oldtype);
第一个参数：设置新的取消类型
     PTHREAD_CANCEL_DEFERRED - 延迟取消(默认)
     PTHREAD_CANCEL_ASYNCHRONOUS - 立即取消
第二个参数：用于带出旧的取消类型，给NULL表示不获取
     Compile and link with -pthread.
2.线程的同步问题
2.1 基本概念
    当一个进程中有多个线程时，多线程之间共享所在进程的资源，如果多个线程同时访问同一个共享资源时，需要相互协调，以防止数据出现不一致和不完整的问题，线程之间的协调和通信叫做线程的同步问题
2.2 实现线程同步的具体方案
     让多个线程依次串行访问共享资源即可
2.3 使用互斥量/互斥锁实现线程的同步
(1)定义互斥量
     pthread_mutex_t  mutex;
(2)初始化互斥量
     pthread_mutex_init(&mutex,NULL);
(3)使用互斥量进行加锁
     pthread_mutex_lock(&mutex);
(4)使用共享资源
(5)使用互斥量进行解锁
     pthread_mutex_unlock(&mutex);
(6)如果不再使用，销毁互斥量
     pthread_mutex_destroy(&mutex);     
2.4 使用信号量实现线程的同步问题
(1)基本概念
     信号量本质就是一个计数器，主要用于控制同时访问共享资源的进程/线程个数
     当信号量的值为1时，效果等同于互斥量；
(2)使用流程
    #include <semaphore.h>
    a.定义信号量
       sem_t sem;
    b.初始化信号量
       sem_init(&sem,0,最大的初始值);
    c.获取一个信号量(信号量的值减1)
       sem_wait(&sem);
    d.使用共享资源
    e.释放一个信号量(信号量的值加1)
       sem_post(&sem);
    f.如果不再使用，删除信号量
       sem_destroy(&sem);
3.综合小项目
     采用C/S架构通过tcp通信模型和多线程实现聊天室
服务器：
     (1)要求服务器可以不断地响应客户端的连接请求
          => 使用while(1)无限循环
          => 将每一个连接上来的客户端通信地址和对应的描述
                 符保存起来，采用数组/链表都可以
     (2)要求服务器可以同时和多个客户端通信
          => 使用多线程的技术来实现
     (3)要求服务器针对每一个客户端可以不断地通信
          => 使用while(1)无限循环
     (4)要求客户端发来"bye"时，表示客户端已下线
          => 进行字符串比较，终止对应的线程pthread_exit
          => 从数组/链表中删除已经下线的客户端信息
     (5)要求服务器可以将接受到的消息转发给其他所有客户端
          => 使用send函数对上述保存过的每一个描述符进行
                发送数据即可
          => 注意跳过已经下线的客户端
     (6)使用信号2来关闭服务器
          => 对信号2进行自定义处理
客户端：
     (1)要求每一个客户端启动时需要指定一个昵称
     (2)要求客户端不断地和服务器进行通信，发送的内容由
          用户手动输入
     (3)要求客户端收发功能独立运行，采用多线程技术
     (4)当客户端发送"bye"时，表示客户端下线
扩展功能：
     (1)编程实现传输文件的功能
     (2)使用网络编程和多线程技术重构银行项目
      
1.自我介绍
   马如忠     ruzhongMa    小马哥    
   marz@tedu.cn 
   赠送一句话：
        程序员是代码喂出来的   
   永久性的作业：
        苦练指法！
   
2. 课程的简介
2.1 课程阶段的简介
     Unix/linux系统下的基本命令
  => 主要学习Unix/linux中常用的命令
  => 依赖于具体的操作系统，但是部分命令与windows相同
  
     标准C语言的学习
  => 主要学习标准C语言的基本语法
  => 不依赖于具体的操作系统，绝大部分程序可以在任意系
       统中使用
     
     数据结构和算法
  => 主要学习常用的数据结构和算法，理解编程的思想
  => 不依赖于具体的编程语言，也不依赖于具体的操作系统
     Unix/linux系统下的高级C编程
  => 主要学习操作系统的基本原理以及常用的API函数
  => 依赖于具体的编程语言，也依赖于具体的操作系统
  => 用时 15天 左右
  目前主流的主机操作系统：
       unix系列/linux系列/windows系列
       windows系列： Xp/vista/win7/win8/win8.1/win10
     
   目前主流的移动终端操作系统：
        android/ios/window10
 
2.2 Unix/linux系统下高级C编程的主要内容
    (1)Unix/linux系统下的开发方式和编程基础
    (2)Unix/linux系统下的内存管理技术
    (3)Unix/linux系统下的文件管理和目录操作
    (4)Unix/linux系统下的进程管理  
    (5)Unix/linux系统下的信号处理
    (6)Unix/linux系统下的进程间通信技术
    (7)Unix/linux系统下的网络编程技术
    (8)Unix/linux系统下的多线程技术
----------------------------------------------------------------------------
今天内容：
    (1)Unix/linux系统的简介
    (2)gcc编译器的使用
    (3)多文件结构的编程
    (4)常用的预处理指令
    (5)环境变量的概念和使用
1.Unix/linux系统的简介
1.1 Unix系统的简介
      在1969年左右，编写操作系统时采用的汇编语言，编写和维护都非常不方便，贝尔实验室  汤普逊 研发了一门语言叫做B语言， 贝尔实验室 丹尼斯-里奇 在B语言的基础上做了修改和扩展，叫做 New B语言，后来改名为C语言
      C语言诞生于1972年，在编程语言排行榜上占据重要
的地位    
      Unix系统诞生于1970年，具有多用户、多任务以及支持多种处理器的特点  
1.2 linux系统的简介
     linux系统是一款  自由免费开放源代码的类Unix操作系统
     ubuntu 系统是一款linux系列的操作系统，每六个月会发布一个版本，分别是：4月 和  10月
     当前教学环境： ubuntu  12.04版本   32位的操作系统
     
2.gcc的使用
2.1 基本概念
    gcc 原名叫做 GNU C Compiler(编译器)，只支持对C语言的编译处理，后来对该编译器做了扩展，支持了更多的编程语言，如C++等，因此改名为 GNU  Compiler Collection
2.2 基本功能(重点)
     编程时采用的是高级语言，如C语言等，高级语言编写的程序代码无法被计算机直接执行，需要将高级语言转换为汇编语言，再将汇编语言转换为机器指令，最后链接生成可执行文件才能被计算机执行，而上述过程主要包含以下四步走：
(1)预处理/预编译
    - 主要用于实现头文件的扩展和宏替换等
(2)编译
    - 主要用于将高级语言翻译成汇编语言，得到汇编文件
(3)汇编
    - 主要用于将汇编语言翻译成机器指令，得到目标文件
(4)链接
    - 主要用于将目标文件和库文件进行链接，得到可执行文件
2.3 常用的编译选项
(1)熟练掌握的选项
     gcc/cc -E  xxx.c
  => 表示对高级源代码文件进行预处理操作，默认输出到控
        制台上，使用-o选项来改变输出位置为 xxx.i
      
     gcc/cc -S xxx.i
  => 表示将预处理文件经过编译翻译成汇编语言文件(xxx.s)
     gcc/cc -c xxx.s
  => 表示将汇编语言文件翻译成机器语言文件(xxx.o)
     gcc/cc xxx.o
  => 表示链接目标文件和库文件生成可执行文件(a.out)
     gcc/cc xxx.c
  => 表示编译链接生成可执行文件(需要执行上述4步走)
练习：
     gcc/cc -E xxx.c -o xxx.i
     gcc/cc -S xxx.i/xxx.c
     gcc/cc -c xxx.s/xxx.i/xxx.c
     gcc/cc xxx.o/xxx.s/xxx.i/xxx.c
(2)熟悉的选项
     -std   表示用于指定具体的C标准
     -v      表示用于查看编译器的版本信息
     -Wall 表示尽可能多地显示所有的警告信息
     -Werror 表示把警告当作错误进行处理
(3)了解的选项
     -g  表示生成调试信息
     -x   表示用于指定源代码的编程语言
     -O  表示进行优化处理
(4)扩展的选项
     man  命令/函数名称/gcc/cc 
     作业： 装个英文词典 -  星际译王 
2.4 常见的文件后缀
     .h  - 头文件             .c  - 源文件
     .i   - 预处理文件       .s  - 汇编文件
     .o  - 目标文件            
     .a  - 静态库文件        .so - 共享库文件
3.多文件结构的编程
3.1 多文件结构的主要组成
     .h - 头文件，主要存放结构体的定义，函数的声明等
     .c - 源文件，主要存放函数的定义等
     .a - 静态库文件，主要对功能函数的打包
     .so - 共享库文件，主要对功能函数的打包
3.2 头文件的详细内容(重点)
(1)头文件卫士
    #ifndef xxxx
    #define xxx
    #endif //xxx
(2)包含其他头文件
    #include <stdio.h>
    ... ...
(3)进行宏定义
    #define PI 3.14
    ... ...
(4)结构体的定义以及对类型起别名
    typedef struct 
    {
	 link lk;
    } stack;
(5)外部变量/函数的声明
    extern int num;
    void show(void);
    ... ...
注意：
    变量/函数的定义不能放在头文件中，因为当多个.c包含该头文件时，在一起编译链接的情况下会引发重定义的错误信息
例子：
     采用多文件的结构进行编程，要求根据用户输入的半径计算出圆形的周长和面积
     周长： 2 * PI * r 
     面积： PI * r * r
作业：
     练习从高级源代码到可执行文件的生成步骤
明日预报：
    (1)常用的预处理指令
    (2)环境变量的概念和使用
    (3)库文件的概念和使用
 
      
 
           
  
   
复习：
1.Unix/linux系统的简介
1.1 Unix系统的简介
     C语言诞生于1972年，在编程语言排行榜上占据重要
的地位
     Unix系统诞生于1970年，具有支持多用户、多任务、以及多种处理器的特点
1.2 linux系统的简介
     linux系统是一款  免费自由开发源代码的类Unix操作系统
    
2.gcc编译器的使用
2.1 基本概念
     原名叫做GNU C Compiler  该名为 GNU Compiler Collection
2.2 基本功能
     根据高级语言编写的源代码，来生成最终的可执行文件
(1)预处理/预编译   -E   
(2)编译  -S
(3)汇编   -c
(4)链接   gcc/cc xxx.o
2.3 常用的编译选项
     -E    -S   -c   -o 
     -std   -v   -Wall   -Werror
     -g   -x   -O
     man gcc/cc
2.4 常用的文件后缀
     .h     .c    .i     .s     .o     .a     .so
3.多文件结构的编程
3.1 多文件结构的主要组成
      .h   .c   .a    .so
3.2 头文件中的详细内容
(1)头文件卫士
     #ifndef ...
     #define ...
     #endif
(2)包含其他头文件
     #include <stdio.h>
(3)进行宏定义
     #define PI 3.14
(4)结构体的定义以及对类型其别名
     typedef struct
     {
          int id;
          char name[20];
     }Student; 
(5)外部变量/函数的声明
     extern int num;
     void show(void);
----------------------------------------------------------------------------
今天内容：
    (1)常用的预处理指令
    (2)环境变量的概念和使用
    (3)库文件的概念和使用
1.常用的预处理指令
1.1 复习标C中学过的预处理指令
     #include   包含...
     #define     定义...
     #undef      取消宏定义
     #ifdef        如果定义...
     #ifndef      如果没有定义...
     #if             如果...
     #elif          否则如果...
     #else         否则...
     #endif        结束如果
     ... ...
1.2 学习常用的新指令
     #line  整数n
 => 主要用于将下一行的行号修改为第n行
 => 可以用于控制调试阶段出错的行号
     #warning  字符串
  => 表示在预处理阶段产生一个警告信息
     #error 字符串
  => 表示在预处理阶段产生一个错误信息
  => 可以用于在调试阶段产生错误/警告信息
思考：
     #if   和 普通的if之间有什么区别呢？？
       #if  - 在编译期间做检查和判断
         if   - 在运行阶段做检查和判断
     #pragma GCC dependency 文件名
 => 表示当前文件依赖于指定的文件名，如果指定的文件最后
       一次修改时间晚于当前文件，则产生警告信息
 => 可以用于在调试阶段去监控具体的文件
老杨：vi show.c
       void show(void)
       {
             printf("我是帅哥我怕谁\n");
       }
小马哥：vi main.c
       #pragma GCC dependency "show.c"
       int main(void)
       {
             show();
             return 0;
       }
       #pragma GCC poison 标识符
   => 主要用于将指定的标识符设置为毒药，一旦使用该标识
        符则产生错误信息
         
      #pragma pack(整数n)
   => 表示设置结构体按照n的整数倍进行对齐和补齐
   => 主要用于通过上述方式来节省内存空间
        
1.3 常用的预定义宏
    __FILE__  -  用于获取预定义宏所在的文件名   %s
    __LINE__  -  用于获取预定义宏所在的行号      %d
    __DATE__ -  用于获取预定义宏所在文件的最后一次
                       编译日期  %s
    __TIME__ -  用于获取预定义宏所在文件的最后一次
                       编译时间  %s
    ... ...
2.环境变量的概念和使用
2.1 基本概念
      环境变量 - 一般是指在操作系统中用来指定操作系统运行的相关参数的特殊变量，也就是说环境变量就是用于存放系统/软件环境 相关参数信息的 特殊变量
      Path/PATH本质就是一种环境变量，路径存放在该环境变量中的应用程序/软件 可以通过文件名直接运行，从而省略路径信息
2.2 配置方法
(1)Windows Xp系统中的配置方法
      我的电脑 => 右键，选择属性  => 高级  =>  环境变量 => 系统变量中，找到Path,点击编辑  =>  在Path变量值的最后增加分号，再添加新路径  => 一路点击确定即可
      其中分号就是一个路径分隔符，用于划分不同的路径
      (切记 不要删除Path变量中之前的变量值)
(2)linux系统中的配置方法
      打开终端输入：  
           export PATH=$PATH:.
                $PATH - 表示获取环境变量PATH原来的数值
                     ：    - 表示路径分隔符，用于划分不同的路径
                       .  - 表示当前目录
      执行上述指令之后，表示把当前目录所在的路径追加到环境变量PATH的变量值末尾
      上述配置方法只对当前终端有效，新开的终端无法使用，为了配置永久性生效，vi ~/.bashrc文件中，编写以下代码：
      export PATH=$PATH:.
      保存退出之后，使用source ~/.bashrc文件，让配置文件中的指令立即生效
处理意外情况的方法：
     打开主目录，在主目录中使用快捷键 ctrl + h来显示所有的隐藏目录和文件，找到.bashrc文件，点击鼠标右键，选择使用文件编辑器的方式打开，修改文件内容后，保存关闭即可
2.3 编程相关的常用环境变量
     CPATH/C_INCLUDE_PATH 
  - 主要用于存放C语言头文件所在的路径
     CPLUS_INCLUDE_PATH 
  - 主要用于存放C++语言头文件所在的路径
     LIBRARY_PATH 
  - 主要用于存放库文件路径，解决编译链接时的问题
     LD_LIBRARY_PATH
  - 主要用于存放共享库所在的路径，解决运行时的问题
练习：
     采用多文件的结构进行编程，编写以下3个文件：
        add.h - 声明一个计算两个int类型参数和并返回的函数
        add.c  - 实现头文件中声明的函数
        main.c - 调用自定义的函数即可
2.4 查找头文件的主要方式
(1)#include <>
     - 表示在系统默认的路径中查找该头文件中
     - /usr/include/ ...
     - 可以使用命令whereis 来查找具体的头文件
(2)#include ""
     - 表示优先在当前目录中查找该头文件，查找不成功时，
       也会去系统默认的路径中进行查找
(3)配置环境变量CPATH/C_INCLUDE_PATH
       export CPATH=$CPATH:..
(4)采用编译选项进行指定(重点)
       gcc/cc xxx.c -I 头文件所在的路径
       gcc/cc xxx.c -I ..
注意：
      方法(1)(2)的缺点在于：一旦头文件的位置发生改变，则需要修改源程序来解决问题
      方法(3)的缺点在于：当有多个项目需要配置环境变量时，可能会引起冲突
      方法(4)的优势在于既不需要修改源程序，也不会引起多个项目的冲突问题，因此优先采用此方法
3.库文件的概念和使用
      在大型项目中，如果每个功能函数都存放在一个独立的.o文件中，那么项目管理变成灾难问题，因此采用库文件来解决该文件，具体的解决方案如下：一般按照功能模块将多个.o文件打包成一个/多个库文件，编写者只需要提供库文件和头文件即可
     库文件主要分为两种： 静态库文件(.a) 和共享库文件(.so)
3.1 静态库的概念和特性
(1)基本概念
     静态库本质就是由若干个.o文件打包生成的.a文件
     链接静态库的方式就是将库中被调用的代码指令复制到调用模块中，体现在最终的可执行文件中
(2)基本特性
优点：
      a.不需要跳转，因此效率会比较高
      b.可以脱离静态库文件
缺点：
      a.最终生成的可执行文件会比较大
      b.修改和维护都非常不方便
注意：
      使用ldd a.out的方式查看所以来的库文件
      使用gcc/cc -static xxx.c的方式强制要求按照静态库的方式进行链接处理，最终生成的可执行文件比较大
作业：
     复习uc讲过的内容
明日预报：
     (1)库文件的概念和使用
     (2)C语言中的错误处理
     (3)环境表的概念和使用
      
   
 
     
               
     
    
 
复习：
1.常用的预处理指令
   #line 整数n
   #warning 字符串
   #error 字符串
   
   #pragma GCC dependency 文件名
   #pragma GCC poison 标识符
   #pragma pack(整数n)   
2.环境变量的概念和使用
2.1 基本概念
   环境变量 - 用于存放系统/软件环境参数信息的特殊变量
   Path/PATH 就是一种环境变量，存放应用程序/软件的路径信息，启动应用程序/软件 只需要文件名即可
2.2 配置方法
(1)Xp系统
     我的电脑  => 右键，选择属性  => 高级  => 环境变量 => 系统变量Path，点击编辑，在变量值的末尾增加分号，添加新路径  =>  一路点击确定即可
(2)linux系统中配置方法
     终端中： export PATH=$PATH:.
      vi ~/.bashrc文件
      source ~/.bashrc
2.3 常用的环境变量
     CPATH/C_INCLUDE_PATH
     CPLUS_INCLUDE_PATH
     LIBRARY_PATH 
     LD_LIBRARY_PATH
     
2.4 查找头文件的主要方式
(1)#include <>
(2)#include ""
(3)配置环境变量CPATH  
     export CPATH=$CPATH:..
(4)gcc/cc xxx.c -I 头文件所在的路径(重点)
3.库文件的概念和使用
3.1 静态库的概念和特性
(1)基本概念
     静态库本质就是由若干个.o文件打包生成的.a文件
     链接静态库的方式本质就是将被调用的代码指令复制到调用模块中，体现在最终的可执行文件中
(2)基本特性
优点：
     a.不需要跳转，执行效率高
     b.可以脱离静态库文件
缺点：
     a.最终生成的可执行文件会比较大
     b.修改和维护都不方便
----------------------------------------------------------------------------
今天内容：
    (1)库文件的概念和使用
    (2)C语言中的错误处理
    (3)环境表的概念和使用
1.库文件的概念和使用
1.1 静态库的生成和调用步骤
(1)生成步骤
    a.编写源程序xxx.c，如：vi add.c
    b.只编译不链接生成目标文件xxx.o
       如： cc -c add.c
    c.生成静态库文件
        ar -r/*插入*/ lib库名.a 目标文件名
        ar -r libadd.a add.o
(2)调用步骤
    a.编写测试源程序xxx.c，如：vi main.c
    b.只编译不链接生成目标文件xxx.o
       如： cc -c main.c
    c.链接静态库文件生成可执行文件，链接方式有以下三种：
       1)直接链接
            cc 目标文件 静态库文件名
            如：cc main.o libadd.a
       2)采用编译选项进行链接(重点)
            cc 目标文件 -l 库名 -L 库文件所在的路径
            如：cc main.o -l add -L .
       3)通过配置环境变量LIBRARY_PATH进行链接
             export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add
1.2 共享库的基本概念和特性
(1)基本概念
     共享库本质就是由若干个.o文件打包生成的.so文件
     共享库和静态库的最大不同就是：链接共享库时并不会把被调用的代码指令复制到调用模块中，而是将被调用的代码指令在共享库中的相对地址嵌入到调用模块中
(2)基本特性
优点：
      a.共享库占用的空间比较小，也就是可执行文件比较小
      b.修改和维护都非常方便
缺点：
      a.需要跳转执行，因此执行效率比较低
      b.不可以脱离共享库文件
注意：
     目前主流的开发都采用共享库文件
1.3 共享库的生成和调用步骤
(1)生成步骤
    a.编写源程序xxx.c，如：vi add.c
    b.只编译不链接生成目标文件xxx.o
      如： cc -c -fpic/*小模式*/ add.c
    c.生成共享库文件
       gcc/cc  -shared/*共享的*/ 目标文件 -o lib库名.so
      如:   cc -shared add.o -o libadd.so 
(2)调用步骤
    a.编写测试源程序xxx.c，如：vi main.c
    b.只编译不链接生成目标文件xxx.o
       如： cc -c main.c
    c.链接共享库文件生成可执行文件，链接方式有以下三种：
       1)直接链接
            cc 目标文件 共享库文件名
            如：cc main.o libadd.so
       2)采用编译选项进行链接(重点)
            cc 目标文件 -l 库名 -L 库文件所在的路径
            如：cc main.o -l add -L .
       3)通过配置环境变量LIBRARY_PATH进行链接
             export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add    
注意：
     调用共享库文件时需要配置环境变量LD_LIBRARY_PATH
，具体的配置方法如下：
     export  LD_LIBRARY_PATH=$LD_LIBRARY_PATH:. 
注意：
    当同一个目录中具有相同库名的静态库和共享库时，使用gcc/cc编译链接时会自动优先选择共享库进行链接，如果希望链接静态库则使用-static选项来强制要求
1.4 共享库的动态加载
     #include <dlfcn.h>
     编译链接时需要指定选项  -ldl
(1)dlopen函数     
     void *dlopen(const char *filename, int flag);
第一个参数：字符串形式的文件名
第二个参数：具体的操作标志
      RTLD_LAZY - 延迟加载
      RTLD_NOW - 立即加载
返回值：成功返回共享库的句柄信息/地址，失败返回NULL
函数功能：
      主要用于加载第一个参数指定的共享库到内存中
(2)dlsym函数
     void *dlsym(void *handle,  const  char *symbol);
第一个参数：共享库的句柄，dlopen函数的返回值
第二个参数：字符串形式的符号，一般指函数名
返回值：成功返回函数名所对应的内存地址，失败返回NULL
函数功能：
      主要用于查找指定共享库中指定函数被加载到内存中地址
(3)dlclose函数
     int dlclose(void *handle);
函数功能：
     主要用于关闭/卸载参数指定的共享库，成功返回0，失败
     返回非0
(4)dlerror函数
     char *dlerror(void);
函数功能：
     主要用于获取dlopen/dlsym/dlclose函数执行期间产生的最近一个错误信息通过返回值返回，如果没有产生错误，则返回值为NULL
2.C语言中的错误处理
如：
     int main(void)
     {
           return 0; //表示程序正常结束
          // return -1;  // 表示程序出错结束
     }
2.1 C语言中的错误表现形式(错了吗？)
     一般来说，C语言中函数的错误表现形式如下：
     (1)对于返回值类型为int类型的函数来说，并且函数的计算结果不可能是负数时，使用返回-1表示出错，使用其他数据表示正常结束
     (2)对于返回值类型为int类型的函数来说，如果函数的计算结果可能是负数时，使用指针作为函数的参数将函数的计算结果带出去，而函数的返回值专门用于表示函数是否出错，习惯上使用-1表示出错，0表示正常结束
     (3)对于返回值类型为指针类型的函数来说，使用返回NULL表示函数出错，其他数据表示正常结束
     (4)如果不考虑函数是否出错，则返回值类型使用void即可
例子：
      按照上述要求，编写以下四个功能函数
      (1)要求返回1~10之间的随机数，如果随机数是5，则返回错误
      (2)比较两个int类型参数的大小，返回其中的最大值，如果两个参数相等，则返回错误
      (3)比较传入的字符串是否为"error"，如果是则返回错误，否则返回”ok“
      (4)打印传入的字符串即可
2.2 错误的编号（为什么错了？）
     errno本质就是一个int类型的全局变量，当函数调用出错时，会自动将错误的原因编号设置到errno中，因此可以通过errno的值来获取具体的错误原因
     #include <errno.h>
     该头文件中包含了errno全局变量的外部声明，以及常见的错误编号宏定义
     /etc/shadow - 存放了真实的密码信息，不过有加密
     /etc/passwd - 存放了当前系统的所有用户信息
文件的内容解析如下：
     tarena:  x:     1000   :  1000:
     用户名：密码：用户ID： 用户组ID
     tarena,,,:/home/tarena:  /bin/bash     
     注释信息 :    用户主目录    : shell的类型
作业：
     (1)查询函数strerror 和 perror的使用
     (2)编写两个功能函数，分别打印实心的菱形和空心的菱形，将这两个函数所在的.c文件分别打包成静态库和共享库进行调用，再练习一下共享库的动态加载
           *                        *
         ***                     * *
       *****                  *    *
         ***                     * *
           *                         *
明日预报：
     (1)C语言中的错误处理
     (2)环境表的概念和使用
     (3)内存管理技术
     
复习：
1.库文件的概念和使用
1.1 静态库的生成和调用步骤
(1)生成步骤
    a. vi add.c
    b. cc -c add.c
    c. ar -r libadd.a add.o
(2)调用步骤
    a. vi main.c
    b. cc -c main.c
    c. 链接的方式有三种：
        1) cc main.o libadd.a
        2) cc main.o -l add -L . 
        3) export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add
1.2 共享库的基本概念和特性
(1)基本概念
     共享库与静态库的最大不同之处：不会拷贝被调用的代码指令，而是将被调用代码指令在共享库中的相对地址拷贝到调用模块中
(2)基本特性
优点：
      a.共享库占用的空间比较小，可执行文件比较小
      b.修改和维护都比较方便
缺点：
      a.执行效率低
      b.不可以脱离共享库文件
1.3 共享库的生成和调用步骤
(1)生成步骤
    a. vi add.c
    b. cc -c -fpic add.c
    c.  cc -shared add.o -o libadd.so
(2)调用步骤
    a. vi main.c
    b. cc -c main.c
    c. 链接的方式有三种：
        1) cc main.o libadd.so
        2) cc main.o -l add -L . 
        3) export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add
注意：
    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.
1.4 共享库的动态加载
    #include <dlfcn.h>
     编译链接时需要指定 -ldl
    dlopen() - 打开/加载共享库文件
    dlsym() - 获取共享库中指定的函数地址
    dlclose() - 关闭/卸载共享库文件
    dlerror() - 获取具体的错误原因
2.C语言中的错误处理
2.1 C语言中的错误表现形式(错了吗？)
    (1)对于返回值类型为int类型的函数来说，并且函数的计算结果不可能是负数时，则返回-1代表错误，返回其他数据代表正常结束
    (2)对于返回值类型为int类型的函数来说，并且函数的计算结果可能是负数时，需要使用指针作为函数的参数将函数的计算结果带出去，而函数的返回值专门表示成功还是失败，使用-1表示错误，0表示成功
    (3)对于返回值类型为指针类型的函数来说，使用返回NULL表示错误
    (4)如果不考虑函数是否出错，则返回值类型给void
2.2 错误编号(为什么错了？)
     #include <errno.h>
     errno本质就是一个int类型的全局变量
     /etc/passwd - 包含了当前系统的用户信息
     /etc/shadow - 包含了系统中的真实密码信息
作业：
---------------------------------------------------------------------------
今天内容：
    (1)C语言中的错误处理
    (2)环境表的概念和使用
    (3)内存管理技术
1.C语言中的错误处理
1.1 错误信息
(1)strerror函数
     #include <string.h>
     char *strerror(int errnum);
函数功能：
     主要用于根据参数指定的错误编号翻译成对应的错误信息，通过返回值返回，当错误编号不合法时，返回“Unknown error nnn”
(2)perror函数(重点)
     #include <stdio.h>
     void perror(const char *s);
函数功能：
     主要用于向标准错误输出上打印最后一个错误信息，如果参数不为空时，则参数的内容原样输出，后面跟着一个冒号，一个空格，再跟着错误信息，并且最后自动换行
(3)printf函数(了解)
    printf("%m\n");  => 打印具体的错误信息
注意：
    判断函数是否出错需要根据函数的返回值进行判断，在明确函数已经出错的情况下，可以通过errno来获取具体的错误原因，但是不能直接使用errno来作为判断函数是否出错的依据，因为errno是个全局变量，errno的数值会随时发生改变，尤其在多线程编程中
2.环境表的概念和使用
2.1 基本概念
     环境表本质就是环境变量的集合，每个进程内部都拥有一张独立的环境表，用于记录和当前进程相关的环境变量信息
     环境表本质就是一个字符指针数组，并且以空指针作为字符指针数组的结尾标志，其中每个指针都是指向一个格式为"环境变量名=环境变量值"的字符串的首地址，而整个环境表的首地址记录在一个全局变量char** environ中，因此可以通过全局变量environ来获取整个环境表中的信息
2.2 基本操作
(1)getenv函数
     #include <stdlib.h>
     char *getenv(const char *name);
函数功能：
     主要用于获取参数指定的环境变量名所对应的环境变量值
，如果环境变量不存在，则返回NULL
(2)setenv函数
     #include <stdlib.h>
     int setenv(const char *name, const char 
*value, int overwrite);
第一个参数：环境变量名
第二个参数：环境变量值
第三个参数：是否修改的标志位
      非0 - 可以修改
        0 - 不可以修改
返回值：成功返回0，失败返回-1
函数功能：
      主要用于增加环境变量/修改环境变量的变量值，也就是如果环境变量不存在则增加，如果环境变量存在则是否修改取决于第三个参数
(3)unsetenv函数
    #include <stdlib.h>
    int unsetenv(const char *name);
函数功能：
      主要用于从环境表中删除参数指定的环境变量，如果该环境变量不存在，则函数的调用依然是成功的，环境表也不会发生改变
(4)putenv函数
     #include <stdlib.h>
     int putenv(char *string);
函数功能：
     主要用于增加环境变量/修改环境变量的值，参数的格式为：name=value，也就是说环境变量不存在则增加，存在则修改，成功返回0，失败返回非0
(5)clearenv函数
     #include <stdlib.h>
     int clearenv(void);
函数功能：
     主要用于清空整个环境表中所有的环境变量对，并且将全局变量environ也置为空指针，成功返回0，失败返回非0
2.3 main函数的原型
    int main(int argc,char* argv[],char* envp[])
第一个参数：记录命令行参数的个数
第二个参数：字符指针数组，用于记录每个命令行参数的地址
第三个参数：字符指针数组，用于记录当前进程的环境表信息
执行程序的方式为  a.out a.txt b.txt时：
      argc = 3;
      argv[0] = a.out
      argv[1] = a.txt
      argv[2] = b.txt
   
注意：
    由于历史的原因，main函数的第三个参数并不一定会被所有的系统支持，因此建议使用全局变量environ来访问环境表
实际案例：
     实现从文件argv[1]到文件argv[2]的拷贝
a.打开文件argv[1]和argv[2]
b.读取文件argv[1]中的内容写入到文件argv[2]中
c.关闭文件argv[1]和argv[2]        
     a.out a.txt b.txt     
  => 实现从a.txt到b.txt的拷贝
     a.out b.txt c.txt
  => 实现从b.txt到c.txt的拷贝
3.内存管理技术
3.1 程序和进程的基本概念
     程序 - 本质就是指存放在磁盘上的可执行文件
     进程 - 本质就是指运行在内存中的程序
     同一个程序可以同时启动多个进程
3.2 进程中的内存区域划分
如：
    int num;  // 全局变量   初始值是0    BSS段
    int main(void)
    {
         int num; // 局部变量  初始值是随机数   栈区
         return 0;
    }         
(1)代码区(Text)
    - 主要用于存放功能代码，函数指针指向该区域
(2)只读常量区(Text)
    - 主要用于存放字符串常量，const修饰的已经初始化的全
       局变量 和 静态局部变量
(3)全局区/数据区(Data)
    - 主要用于存放没有const修饰的已经初始化的全局变量和
       静态局部变量      
(4)BSS段(Data)
    - 主要用于存放没有const修饰的没有初始化的全局变量和
      静态局部变量
    - 该区域会在main函数执行之前执行自动清零的操作
(5)堆区(Heap)
    - 主要指使用malloc/calloc/realloc/free函数操作的
       内存区域
    - 该区域中的内存由程序员手动申请和手动释放
(6)栈区(Stack)
    - 主要用于存放局部变量(包括函数的形参),const修饰的
      局部变量以及块变量
    - 该区域中的内存由操作系统自动管理
综上所述：
     进程中的内存区域按照地址从小到大依次是：代码区、只读常量区、全局区、BSS段、堆区、栈区
     一般来说，堆区的内存地址按照从小到大依次分配，而栈区的内存地址按照从大到小依次进行分配
作业：
     根据图片以及程序来分析和理解进程中的内存区域划分
明日预报：
    (1)内存管理技术
     
    
       
复习：
1.C语言中的错误处理
     strerror() - 根据指定的错误编号翻译成对应的错误信息
     perror() - 打印错误信息
     printf("%m\n"); - 打印错误信息
2.环境表的概念和使用
2.1 基本概念
      环境表本质就是环境变量的集合，每个进程都拥有一张独立的环境表，用于记录属于当前进程的环境信息
      环境表本质是一个以NULL指针为结尾的字符指针数组，环境表的首地址记录在 全局变量 char** environ;
2.2 基本操作
     getenv() - 获取环境变量的值
     setenv() - 增加/修改环境变量
     unsetenv() - 删除环境变量
     putenv() - 增加/修改环境变量
     clearenv() - 清空整个环境表
2.3 main函数的原型
    int main(int argc,char* argv[],char* envp[])
3.内存管理技术
3.1 程序和进程的概念
     程序 - 存放在磁盘上的可执行文件
     进程 - 运行在内存中的程序
     程序可以同时启动多个进程
3.2 进程的内存区域划分
     内存地址从小到大：代码区、只读常量区、全局区/数据区、BSS段、堆区、栈区
作业：
----------------------------------------------------------------------------
今天内容：
     (1)内存管理技术
1.内存管理技术
1.1 存放常量字符串的不同形式之间的比较
如：
    char* pc = "hello";
    char ps[] = "hello";
      对于记录常量字符串的字符指针来说，指针的指向可以改变，但是指针指向的内容不可以改变；
      对于记录常量字符串的字符数组来说，数组名的指向不可以改变，但是数组名指向的内容可以改变；
      对于记录动态内存区域的指针来说，指针的指向和指针指向的内容都可以改变；
1.2 虚拟内存管理技术
    在Unix/linux系统中都采用虚拟内存管理技术对内存空间进行管理，即：每个进程都有0 ~ 4G-1的虚拟地址空间(虚拟的，并不是真实存在的)，由操作系统负责把虚拟地址和真实的物理内存地址映射起来，因此，不同进程中的地址空间看起来是一样的，但是所对应的物理内存却是不一样的
     其中0 ~ 3G-1之间的地址空间叫做用户空间，3G ~ 4G-1之间的地址空间叫做内核空间，绝大多数用户程序都运行在用户空间，内核空间只有内核才可以访问，当然内核也提供了相关的函数用于访问内核空间
     内存地址的基本单位是字节，但是内存映射的基本单位是内存页，目前主流的操作系统中一个内存页的大小是4Kb，也就是4096个字节
      ... ...
     1Pb = 1024Tb
     1Tb = 1024Gb
     1Gb = 1024Mb
     1Mb = 1024Kb
     1Kb = 1024byte(字节)
     1byte = 8 bit(二进制位)
1.3 段错误的由来
    (1)试图使用没有经过映射的虚拟地址时，可能引发段错误
    (2)试图对没有操作权限的内存空间进行操作时，可能引发段错误
1.4 使用malloc函数申请动态内存
(1)使用malloc函数申请的动态内存时的注意事项
     使用malloc函数申请动态内存时，malloc函数除了申请指定的内存空间之外，还可能申请额外的12个字节用于存储动态内存的管理信息，包括动态内存的大小，是否可用等信息，因此以后使用malloc函数申请的动态内存时，切记不要对动态内存进行越界访问，以避免对管理信息的破坏
(2)使用malloc函数申请动态内存的一般性原则
     一般来说，当使用malloc函数申请比较小块的动态内存时，操作系统会一次性映射33个内存页大小的存储空间，本质就是为了提高效率
    #include <unistd.h>
    #include <sys/types.h>
    getpid() - 主要用于获取当前进程的进程号
    
     cat  /proc/进程号/maps 
      - 表示查看指定进程的内存映射情况
具体的察看结果有六列：地址范围、操作权限、偏移量、设备
      编号、I节点的编号、具体的进程名称/内存区域名称
1.5 使用free函数释放动态内存
     一般来说，使用free函数释放动态内存时，释放多少则减去多少，当把所有动态内存全部释放完毕时，系统还会保留33个内存页，本质上还是为了提高效率
1.6 内存管理的相关函数
(1)getpagesize函数
     #include <unistd.h>
     int getpagesize(void);
函数功能：
     主要用于获取当前系统中一个内存页的大小，目前主流的操作系统都是4096个字节
(2)sbrk函数
     #include <unistd.h>
     void *sbrk(intptr_t increment);
函数的功能：
     主要用于根据参数指定的值来调整动态内存空间的大小
     当参数 > 0时：
          申请动态内存，成功返回申请到的内存空间的首地址
     当参数 = 0时：
          动态内存空间不变，成功返回当前动态内存的末尾地址
     当参数 < 0时：
          释放动态内存，成功返回释放之前的内存空间末尾地址
      函数调用失败时，返回(void*)-1
注意：
     使用sbrk函数申请内存比释放内存简单
     一般来说，使用sbrk函数申请比较小的内存时，操作系统会一次性映射1个内存页的大小，当申请的内存空间超过1个内存页时，系统会再次映射1个内存页的大小，当使用sbrk函数释放1个字节的内存时，系统可能会一次性释放1个内存页，当所有的动态内存被释放时，系统不会保留动态内存，因此相对于malloc函数来说更节省内存空间，但是效率没有malloc函数高
作业：
     查询并尝试使用brk函数
明日预报：
    (1)内存管理技术
    (2)文件管理
    
 
   
    
    
 
复习：
     ... ...
今天内容：
     (1)内存管理
     (2)文件管理
1.内存管理
1.1 内存管理的相关函数
(1)brk函数
     #include <unistd.h>
     int brk(void *addr);
函数功能：
     主要用于将动态内存的末尾地址调整到参数指定的位置，也就是根据具体的范围来调整动态内存的大小
     参数位置  > 末尾位置
         - 申请动态内存
     参数位置  = 末尾地址
         - 动态内存空间不变
     参数位置 < 末尾位置
         - 释放动态内存
注意：
     使用brk函数释放内存比申请内存方便，因此一般情况下和sbrk函数搭配使用，sbrk函数专门用于申请内存空间，brk函数专门用于释放内存空间
练习：
     使用sbrk函数和brk函数搭配使用，首先申请一个int类型的存储空间，存放数据66，在申请一个double类型的存储空间，存放数据3.14，最后申请10个字节的字符串空间，存放那个数据"hello"，打印以上内存空间中的数据，最后释放所有的内存空间
(2)mmap函数
     #include <sys/mman.h>
     void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
第一个参数：建立映射的起始地址，给NULL则由内核指定
第二个参数：映射的长度/大小
第三个参数：映射的权限
     PROT_EXEC - 可执行
     PROT_READ - 可读
     PROT_WRITE - 可写
     PROT_NONE - 不可访问
第四个参数：映射的标志
     MAP_SHARED - 共享的
     MAP_PRIVATE - 私有的
     MAP_ANONYMOUS - 映射到物理内存
第五个参数：文件描述符，暂时给0即可
第六个参数：文件中的偏移量，暂时给0即可
返回值：成功返回映射的首地址，失败返回MAP_FAILED
函数功能：
     主要用于建立文件/设备到内存中的映射
(3)munmap函数
     int munmap(void *addr, size_t length);
第一个参数：映射的起始地址，mmap函数的返回值
第二个参数：映射的长度/大小
函数功能：
      主要用于解除指定的映射关系
1.2 内存管理的层次关系
应用程序 - 业务逻辑
     |
STL标准模版库 - 使用容器和内存分配器，自动管理
     |
标准C++语言 - 使用运算符new申请，使用delete释放
     |
标准C语言  -  使用malloc函数申请,使用free函数释放
     |
POSIX标准  -  使用sbrk函数申请，使用brk函数释放 
     |
linux系统   - 使用mmap函数建立映射，munmap解除映射
                                                                          用户层
--------------------------------------------------------------------------
                                                                          内核层
操作系统内核 - vmalloc函数等
     |
... ...
2.文件管理
2.1 基本概念
     在linux系统中，几乎把所有的一切都统称为文件，包括目录和输入输出设备等等，因此对文件的绝大部分操作都适用于各种输入输出设备等
   
     /dev/null   -  空设备文件
如：
     echo hello
  => 终端中会输出 hello
     echo hello > a.txt
  => 将hello 写入到文件a.txt中
     echo hello > /dev/null
  => 丢弃命令的执行结果
     cat  /dev/null > a.txt
  => 表示清空文件中的内容
2.2 基本操作(重中之重)
复习标C中文件操作函数：
      fopen()/fclose()/fread()/fwrite()/fseek()
学习UC中文件操作函数：
      open()/close()/read()/write()/lseek()
(1)open函数
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    int open(const char *pathname, int flags);
    int open(const char *pathname, int flags, mode_t mode);
    int creat(const char *pathname, mode_t mode);
第一个参数：字符串形式的文件路径和文件名
第二个参数：文件的操作标志
      必须包含以下标志位中的一个
          O_RDONLY  -  只读
          O_WRONLY -  只写
          O_RDWR  -  可读可写
     还可以按位或以下的标志位：
          O_APPEND  -  以追加的方式打开文件
          O_CREAT  -  若文件不存在则创建，若存在则打开
          O_EXCL - 与O_CREAT搭配使用，若文件不存在则
                           创建，若文件存在则创建失败
          O_TRUNC - 若文件存在，则清空文件中的内容
第三个参数：文件的权限信息
      当创建一个新文件时，则需要该参数指定文件的权限信
      息，如：0664，当打开一个已经存在的文件时，不需要
      该参数，此时使用第一个open版本函数
返回值：成功返回文件描述符，失败返回-1
函数功能：
     主要用于打开/创建一个文件/设备
ls -l a.out的执行结果如下：
        -            rwx         rwx           r-x               1 
    文件的类型 属主权限 属组权限  其他用户权限  硬链接数
     tarena   tarena     7431        11月 20 14:43   a.out
    属主名称 属组名称  文件的大小 最后一次修改时间 文件名
其中的文件的类型主要有：
    -  表示普通规则文件
    d  表示目录文件
    ...
其中的权限信息主要有：
    r  表示可读   数字值为 4
    w 表示可写   数字值为 2
    x  表示可执行 数字值为1
    -  表示没有此权限  数字值为0
作业：
    查询文件基本操作的其他函数
明日预报：
    (1)文件的管理
复习：
1.文件管理
1.1 文件的基本操作
    open() - 打开/创建一个文件
    close() - 关闭文件
    read() - 读取文件中的内容
    write() - 向文件中写入数据
    lseek() - 调整文件的读写位置
1.2 标C和UC文件操作的比较
      标C的文件操作函数效率更高一些，因为函数内部提供了输入输出缓冲区，当数据积累到一定数量之后才会访问内核，才会写入数据到文件中
      使用time命令获取程序的执行时间
      UC文件操作可以通过自定义缓冲区的方式来提高效率，但不是缓冲区越大则效率越高
1.3 文件描述符的工作原理
作业：
--------------------------------------------------------------------------
今天内容：
     (1)文件的管理       
1.文件的管理
1.1 dup/dup2函数
     #include <unistd.h>
     int dup(int oldfd);
函数功能：
     主要用于对参数oldfd进行复制，成功返回新的文件描述符，失败返回-1
     #include  <unistd.h>
      int dup2(int oldfd, int newfd);
函数功能：
     主要用于实现从oldfd到newfd的复制，如果必要的话先强制关闭newfd再占用，成功返回新的描述符，失败返回-1
注意：
    使用dup/dup2函数复制文件描述符，本质就是复制文件描述符所对应的文件表地址，也就是让多个文件描述符同时对应同一个文件而已
1.2 fcntl函数
    #include <unistd.h>
    #include <fcntl.h>
    int fcntl(int fd, int cmd, ... /* arg */ );
第一个参数：文件描述符，open函数的返回值
第二个参数：操作的命令(执行一个什么样的操作)
     F_DUPFD - 实现复制文件描述符的功能，与dup2所不同
             的是，不会强制关闭占用的描述符，寻找>=第三个
             参数的描述符进行复制
    F_GETFD/F_SETFD - 获取/设置文件描述符的标志
    F_GETFL/F_SETFL - 获取/设置文件状态标志
    F_SETLK/F_SETLKW/F_GETLK - 实现文件锁的功能
第三个参数：可变长参数，是否需要取决于cmd
       实现文件锁的功能时，该参数是一个指向以下结构体的结构体指针，结构体类型如下：
struct flock 
{
     ...
     short l_type;/*锁的类型：F_RDLCK(读锁), F_WRLCK(写锁), F_UNLCK(解锁) */
     short l_whence;  /*锁定的起始位置:              SEEK_SET, SEEK_CUR, SEEK_END */
     off_t l_start;   /*针对起始位置的偏移量*/
     off_t l_len;     /*锁定的字节数*/
     pid_t l_pid;     /*加锁的进程号(F_GETLK使用)，否则默认给-1即可
};
返回值：
    F_DUPFD - 成功返回新的文件描述符，失败返回-1
    F_GETFD - 成功返回文件描述符的标志值，失败返回-1
    F_GETFL - 成功返回文件的状态值，失败返回-1
    其他命令成功返回0，失败返回-1
函数功能：
     (1)复制文件描述符(了解)
     (2)操作文件描述符标志(了解)
     (3)操作文件状态标志(了解)
     (4)实现建议锁/文件锁的功能(重点)
1.3 使用fcntl函数实现文件锁的功能
(1)文件锁的由来
     当有多个进程同时对同一个文件进行读写操作时，可能会产生数据的覆盖问题，也就是多个进程同时读文件可以进行，但是只要有一个进程在执行写操作，那么其他进程既不能读也不能写，为了实现上述效果，可以通过文件锁机制来实现
      文件锁本质就是一把读锁和一把写锁，其中读锁是一把共享锁，允许其他进程加读锁，不允许其他进程加写锁；而写锁是一把互斥锁，不允许其他进程加读锁和写锁(君子协定)
          
(2)F_SETLK作为函数的实参
      当锁的类型为F_RDLCK/F_WRLCK时，实现加锁功能
      当锁的类型为F_UNLCK时，实现解锁功能
练习：
     vi 04write.c文件，编程向文件b.txt中写入字符串内容"hello"，并且判断写入是否成功
总结：
     根据例子代码可知，给文件加完写锁之后还是可以向文件中写入数据内容的，结果说明文件锁是独立于文件的，也就是文件锁并不能控制对文件的读写操作，只能控制其他进程能否加锁成功，换句话说，如果给文件加了一把锁，可以导致第二次加锁失败(两个读锁除外)
  
思考：
    如果希望通过文件锁来控制对文件的读写操作,如何处理？
解决方案：
    为了实现上述效果，可以在每次进行读写操作之前尝试加读写锁，根据能否加上读写锁来决定能否进行读写操作，从而使得文件锁对文件的读写操作产生了约束
释放文件锁的方式：
     a.将锁的类型改为F_UNLCK，然后重新设置即可
     b.使用close函数关闭文件后，文件描述符对对应的文件
        上所有属于当前进程的文件锁都会释放
     c.进程结束，会自动释放所有该进程增加的文件锁
练习：
    vi 06unlock.c文件，首先对文件b.txt中的前10个字节加写锁，然后占用20秒之后开始解锁，解锁的方式为修改锁的类型，然后再占用20秒之后关闭文件，结束进程
(3)F_SETLKW作为函数的实参
      功能与F_SETLK类似，所不同的是如果当前锁加不上时，会进入阻塞状态一直等待，直到可以加上锁为止
(4)F_GETLK作为函数的实参
      如果第三个参数所描述的锁可以放置到文件上，则不去放置该锁，而是将锁的类型改为F_UNLCK，结构体中的其他成员保持不变；
      如果第三个参数所描述的锁不可以被放置到文件上，则使用文件上已经存在的锁信息去替换参数锁信息，并且将l_pid设置为真正给文件加锁的进程所对应的进程号；
 
1.4 access函数
      #include <unistd.h>
      int access(const char *pathname, int mode);
第一个参数：字符串形式的路径和文件名
第二个参数：操作模式
      F_OK  表示判断文件是否存在
      R_OK  表示判断文件是否可读
      W_OK  表示判断文件是否可写
      X_OK  表示判断文件是否可执行
函数功能：
     主要用于检查文件的存在性以及对应的权限信息      
作业：
     编写函数generator_id()实现生成递增帐号的功能
     a.out  100000   
     a.out  100001
     a.out  100002
     ... ...
明日预报：
    (1)文件管理
    (2)目录管理
    (3)进程管理
 
复习：
1.文件的管理
    dup/dup2函数  - 主要用于复制文件描述符
    fcntl函数 - 主要用于操作文件描述符
    access函数 - 主要用于判断文件是否存在以及拥有权限 
作业：
-----------------------------------------------------------------------------
今天内容：
     (1)文件的管理
     (2)目录的管理
     (3)进程的管理
1.文件的管理
1.1 常用的文件管理函数
(1)stat/fstat函数(重点)
     #include <sys/types.h>
     #include <sys/stat.h>
     #include <unistd.h>
     int stat(const char *path, struct stat* buf);
     int fstat(int fd, struct stat *buf);
第一个参数：文件的路径名/文件描述符
第二个参数：结构体指针
struct stat
{
      ...
      mode_t    st_mode;/*文件的类型和权限信息*/
      off_t     st_size;    /*文件的大小信息*/
      time_t    st_mtime;   /*文件的最后一次修改时间*/
      ...
      // 其中off_t本质就是long int类型
      // 其中time_t本质就是long int类型
};
函数功能：
     主要用于获取参数指定文件的状态信息
     #include <time.h>
     char *ctime(const time_t *timep);
  => 主要用于将整数类型的时间转换为字符串形式的时间
     struct tm *localtime(const time_t *timep);
  => 主要用于将整数类型的时间转换为结构体指针类型时间
     struct tm 
     {
         int tm_sec; /* 秒 */
         int tm_min;/* 分 */
         int tm_hour;/* 时 */
         int tm_mday;/* 日 */
         int tm_mon; /* 月 +1 */
         int tm_year; /* 年 +1900 */
         int tm_wday;/* 星期 */
         int tm_yday; /* 一年中的第几天 */
         int tm_isdst; /* 夏令时 了解 */
    };
扩展：
    获取一个文件大小的方法主要有三种：
        a.使用fseek函数将文件读写位置重置到末尾，使用
            ftell函数来获取文件的大小
        b.使用lseek函数将文件读写位置重置到末尾，通过返
            回值获取文件的大小
        c. 使用stat/fstat函数可以获取文件的大小
(2)chmod/fchmod函数
     #include <sys/stat.h>
      int  chmod(const  char  *path,  mode_t mode);
      int fchmod(int fd, mode_t mode);
第一个参数：文件的路径名/文件的描述符
第二个参数：文件的权限信息
函数功能：
      主要用于修改指定文件的权限信息
(3)truncate/ftruncate函数(重点)
     #include <unistd.h>
     #include <sys/types.h>
     int truncate(const char  *path,  off_t length);
     int ftruncate(int fd, off_t length);
第一个参数：文件的路径名/文件描述符
第二个参数：文件的最新长度
函数功能：
      主要用于修改文件的大小信息
注意：
      如果文件变小了，则多余的数据会被丢弃，如果文件变大了，则文件会被扩展，扩展出来的空间读取到的数据是'\0'
(4)umask函数(了解)
     #include <sys/types.h>
     #include <sys/stat.h>
     mode_t umask(mode_t mask);
函数功能：
     主要用于设置文件创建时的权限屏蔽字为：mask & 0777，通过返回值返回之前旧的权限屏蔽字
(5)又见mmap/munmap函数
     建立文件到虚拟内存地址之间的映射
  => 通过映射的机制可以将对文件的读写操作转换为对内存
        地址的读写操作，因此又多了一种访问文件的方式     
(6)其他功能函数
     link() - 主要用于创建硬链接
     unlink() - 主要用于删除硬链接
     rename() - 主要用于重命名
     remove() - 主要用于删除文件
     ... ... 
2.目录的管理
2.1 常用的管理函数
(1)opendir函数
     #include <sys/types.h>
     #include <dirent.h>
     DIR *opendir(const char *name);   
函数功能：
     主要用于打开参数指定的目录，成功返回目录的首地址，失败返回NULL
(2)readdir函数
     #include <dirent.h>
     struct dirent *readdir(DIR *dirp);
函数功能：
     主要用于读取参数指向的目录中的内容，成功返回目录指针，失败返回NULL，结构体的类型如下：
struct dirent
{
      ...
      unsigned char  d_type;/* 文件的类型 */
      char   d_name[256]; /* 文件名称 */
};
(3)closedir函数
     #include <sys/types.h>
     #include <dirent.h>
     int closedir(DIR *dirp);
函数功能：
     主要用于关闭参数指定的目录
练习：
     编程实现递归打印指定目录中的所有内容，要求子目录中的内容也要打印出来
2.2 其他目录管理函数
    mkdir() - 创建目录
    rmdir() - 删除目录
    chdir() - 切换目录
    getcwd() - 获取当前工作目录的绝对路径
    ... ...
3.进程的管理
3.1 基本概念和基本命令
(1)基本概念
     程序 - 存放在磁盘上的可执行文件
     进程 - 运行在内存中的程序
     同一个程序可以启动多个进程
(2)基本命令
     ps  -  查看当前终端启动的进程信息(进程的快照)
ps命令的执行结果如下：
     PID  -  进程的编号(重点)
     TTY  - 终端的次要装置号码(了解)
     TIME - 消耗CPU的时间(了解)
     CMD - 进程的名称(重点)
     ps -aux 表示显示所有包含其他使用者的进程信息
     ps -aux|more  表示分屏显示进程信息
ps -aux | more的执行结果如下(了解)：
     USER  -  用户名称
     PID - 进程号
     %CPU -  占用CPU的百分比
     %MEM  - 占用内存的百分比
     VSZ - 虚拟内存的大小
     RSS - 真实物理内存的大小
     TTY - 终端的次要装置号码     
     STAT - 进程的状态信息
     START - 进程的启动时间
     TIME - 消耗CPU的时间
     COMMAND -  进程的名称
进程的常见状态有(了解)：
     S  - 休眠状态，为了减轻CPU的压力
     s  -  进程的领导者，拥有子进程
     Z  -   僵尸进程(已经结束但是资源没有释放的进程)
     R  -  正在运行的进程
     O  -  可以运行的进程
     T  -   挂起的进程
     <  -  优先级比较高的进程
     N  -   优先级比较低的进程
     ...  ... 
    
     ps -ef  表示以全格式的方式显示所有进程信息
     ps -ef | more  表示以分屏方式显示进程信息
ps -ef | more的执行结果如下(了解):
      UID  -  用户的编号
      PID  -  进程的编号 
      PPID -  父进程的编号
      C  - 占用CPU的百分比
      STIME - 进程的启动时间
      TTY  - 终端的次要装置号码          
      TIME - 消耗CPU的时间
      CMD  - 进程的名称
  
      kill -9 进程号   表示杀死指定的进程 
  
      目前主流的操作系统支持多进程，在操作系统中，如果进程A启动了进程B，那么进程A就叫做进程B的父进程，进程B就叫做进程A的子进程
      操作系统中进程0(系统级的进程)负责启动进程1(init)和进程2，其他所有的进程都是直接/间接  由 进程1/进程2 启动的，所有的进程组成了树形结构
作业：
      查询和尝试使用文件和目录的其他管理函数
明日预报：
     (1)进程的管理
     (2)信号的处理
     
    
     
 
    
复习：
1.文件的管理
    stat()/fstat() - 主要用于获取文件的状态信息
    chmod()/fchmod() - 主要用于修改文件的权限信息
    truncate()/ftruncate() - 主要用于修改文件的大小
    umask()  -  主要用于设置文件创建时的权限屏蔽字
    mmap()/munmap() - 建立虚拟地址到文件的映射
    link()/unlink()/rename()/remove()/... ...
2.目录的管理
    opendir() - 打开目录
    readdir() - 读取目录中的内容
    closedir() - 关闭目录
    mkdir()/rmdir()/chdir()/getcwd()/ ... ...   
  
3.进程的管理
3.1 基本概念和基本命令
     ps  -  查看当前终端所启动的进程  PID   CMD
     ps -aux  -  显示所有包含其他使用者的进程信息
     ps -ef  -  以全格式的方式显示进程信息
     kill -9 进程号  表示杀死指定的进程
     目前主流的操作系统都支持多进程，如果进程A启动了进程B，则进程A叫做进程B的父进程，进程B叫做进程A的子进程
     进程0(系统级进程)负责启动了进程1(init)和进程2，其他所有的进程都是直接/间接 由 进程1/进程2 启动的，最终组成了树形结构   
-----------------------------------------------------------------------------
今天内容：
     (1)进程的管理
     (2)信号的处理
1.进程的管理
1.1 各种ID的获取
    #include <sys/types.h>
    #include <unistd.h>
    getpid()  -  获取当前进程的进程编号，返回pid_t
    getppid()  -  获取当前进程父进程的进程编号,返回pid_t
    getuid()  -  获取当前用户的编号，返回uid_t
    getgid()  -  获取当前用户所在用户组的编号，返回gid_t
注意：
    PID - 进程的编号，操作系统通过该编号唯一标识指定的进程，但是进程号的分配采用延迟重用的策略，在任意时刻都保证了进程号的唯一性
    pid_t本质就是int类型，进程号都是非负整数
    uid_t本质就是unsigned int类型
    gid_t本质就是unsigned int类型
      
1.2 进程的创建
(1)fork函数
     #include <unistd.h>
     pid_t fork(void);
函数功能：
     主要用于通过复制当前正在调用进程的方式来创建子进程，调用成功时父进程返回子进程的进程号，子进程返回0，调用失败时父进程返回-1，没有子进程存在
注意：
     使用fork函数创建子进程后，父子进程之间的执行顺序取决于操作系统的调度算法
(2)父子进程的代码执行方式
    a.对于fork函数之前的代码，由父进程执行一次；
    b.对于fork函数之后的代码，由父子进程各自执行一次；
    c.fork函数的返回值 由父子进程各自返回一次，父进程返
       回子进程的进程号，子进程返回0，因此可以通过函数的
       返回值来区分父子进程
(3)父子进程之间的关系
    a.父进程启动了子进程，父子进程同时执行，如果子进程先结束，子进程会给父进程发信号，父进程负责回收子进程的资源；
    b.如果父进程先结束，则子进程会变成孤儿进程，子进程会变更父进程(重新设定父进程,init进程)，init进程因为收养孤儿进程，因此被称为孤儿院；
    c.如果子进程先结束，但是父进程由于各种原因没有收到子进程发来的信号，则不会负责回收其资源，那么子进程就会变成僵尸进程；
(4)父子进程之间内存资源的关系
     对于fork函数创建的子进程来说，子进程会复制父进程中除了代码区之外的其他内存区域，而代码区和父进程共享
(5)扩展
    a.如何使用fork函数创建4个进程？？？
          fork();
          fork();
      4个进程：1个父进程 + 2个子进程 + 1个孙子进程
   b. 如何使用fork函数创建3个进程？？？
          pid = fork();
          if(0 != pid)
         {
                fork();
         }    
      3个进程：1个父进程  +  2个子进程
   c. 俗称"fork炸弹"
        while(1)
        {
              fork();
        }
1.3 进程的终止
(1)正常终止进程的方式
    a.执行到了main函数的return 0；
    b.调用exit()函数
    c.调用_exit()/_Exit()函数
    d.最后一个线程返回
    e.最后一个线程调用pthread_exit()函数
(2)非正常终止进程的方式
    a.采用信号来终止进程，如：ctrl+c
    b.最后一个线程被其他线程调用pthread_cancel函数取消
(3)终止进程相关函数的解析
    #include <unistd.h>
    void _exit(int status);   => UC函数
    #include <stdlib.h>
    void _Exit(int status);   => 标C函数
函数功能：
     主要用于立即终止当前正在调用的进程，自动关闭所有属于该进程的文件描述符，让该进程的所有子进程变更父进程为init进程，该进程也会其父进程发送SIGCHILD信号来回收该进程的资源
     参数值会被返回给当前进程的父进程作为当前进程的退出状态信息，父进程若要收集退出状态信息，则需要调用wait系列函数来处理
     #include <stdlib.h>
     void exit(int status);
函数功能：
      主要用于引起正在调用进程的终止，参数status & 0377之后的结果会被返回给父进程作为当前进程的退出状态信息
      在终止进程之前会自动调用所有由atexit()和on_exit()函数注册过的函数
      
      #include <stdlib.h>
      int atexit(void (*function)(void));
函数功能：
      主要用于注册参数指定的功能函数，注册过的函数会在进程正常终止时调用，而进程正常终止的方式为：调用exit()函数和从main函数中返回
      该函数调用成功时返回0，失败返回非0
1.4 进程的等待
(1)wait函数
     #include <sys/types.h>
     #include <sys/wait.h>
     pid_t wait(int *status);
函数功能：
     主要用于挂起当前正在调用的进程，直到该进程的一个子进程终止为止
     当参数不为空时，就将获取到的进程退出状态信息存放到参数status所指向的存储空间中，为了解析该退出状态信息，需要使用以下的带参宏：
     WIFEXITED(*status) - 如果进程正常终止则返回真，所谓正常终止就是指：调用exit()/_exit()/从main函数中返回
     WEXITSTATUS(*status) - 获取子进程的退出状态信息
     成功返回终止子进程的进程号，失败返回-1
(2)waitpid函数
     #include <sys/types.h>
     #include <sys/wait.h>
     pid_t waitpid(pid_t pid, int  *status,int options);
第一个参数：进程的编号
    <-1 等待进程组ID为pid绝对值的任意一个子进程(了解)
     -1  等待任意一个子进程(重点)
     0   等待和正在调用进程在同一个进程组的任意子进程
          (了解)
    >0  等待进程号为pid的子进程(重点)
第二个参数：指针作为函数的参数，获取进程的退出状态
第三个参数：等待的方式，默认给0，表示等不到会阻塞
    WNOHANG - 没有子进程终止时立即返回，不会阻塞
返回值：成功返回终止子进程的进程号，失败返回-1
函数功能：
      主要用于等待指定的进程状态发生改变
注意：
      The call wait(&status) is equivalent to:
      waitpid(-1, &status, 0);
1.5 进程的其他管理函数
(1)vfork函数
     #include <sys/types.h>
     #include <unistd.h>
     pid_t vfork(void);
函数功能：
     与fork函数类似，都是创建当前正在调用进程的子进程，有关创建的详细信息、返回值以及常见的错误信息请参考fork函数即可
     与fork函数不同之处在于，不会复制父进程中的内存区域，而是直接占用，导致父进程会被挂起直到子进程终止，或者子进程调用exec系列函数为止，所以vfork函数保证了子进程先于父进程执行
      使用vfork函数创建的子进程终止时只能调用_exit函数，而不能从当前函数返回 或者 调用exit函数
(2)exec系列函数
    #include <unistd.h> 
    int execl(const char *path, const char*arg, ...);
第一个参数：字符串形式的路径名
第二个参数：字符串形式的参数，一般指定可执行文件名
第三个参数：可变长参数，是否需要取决于前两个参数
函数功能：
      主要用于执行指定的文件
如：
    使用execl函数执行ls -l 命令时的用法如下：
        execl("/bin/ls","ls","-l",NULL);
注意：
       vfork函数本身没有太大的实际意义，一般需要与exec系列函数搭配使用，这样可以使得父子进程去执行完全不同的代码段
       fork函数也可以和exec系列函数搭配使用，但是效率相对比较低，因此一般情况下很少这样使用
(3)system函数
     #include <stdlib.h>
     int system(const char *command);
函数功能：
     主要用于执行参数指定的shell命令，但是在实际项目开发中可能更多地被用于执行shell脚本和可执行文件
2.中断的概念和分类
      中断就是指暂停执行当前正在执行的程序转而执行其他程序或者处理意外情况的过程
      中断分为：硬件中断  和 软件中断
3.信号的处理
3.1 基本概念和特点
(1)基本概念
      信号本质就是一种软件中断,它既可以作为进程间通信的一种方式，又可以中断一个正常运行的进程，它更多地被用于处理意外情况
(2)基本特点
    a.信号是异步的，也就是进程并不知道信号何时会到达;
    b.进程既可以处理信号，也可以发送信号给指定的进程;
    c.每个信号都有一个名字，并且用SIG开头;
3.2 信号的基本命令和分类
      kill -l  表示查看当前系统所支持的所有信号
      一般来说，在linux系统中支持的信号范围是：1 ~ 64，不保证信号是连续的，而unix系统与linux系统有所不同，一般支持的范围是 1 ~ 48;
      在linux系统中，其中 1 ~ 31之间的信号叫做不可靠信号，不支持排队，信号随时可能会丢失，也叫做非实时信号；
      其中34 ~ 64之间的信号叫做可靠信号，支持排队，信号不会丢失，也叫做实时信号；
要求掌握的信号：
      SIGINT    2   使用ctrl+c产生该信号   进程终止
      SIGQUIT  3   使用ctrl+\产生该信号   进程终止
      SIGKILL   9   使用kill -9产生该信号   进程终止
作业：
      查询signal函数并且尝试使用
明日预报：
      (1)信号的处理
   
   
 
复习：
1.进程的管理
1.1 各种ID的获取
      getpid() - 获取当前进程的进程号
      getppid() - 获取当前进程的父进程进程号
      getuid() - 获取用户的编号
      getgid() - 获取用户组的编号
      pid_t 本质就是 int 类型， 系统采用延迟重用
1.2 进程的创建
     fork() - 复制当前进程的方式来创建子进程
     
     子进程会复制父进程中除了代码区之外的其他内存区域，而代码区和父进程共享
     
     fork();
     fork();
     pid = fork();
     if(0 != pid)
     {
          fork();
     }
   
    while(1) {  fork();}
1.3 进程的终止
(1)正常终止进程的方式
     a.执行了main函数中的return
     b.调用exit()函数
     c.调用_exit()/_Exit()函数
     d.最后一个线程返回
     e.最后一个线程调用了pthread_exit()函数
(2)非正常终止进程的方式
     a.使用信号终止进程
     b.最后一个线程被其他线程调用pthread_cancel()函数
1.4 进程的等待
     wait() - 等待任意一个子进程结束
     waitpid() - 等待指定的子进程结束    
1.5 进程的其他管理函数
     vfork() - 创建子进程
     execl() - 执行指定的文件
     system() - 执行指定的shell命令
2.信号的处理
2.1 基本概念和特性
    信号本质就是一种软中断，它既可以作为进程间通信的机制，又可以终止一个正在执行的进程，更多地被用于处理意外情况
2.2 基本概念和分类
    在linux系统中支持的信号是 1 ~ 64，不保证连续，其中 1 ~ 31之间的信号叫做不可靠信息，不支持排队，信号可能会丢失，也叫做非实时信号；其中34 ~ 64之间的信号叫做可靠信号，支持排队，信号不会丢失，也叫做实时信号    
     kill -l
掌握的信号：
     SIGINT   2   ctrl+c    默认处理方式为终止进程
     SIGQUIT  3  ctrl+\    终止进程
     SIGKILL   9  kill -9    终止进程
作业：
     查询和解析signal函数
----------------------------------------------------------------------------
今天内容：
     (1)信号的处理
1.信号的处理
1.1 信号的处理方式
(1)默认处理，绝大多数信号的处理方式为终止进程
(2)忽略处理
(3)自定义处理  
注意：
     其中信号SIGKILL只能采用默认处理方式
     每个用户只能处理属于该用户的信号，只能给该用户的进程发送信号，其中root用户可以给几乎所有进程发信号
     #include <signal.h>
     typedef void (*sighandler_t)(int);
     sighandler_t     signal(int    signum,
          sighandler_t handler);
函数原型解析：
     typedef void (*sighandler_t)(int);
 =>  typedef void (*)(int)  sighandler_t;
 =>  typedef void (*p)(int)  sighandler_t;
     sighandler_t     signal(int    signum,
          sighandler_t handler);
 => void (*)(int)  signal(int    signum,
           void (*)(int) handler);
 =>  void (*)(int)  signal(int    signum,
           void (*handler)(int) );
 =>  void (*signal(int    signum,
           void (*handler)(int)) )(int);
 =>  signal首先是一个函数
        具有两个参数：一个是int类型，一个是函数指针类型
        函数的返回值类型也是函数指针类型
 =>  函数指针是一个 指向 int类型参数 void类型返回值的 
            函数的 指针
函数功能解析：
     第一个参数：信号的名称/信号值(处理哪个信号)
     第二个参数：函数指针类型
          SIG_IGN - 忽略处理
          SIG_DFL - 默认处理
          自定义函数地址 - 自定义处理
    返回值：成功返回之前的处理方式，失败返回SIG_ERR
    函数功能：
          主要用于设置信号的处理方式
练习：
    编程打印进程号，设置对信号SIGINT进行自定义处理，对信号SIGQUIT进行忽略处理，设置完毕之后使用fork函数创建子进程，打印子进程的进程号后进入无限循环，父进程直接结束，在另一个终端中采用kill命令发送信号进行测试
总结：
     (1)对于fork函数创建的子进程来说，完全照搬父进程对信号的处理方式，也就是父进程自定义，子进程自定义；父进程默认，子进程也默认；父进程忽略，子进程也忽略处理；
     (2)对于vfork函数和execl函数启动的进程来说，父进程默认，子进程也默认；父进程忽略，子进程也忽略；父进程自定义处理，子进程采用默认处理；
1.2 信号的发送方式
(1)采用键盘方式发送(只能发送部分特殊的信号)
      SIGINT   2   采用ctrl+c来发送
      ... ...
(2)采用程序出错方式发送(只能发送部分特殊的信号)
      段错误  本质就是SIGSEGV信号   11
      ... ...
(3)使用kill命令发送信号(可以发送所有信号)
      kill -信号值 进程号
   => 表示给指定的进程发送指定的信号
(4)采用系统函数发送信号(重点)
      kill()/raise()/alarm()/sigqueue()
1.3 发送信号的系统函数解析
(1)kill函数
    #include <sys/types.h>
    #include <signal.h>
    int kill(pid_t pid, int sig);
第一个参数：进程号(给谁发信号)
    >0 表示发送信号到进程号为pid的进程(重点)
      0 表示发送信号给和当前进程在同一个进程组的每个进程
          (了解)
     -1 表示发送信号给当前进程可以发送的每个进程，除了进
           程init(了解)
   <-1 表示发送信号给进程组ID为-pid的每个进程(了解)
第二个参数：信号值/信号名称(发送什么样的信号)
     0 表示不会发送信号，而是判断进程/进程组是否存在
函数功能：
     主要用于给指定的进程发送指定的信号
(2)raise函数
     #include <signal.h>
     int raise(int sig);
函数功能：
     主要用于给当前正在调用的进程/线程发送参数指定的信号，对于单线程的进程来说，等价于kill(getpid(),sig)
     成功返回0，失败返回非0
     #include <unistd.h>
     unsigned int sleep(unsigned int seconds);
函数功能：
     主要用于按照参数指定的秒数进行睡眠，直到参数指定的秒数到了或者被一个不能忽略的信号打断，如果睡够了则返回值为0，如果没有睡够则返回还没有来得及睡的秒数(也就是剩余的秒数)
(3)alarm函数
     #include <unistd.h>
     unsigned int alarm(unsigned int seconds);
函数功能：
     主要用于在经过参数指定的秒数之后发送SIGALRM信号给当前正在调用的进程
     每次设置新闹钟之后会取消之前的闹钟，参数为0时不会设置新闹钟，专门用于取消闹钟
    成功返回之前闹钟剩余的秒数，如果之前没有闹钟则返回0
(4)sigqueue函数
     等到讲完sigaction函数之后回来再讲
1.4 信号集的基本概念和操作
(1)基本概念
     信号集本质就是由若干个信号组成的集合，当前系统支持的信号范围是 1 ~ 64，不保证连续
分析：
     采用最节省内存方式描述信号集，数据类型该如何设计？
     char str[64];     需要64个字节
     采用每一个二进制位代表一个信号，则需要64个二进制位，那么也就是8个字节，类型为：long long int;
总结：
     信号集的数据类型是sigset_t类型，大小是128个字节，但是底层采用每一个二进制位来代表一个信号;
typedef struct
{
     unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
typedef __sigset_t sigset_t;
(2)基本操作
     #include <signal.h>
     sigemptyset() - 清空信号集//成功0失败-1
     sigfillset() - 填满信号集//成功0失败-1
     sigaddset() - 增加指定的信号到信号集中//成功0失败-1
     sigdelset() - 删除信号集中指定的信号//成功0失败-1
     sigismember() - 判断指定的信号是否存在
	 //返回1：说明指定的信号存在,
	 //返回0：说明指定的信号不存在
	 //返回-1：说明出错
1.5 信号的屏蔽
(1)sigprocmask函数
     #include <signal.h>
     int   sigprocmask(int    how,    const sigset_t *set, sigset_t *oldset);
第一个参数：屏蔽方式
      SIG_BLOCK - ABC  CDE => ABCDE(原+新)
      SIG_UNBLOCK - ABC  CDE => AB(原-新)
      SIG_SETMASK - ABC  CDE => CDE(新替换原，重点)
第二个参数：屏蔽的信号集
第三个参数：获取之前的屏蔽集
函数功能：
      主要用于获取/修改屏蔽的信号集
(2)sigpending函数
     #include <signal.h>
     int sigpending(sigset_t *set);
函数功能：
     主要用于获取在信号屏蔽期间来过但没有处理的信号，将这些来过的信号设置到参数指定的信号集中
1.6 sigaction函数
    => signal函数的增强版
    #include <signal.h>
     int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);
第一个参数：信号名称/信号值
      可以选择任何一个有效信号，除了SIGKILL和SIGSTOP
第二个参数：设置针对上述信号的处理方式
struct sigaction 
{
   void (*sa_handler)(int);
=> 函数指针，主要用于设置信号的处理方式
=> SIG_DFL，SIG_IGN，自定义函数的地址
   void (*sa_sigaction)(int, siginfo_t *, void *);
=> 函数指针类型，用于设置信号的处理方式，是否选用该成
     员，取决于sa_flags;
   sigset_t   sa_mask;
=> 主要用于设置在执行信号处理函数期间屏蔽的信号集
=> 默认屏蔽与触发信号处理函数相同的信号
   
   int sa_flags;
=> SA_SIGINFO  使用第二个函数指针来设置信号处理方式 
=> SA_NODEFER 解除对触发信号处理函数相同信号的屏蔽
=> SA_RESETHAND 一旦信号处理函数调用后恢复信号的
      默认处理方式(也就是自定义处理一次)
   void     (*sa_restorer)(void);
=> 函数指针类型，保留成员，暂时不使用
};     
第三个参数：用于获取之前的处理方式
函数功能：
     主要用于检查/修改指定信号的处理方式
其中结构体中的第二个成员的第二个形参类型如下：
struct siginfo_t
{
     ...
     pid_t    si_pid;      /* 发送信号的进程号 */
     sigval_t si_value;    /* 发送信号伴随的附加数据 */
     ... 
};
作业：
     查询和理解sigaction和sigqueue函数
明日预报：
     (1)信号的处理
     (2)进程间的通信
   
 
复习：
1.信号的处理
1.1 信号的处理方式
(1)默认处理，绝大多数信号的默认处理方式都是终止进程
(2)忽略处理
(3)自定义处理
     signal() - 设置对信号的处理方式
父子进程对信号处理方式的比较
    (1)对于fork函数创建的子进程来说，完全照搬父进程对信号的处理方式；
    (2)对于vfork函数和execl函数创建的子进程来说，父进程默认，子进程也默认；父进程忽略，子进程也忽略；父进程自定义，子进程默认处理；
1.2 发送信号的主要方式
(1)采用键盘发送(只能发送部分特殊的信号)
(2)采用程序出错发送(只能发送部分特殊的信号)
(3)使用kill命令   
     kill -信号值 进程号
(4)采用系统函数发送信号
     kill()/raise()/alarm()/sigqueue()
1.3 信号集的概念和操作
     信号集本质就是若干个信号组成的集合
     数据类型：sigset_t类型， 128个字节，采用每一个二进制位来代表一个信号
     sigemptyset() - 清空信号集
     sigfillset() - 填满信号集
     sigaddset() - 添加指定信号到信号集
     sigdelset() - 删除指定的信号
     sigismember() - 判断信号是否存在于信号集中
1.4 信号的屏蔽
     sigprocmask() - 设置/检查/修改屏蔽的信号集
     sigpending() - 获取信号屏蔽期间来过的信号     
1.5 sigaction函数
     是signal函数的增强版，设置对信号的处理方式
--------------------------------------------------------------------------
今天内容：
     (1)信号的处理
     (2)进程间通信的方式
1.信号的处理
1.1 sigaction函数
     #include <signal.h>
     int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);
第一个参数：信号名称/信号值
      可以选择任何一个有效信号，除了SIGKILL和SIGSTOP
第二个参数：设置针对上述信号的处理方式
struct sigaction 
{
   void (*sa_handler)(int);
=> 函数指针，主要用于设置信号的处理方式
=> SIG_DFL，SIG_IGN，自定义函数的地址
   void (*sa_sigaction)(int, siginfo_t *, void *);
=> 函数指针类型，用于设置信号的处理方式，是否选用该成
     员，取决于sa_flags;
   sigset_t   sa_mask;
=> 主要用于设置在执行信号处理函数期间屏蔽的信号集
=> 默认屏蔽与触发信号处理函数相同的信号
   
   int sa_flags;
=> SA_SIGINFO  使用第二个函数指针来设置信号处理方式 
=> SA_NODEFER 解除对触发信号处理函数相同信号的屏蔽
=> SA_RESETHAND 一旦信号处理函数调用后恢复信号的
      默认处理方式(也就是自定义处理一次)
   void     (*sa_restorer)(void);
=> 函数指针类型，保留成员，暂时不使用
};     
第三个参数：用于获取之前的处理方式
函数功能：
     主要用于检查/修改指定信号的处理方式
其中结构体中的第二个成员的第二个形参类型如下：
struct siginfo_t
{
     ...
     pid_t    si_pid;      /* 发送信号的进程号 */
     sigval_t si_value;    /* 发送信号伴随的附加数据 */
     ... 
};
1.2 sigqueue函数
    #include <signal.h>
     int sigqueue(pid_t pid, int sig, const union sigval value);
第一个参数：进程的编号(给哪个进程发信号)
第二个参数：信号值/信号名称(发送什么样的信号)
第三个参数：发送信号时伴随的附加数据
     union sigval 
     {
          int   sival_int;
          void *sival_ptr;
     };
函数功能：
      主要用于发送信号和附加数据到指定的进程中
1.3 计时器
     在linux系统中，系统会为每一个进程维护3种计时器：真实计时器、虚拟计时器、以及实用计时器，其中一般使用真实计时器更多一些；
     #include <sys/time.h>
     int getitimer(int which, struct itimerval *curr_value);
     int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);
第一个参数：计时器的类型(哪一种)
     ITIMER_REAL - 通过统计进程消耗的真实时间来传递SIGALRM信号进行工作的(重点)
     ITIMER_VIRTUAL - 通过统计进程消耗的用户态时间来传递SIGVTALRM信号进行工作的(了解)
     ITIMER_PROF - 通过统计进程消耗的用户态时间和内核态时间的总和来传递SIGPROF信号进行工作的(了解)
第二个参数：结构体指针，用于设置计时器的新值
struct itimerval 
{
     struct timeval it_interval; /* 间隔时间 */
     struct timeval it_value;    /*  启动时间 */
};
struct timeval 
{
     long tv_sec;  /* 秒  = 10^6 微秒*/
     long tv_usec;/* 微秒  */
};
    
第三个参数：结构体指针，用于返回计算器之前的旧值
函数功能：
     主要用于获取/设置计时器的参数值
2.进程间的通信方式
2.1 基本概念
    两个/多个进程之间的数据交互叫做进程间的通信
2.2 通信方式
    (1)文件
    (2)信号
    (3)管道
    (4)共享内存
    (5)消息队列(重点)
    (6)信号量集
    (7)网络(重点)
     ... ...
    其中(4)(5)(6)统称为 XSI IPC通信方式
     (X/open System Interface Inter-Process Communication)
3.使用管道实现进程间的通信
3.1 基本概念
     使用管道通信本质上还是以文件作为通信的媒介，只不过管道是一种比较特殊的文件而已
     管道分为两种：有名管道  和 无名管道
     有名管道：可以用于任意两个进程之间的通信
     无名管道 : 主要用于父子进程之间的通信
3.2 使用有名管道实现进程间的通信
     使用mkfifo命令/函数可以创建有名管道文件
如：
     mkfifo  a.pipe
  => 创建有名管道a.pipe文件
     touch  a.txt
  => 创建普通文件a.txt
     echo  hello  > a.txt
  => 将字符串hello写入到文件a.txt，可以写入的
     echo  hello  > a.pipe
  => 将字符串hello写入文件a.pipe，不可以写入的
     再开另外一个终端，写入以下指令：
     cat  a.pipe
  => 读取管道文件中的内容，此时数据hell可以读取成功
       对面的写入数据也会解除阻塞
     #include <sys/types.h>
     #include <sys/stat.h>
     int mkfifo(const char *pathname, mode_t mode);
 => 主要用于创建一个有名管道文件，权限由第二个参数指定
3.3 使用无名管道实现进程间的通信
    #include <unistd.h>
    int pipe(int pipefd[2]);
函数功能：
    主要用于创建无名管道文件，可以提供进程间通信的一种单向数据通道，通过参数可以返回两个文件描述符，其中pipefd[0]表示读端，pipefd[1]表示写端
注意：
     管道文件的特殊性就在于只是用于作为数据通信的桥梁，但是管道文件自身并不会存放任何数据
     使用管道实现进程间的通信是属于比较古老的方式，以后很少使用
4.使用共享内存实现进程间的通信
4.1 基本概念
      所谓共享内存本质就是一块由系统内核指定并维护的内存区域，该区域可以共享在多个进程之间，因此多个进程可以通过该共享内存作为媒介来实现进程间的通信
4.2 通信模型
(1)获取key值，使用ftok函数
(2)创建/获取共享内存，使用shmget函数
(3)挂接共享内存，使用shmat函数
(4)使用共享内存
(5)脱接共享内存，使用shmdt函数
(6)如果不再使用则删除共享内存，使用shmctl函数
4.3 相关函数的解析
(1)ftok函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     key_t  ftok(const  char *pathname, int proj_id);
第一个参数：字符串形式的路径名
      要求必须关联一个存在并且可以访问的文件
第二个参数：项目的编号，要求非0，取低八位二进制
返回值：成功返回key_t类型的key值，失败返回-1
函数功能：
      主要用于根据路径名和项目编号来生成key值
注意：
      使用相同的路径名和相同的项目编号，最终生成的key值也相同
(2)shmget函数
     #include <sys/ipc.h>
     #include <sys/shm.h>
     int shmget(key_t key, size_t size, int shmflg);
第一个参数：key值，ftok函数的返回值
第二个参数：共享内存的大小，
       如果获取已经存在的共享内存，则实参传0即可
第三个参数：共享内存的操作标志
       IPC_CREAT - 创建
       IPC_EXCL - 与IPC_CREAT搭配使用，如果共享内存已
                          经存在，则创建失败
       0 - 获取一个已经存在的共享内存
返回值：成功返回共享内存的ID，失败返回-1
函数功能：
      主要用于创建/获取一块共享内存
注意：
      使用shmget函数创建新的共享内存时，需要使用低位二进制来指定共享内存的权限信息，如按位或 0664
(3)shmat函数
     #include <sys/types.h>
     #include <sys/shm.h>
      void *shmat(int shmid, const void *shmaddr, int shmflg);
第一个参数：共享内存的ID，shmget函数的返回值
第二个参数：共享内存的地址，给NULL由系统指定
第三个参数：共享内存的操作标志，默认给0即可
返回值：成功返回挂接共享内存的地址，失败返回(void*)-1
函数功能：
     主要用于挂接共享内存到当前进程中
(4)shmdt函数
     #include <sys/types.h>
     #include <sys/shm.h>
     int shmdt(const void *shmaddr);
函数功能：
     主要用于脱接当前进程中的共享内存，参数为shmat函数的返回值
(5)shmctl函数
     #include <sys/ipc.h>
     #include <sys/shm.h>
     int shmctl(int shmid, int cmd, struct shmid_ds *buf);
第一个参数：共享内存的ID，shmget函数的返回值
第二个参数：具体的操作命令
     IPC_RMID - 删除共享内存，此时第三个参数给NULL即可
第三个参数：结构体指针
函数功能：
      主要用于对指定的共享内存进行控制
4.4 相关的基本命令
     ipcs  -m  表示查看当前系统中的所有共享内存
     ipcrm  -m  共享内存的ID  表示删除指定的共享内存
5.使用消息队列实现进程间的通信
5.1 基本概念
    本质上就是将数据打包成消息，然后将消息放到消息队列中，让多个进程访问同一个消息队列，从而实现进程间的通信
5.2 基本模型
(1)获取key值，使用ftok函数
(2)创建/获取消息队列，使用msgget函数
(3)发送/接收消息队列中的消息，使用msgsnd/msgrcv函数
(4)如果不再使用消息队列则删除，使用msgctl函数
5.3 相关函数的解析
(1)msgget函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgget(key_t key, int msgflg);
第一个参数：key值，ftok函数的返回值
第二个参数：操作标志
      IPC_CREAT  -  创建
      IPC_EXCL  -  与IPC_CREAT搭配使用，若存在创建失败
       0  -  获取一个已经存在的消息队列
返回值：成功返回消息队列的ID，失败返回-1
函数功能：
      主要用于创建/获取一个消息队列
注意：
     当创建新的消息队列时，需要在第二个参数中指定权限信息，如按位或 0664等
(2)msgsnd函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：消息的首地址，消息的一般格式如下：
struct msgbuf 
{
    long mtype;      /* 消息的类型, must be > 0 */
    char mtext[1];  /* 消息的内容，可以是其他结构*/
};
第三个参数：消息的大小
     用于指定消息内容的大小，不包括消息的类型
第四个参数：消息的发送标志，默认给0即可
     IPC_NOWAIT  -  不会产生阻塞现象
函数功能：
      主要用于将指定的消息发送到指定的消息队列中
作业：
     查询剩余的两个功能函数
明日预报：
     (1)使用消息队列实现进程间的通信
     (2)使用信号量集实现进程的通信
     (3)综合小项目：模拟ATM的功能
 
 
复习：
1.信号的处理
    sigaction() -  主要用于设置信号的处理方式
    sigqueue() - 主要用于发送信号和附加数据到指定进程
    setitimer()/getitimer() - 设置/获取计时器的相关信息
2.进程间通信的方式
   (1)文件
   (2)信号
   (3)管道
   (4)共享内存
   (5)消息队列(重点)
   (6)信号量集
   (7)网络(重点)
   ...
   其中(4)(5)(6)统称为 XSI IPC通信方式
   
3.使用管道实现进程间的通信
3.1 基本概念
     使用管道通信本质还是以文件作为通信的媒介，只不过该文件比较特殊，文件本身不会存放任何数据
     管道分为：有名管道  和 无名管道
3.2 使用有名管道实现进程间的通信
     mkfifo  xxx.pipe
     echo hello > xxx.pipe
     cat xxx.pipe
     mkfifo() - 创建有名管道
3.3 使用无名管道实现进程间的通信
     pipe() - 主要用于创建无名管道，返回两个描述符
4.使用共享内存实现进程间的通信
(1)获取key值，使用ftok函数
(2)创建/获取共享内存，使用shmget函数
(3)挂接共享内存，使用shmat函数
(4)使用共享内存
(5)脱接共享内存，使用shmdt函数
(6)如果不再使用，则删除共享内存，使用shmctl函数
ipcs -m   查看系统中的共享内存
ipcrm -m 共享内存的ID  表示删除指定的共享内存
5.使用消息队列实现进程间的通信
(1)获取key值，使用ftok函数
(2)创建/获取消息队列，使用msgget函数
(3)发送/接受消息，使用msgsnd/msgrcv函数
(4)如果不再使用，则删除消息队列，使用msgctl函数
----------------------------------------------------------------------------
今天内容：
    (1)使用消息队列实现进程间的通信
    (2)使用信号量集实现进程间的通信
    (3)综合小项目：银行账户管理系统
1.使用消息队列实现进程间的通信
1.1 相关函数的解析
(1)msgget函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgget(key_t key, int msgflg);
第一个参数：key值，ftok函数的返回值
第二个参数：操作标志
      IPC_CREAT  -  创建
      IPC_EXCL  -  与IPC_CREAT搭配使用，若存在创建失败
       0  -  获取一个已经存在的消息队列
返回值：成功返回消息队列的ID，失败返回-1
函数功能：
      主要用于创建/获取一个消息队列
注意：
     当创建新的消息队列时，需要在第二个参数中指定权限信息，如按位或 0664等
(2)msgsnd函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：消息的首地址，消息的一般格式如下：
struct msgbuf 
{
    long mtype;      /* 消息的类型, must be > 0 */
    char mtext[1];  /* 消息的内容，可以是其他结构*/
};
第三个参数：消息的大小
     用于指定消息内容的大小，不包括消息的类型
第四个参数：消息的发送标志，默认给0即可
     IPC_NOWAIT  -  不会产生阻塞现象
函数功能：
      主要用于将指定的消息发送到指定的消息队列中
(3)msgrcv函数
    #include <sys/types.h>
    #include <sys/ipc.h>
    #include <sys/msg.h>
    ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：存放消息的首地址
第三个参数：消息的大小，不包括消息的类型
第四个参数：消息的类型
    0  - 表示始终读取消息队列中的第一个消息
  >0  - 表示始终读取消息队列中第一个类型为msgtyp的消息
  <0  - 表示始终读取消息类型<=msgtyp绝对值的消息，其
           中最小的类型优先读取
第五个参数：接受消息的方式，默认给0，产生阻塞现象
返回值：成功返回实际接收的数据大小，失败返回-1
函数功能：
      主要用于从指定的消息队列中接收消息
(4)msgctl函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgctl(int msqid, int cmd, struct msqid_ds *buf);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：具体的操作命令
      IPC_RMID  - 删除消息队列，第三个参数给NULL即可
第三个参数：结构体指针
函数功能：
     主要用于操作指定的消息队列
1.2 基本命令
    ipcs  -q  表示查看系统中存在的消息队列
    ipcrm  -q  消息队列的ID   表示删除指定的消息队列
2.使用信号量集实现进程间的通信
2.1 基本概念
(1)什么是信号量？
      信号量本质就是一种计数器，用于控制同时访问同一个共享资源的进程个数/线程个数
(2)什么是信号量集？
      信号量集本质就是信号量的集合，也就是由若干个信号量组成的集合，主要用于控制多种共享资源各自同时被访问的进程/线程个数
(3)信号量的工作方式
    a.将信号量初始化为最大值；
    b.如果有进程申请到资源，则信号量的值减1；
    c.当信号量的值变为0时，申请资源的进程进入阻塞状态；
    d.如果有进程释放资源，则信号量的值加1；
    e.当信号量的值 > 0时，阻塞的进程继续抢占资源；
2.2 使用信号量集通信的基本模型
(1)获取key值，使用ftok函数
(2)创建/获取信号量集，使用semget函数
(3)初始化信号量集，使用semctl函数
(4)操作信号量集，使用semop函数
(5)如果不再使用，则删除信号量集，使用semctl函数
2.3 相关函数的解析
(1)semget函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semget(key_t key, int  nsems,  int semflg);
第一个参数：key值，ftok函数的返回值
第二个参数：信号量集的大小(信号量的个数)
       0  -  获取已经存在的信号量集
第三个参数：操作的标志
      IPC_CREAT  -  创建
      IPC_EXCL  - 与IPC_CREAT搭配使用，存在则创建失败
       0  -  获取已经存在的信号量集
返回值：成功返回信号量集的ID，失败返回-1
函数功能：
      主要用于创建/获取信号量集
注意：
     当创建新的信号量集时需要指定权限，如：0664等
(2)semctl函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semctl(int semid, int semnum, int cmd, ...);
第一个参数：信号量集的ID，semget函数的返回值
第二个参数：信号量集的下标(一般从0开始)
第三个参数：具体的操作命令
      IPC_RMID  -  删除信号量集，此时忽略第二个参数，不
                           需要第四个参数
      SETVAL  -  使用函数的第四个参数给信号量集中下标为
                        semnum的信号量进行初始化
第四个参数：可变长参数，是否需要取决于cmd
函数功能：
      主要用于控制指定的信号量集，具体功能取决于cmd
(3)semop函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semop(int semid, struct sembuf *sops, unsigned nsops);
第一个参数：信号量集的ID，semget函数的返回值
第二个参数：结构体指针，可以指向结构体变量，也可以指向
          结构体数组的首地址，结构体类型如下：
struct sembuf
{
    unsigned short sem_num;  /* 信号量的下标 */
    short  sem_op;   /* 信号量的操作 
         正数表示增加  0表示不变   负数表示减少  */
    short  sem_flg;  /* 操作标志，默认给0即可*/
};
第三个参数：结构体指针指向的结构体个数
函数功能：
      主要用于对指定的信号量执行指定的操作
2.4 基本命令
     ipcs  -s  表示查看当前系统中的信号量集
     ipcs  -a  表示查看当前系统中所有的IPC对象，包括共享内存，消息队列以及信号量集
     ipcrm  -s  信号量集的ID   表示删除指定的信号量集
3.综合小项目
3.1 项目名称
     银行账户管理系统(模拟ATM的功能)
3.2 项目功能
     开户、销户、存款、取款、查询、转帐、退出
3.3 项目架构
     采用C(Client)/S(Server)架构进行项目的架构  
客户端：
     提供界面让用户选择具体的业务，将用户的选择交给服务器进行处理，等待服务器的处理结果，并且显示给用户；
服务器：
    接受客户端发来的业务功能，通过访问数据库的方式进行处理，再将最终的处理结果交给客户端；
3.4 项目的详细设计
(1)客户端和服务器之间如何通信？？
     提供两个消息队列来实现通信
          消息队列一： 客户端  =>  服务器
          消息队列二： 服务器  =>  客户端
(2)不同的业务之间如何区分？？
     提供8种不同的消息类型
           6种不同的业务类型  + 成功  +  失败
(3)账户的数据类型和消息的数据类型应该如何设计？？
     采用结构体类型
     账户的信息：帐号、账户名称、密码、余额
     消息的信息：消息的类型   +   消息的内容(账户信息)
(4)以开户为例分析一下项目的执行流程
客户端：
    a.提供字符界面由用户选择具体的业务编号；
       => 使用printf打印界面即可
    b.根据用户的选择进入不同的分支处理；
       => 采用switch-case多分支结构
    c.提示用户输入用户名、密码以及余额信息；
       => 使用scanf函数进行读取即可
    d.将用户提供的信息和业务编号打包成完整的消息，
        发送到消息队列一中；
       => 打包消息的结构体变量，使用msgsnd发送即可
    e.等待服务器的处理结果，接收消息队列二中的消息；
       => 使用msgrcv函数进行接收，根据接收到的消息类型
             判断成功或失败，将结果打印出来
服务器：        
    a.创建两个消息队列；
      => 使用msgget函数
    b.接收消息队列一中的消息，并且判断消息的类型
      => 使用msgrcv函数，判断消息类型是否为开户的类型
    c.自动生成帐号，补充完整开户的用户信息，写入文件
       => 调用generator_id函数，使用write函数写入
       => 将每个用户信息保存在每个独立的文件中
       => 使用账户作为文件名确保唯一性，使用sprintf函数 
   d.根据用户信息写入是否成功，来修改对应的消息类型
       => 开户成功可以修改消息类型为7，否则修改为8
   e.将处理结果打包成完整的消息，发送到消息队列二中；
       => 使用msgsnd函数进行发送
   f.服务器应该24小时启动，除非手动去关闭；
       => 使用while(1)无限循环
       => 使用ctrl+c来关闭服务器，销毁两个消息队列
3.5 项目的要求
     (1)要求采用多文件的结构进行编程，而在每个文件中采用多个函数各自封装独立功能的方式进行编程；
     (2)要求实现开户的功能即可，有余力的同学考虑其他功能
3.6 项目的提示
     vi bank.h  -  定义用户信息和消息的数据类型
     vi client.c  -  编写打印字符界面的功能函数 ....
     vi server.c  -  编写创建消息队列的功能函数  ...
     vi dao.c  -  编写自动生成帐号的功能函数 ...
     ....
     最后支持Makfile文件
     
     
今天内容：
     (1)网络的基本常识
     (2)基于socket的一对一通信模型
     (3)基于tcp协议的通信模型
1.网络的基本常识
如：
    目前比较主流的网络通讯软件：QQ  微信  MSN  阿里旺旺 飞信 ... ...    
1.1 七层网络模型 和 常用的协议
(1)七层网络模型
     ISO将网络协议从逻辑上划分为7层，来保障数据传递过程中的可靠性、安全性等，具体的7层网络模型如下：
应用层 - 主要为应用程序的通信服务的，将数据交给应用程序
表示层 - 主要将数据按照统一的格式进行封装和打包等
会话层 - 对话，主要用于控制会话何时开始、何时结束等
传输层 - 主要对数据进行错误检查和重新排序等
网络层 - 主要用于选择具体的网络协议进行数据的传递
数据链路层 - 主要用于将打包好的数据转换为高低电平信号
物理层 - 主要指具体的交换机设备等
(2)常用的协议
    TCP - 传输控制协议，面向连接，该协议提供可靠的全双
               工的子节流
    UDP - 用户数据报协议，非面向连接，没有tcp协议可靠但
               是速度比较快
    IP  -  互联网协议，是上述两种协议的底层协议
1.2 IP地址 和 子网掩码的概念
(1)IP地址的概念和分类
     IP地址本质就是在互联网中的唯一地址标识，其数据类型为32位二进制组成的整数(ipv4)，当然也有128位二进制组成的整数(ipv6)
     日常生活中描述IP地址的主要形式为: 点分十进制表示法，也就是将每8位二进制转换为一个十进制整数，不同的十进制整数之间通过小数点分隔；
如：
     0x01020304  =>  1.2.3.4
查看IP地址的方式:
     windows系统中： ipconfig    ipconfig/all
     linux系统中： ifconfig    /sbin/ifconfig
     IP地址主要分为两部分：  网络地址  +  主机地址，根据网络地址和主机地址的划分，将IP地址分为以下4类：
     A类：0 + 7位网络地址 +  24位主机/本地地址
     B类：10 + 14位网络地址 + 16位主机/本地地址
     C类：110 + 21位网络地址 + 8位主机/本地地址
     D类：1110 + 28位多播地址
(2)子网掩码的概念
     子网掩码本质就是用于帮助IP划分具体的网络地址和主机地址，也可以用于判断两个IP地址是否在同一个局域网中，具体的划分方法为：按位&运算进行
如：
    IP地址：172.30.100.41
 子网掩码：255.255.255.0   &
-----------------------------------------------
                172.30.100   -  网络地址 
                             41   -  主机地址
练习：
     判断以下两个IP地址是否在同一个局域网中？？？
     166.111.160.1   和  166.111.161.45
      子网掩码全部为：255.255.254.0
解析：
     IP地址：166.111.160.1 
  子网掩码：255.255.254.0   &
-----------------------------------------------
                166.111.160   -  网络地址
    IP地址：166.111.161.45
 子网掩码：255.255.254.0   &
-----------------------------------------------
                166.111.160   -  网络地址
综上所述：
     上述两个IP地址在同一个局域网中
1.3 端口号和字节序的概念
(1)端口号
     IP地址 - 互联网中的地址标识，通过该地址可以定位主机
     端口号 - 主要用于定位某一台主机上的具体进程
     端口号的数据类型是：unsigned short类型，范围是：0 ~ 65535，其中0 ~ 1024之间的端口由系统占用，因此编程指定端口号时，建议从1025开始使用
     网络编程中需要提供：IP地址  +  端口号
(2)字节序的概念
小端系统：低位内存地址存放低位数据的系统
大端系统：低位内存地址存放高位数据的系统
如：
     对于十六进制的数据 0x12345678来说
小端系统中按照地址从小到大依次：0x78 0x56 0x34 0x12
大端系统中按照地址从小到大依次：0x12 0x34 0x56 0x78
一般性原则：
     对于多字节整数来说，为了避免不同的操作系统中存放字节序的不同而造成的数据不一致性问题，习惯上将所有发送出去的多字节整数先转换为网络字节序再发送，而将所有从网络上收到的多字节整数先转换为主机字节序再解析，而网络字节序本质就是大端系统的字节序
2.基于Socket的一对一通信模型
2.1 基本概念
    Socket  -  本意为插座的意思，表示逻辑上的通信载体
2.2 基本模型
服务器：
    (1)创建socket，使用socket函数
    (2)准备通信地址，使用结构体变量
    (3)绑定socket和	通信地址，使用bind函数
    (4)进行通信，使用read/write函数
    (5)关闭socket，使用close函数
客户端：
    (1)创建socket，使用socket函数
    (2)准备通信地址，是服务器的地址
    (3)连接socket和通信地址，使用connect函数
    (4)进行通信，使用read/write函数
    (5)关闭socket，使用close函数
2.3 相关函数的解析
(1)socket函数
     #include <sys/types.h>
     #include <sys/socket.h>
     int  socket(int  domain, int type, int protocol);
第一个参数：协议族/域，决定本地通信还是网络通信
     AF_UNIX/AF_LOCAL  -  实现本地通信
     AF_INET  -  实现基于ipv4网络协议的通信
     AF_INET6  -  实现基于ipv6网络协议的通信
第二个参数：通信的类型，决定具体的通信协议
     SOCK_STREAM  -  提供有序的、可靠的、双向的面向连
            接的字节流通信，本质就是基于tcp协议的通信模式
     SOCK_DGRAM  -  提供不可靠的，非面向连接的数据报
            通信，本质就是基于udp协议的通信模式
第三个参数：特殊的协议，直接给0即可
返回值：成功返回socket的描述符，失败返回-1
函数功能：
      主要用于创建端点来实现进程间的通信
(2)通信地址的结构体类型
a.通用的通信地址
   struct sockaddr 
   {
        sa_family_t sa_family;
        char        sa_data[14];
   };
   该结构体主要用于函数的形参类型，很少定义结构体变量
b.实现本地通信的通信地址
   #include <sys/un.h>
   struct sockaddr_un
   {
         sa_family_t  sun_family;//地址族，相当socket函数
                   中的第一个参数
         char  sun_path[];//socket文件的路径名
   };
   该结构体专门用于准备本地通信的通信地址
c.实现网络通信的通信地址
   #include <netinet/in.h>
   struct sockaddr_in
   {
        sa_family_t  sin_family; //地址族 AF_INET
        in_port_t       sin_port ;// 端口号
        struct in_addr  sin_addr;// ip地址
   };
   struct in_addr
   {
        in_addr_t  s_addr; 
   };
   该结构体专门用于准备网络通信的通信地址
(3)bind函数
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>
    int bind(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：通信地址的首地址，需要类型转换
第三个参数：通信地址的大小，使用sizeof计算即可
函数功能：
      主要用于socket和通信地址
(4)connect函数
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>
     int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
函数功能：
     主要用于连接socket和通信地址，参数和返回值参考bind函数即可
(5)字节序的转换函数
     #include <arpa/inet.h>
     uint32_t htonl(uint32_t hostlong);
 => 主要用于将32位的主机字节序转换为网络字节序
     uint16_t htons(uint16_t hostshort);
 => 主要用于将16位的主机字节序转换为网络字节序
     uint32_t ntohl(uint32_t netlong);
 => 主要用于将32位的网络字节序转换为主机字节序
     uint16_t ntohs(uint16_t netshort);
 => 主要用于将16位的网络字节序转换为主机字节序
(6)IP地址的转换函数
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    in_addr_t inet_addr(const char *cp);
 => 主要用于将字符串形式的IP地址转换为整数类型
    char *inet_ntoa(struct in_addr in);
 => 主要用于将结构体类型的IP地址转换为字符串类型
作业：
     练习和理解基于socket的通信模型
明日预报：
     (1)基于tcp的网络通信模型
     (2)tcp和udp协议的区别
     (3)基于udp的网络通信模型
 
复习：
1.网络的基本常识
1.1 七层网络模型和常用的网络协议
     七层网络模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
     TCP  -  传输控制协议，面向连接的协议，提供可靠的全双工的字节流通信
     UDP  -  用户数据报协议，非面向连接，没有tcp可靠但是传输速度比较快
     IP   -  互联网协议，上述协议的底层协议
1.2 IP地址和子网掩码
    IP地址本质就是互联网中的唯一地址标识，是32位二进制组成的整数(ipv4)，还有128位二进制组成的整数(ipv6)
    日常生活中，采用点分十进制表示法描述IP地址
    IP地址分为:  网络地址  +  主机地址
    子网掩码 -  主要用于划分IP地址的网络地址和主机地址
         IP地址 &  子网掩码
1.3 端口号和字节序
    IP地址 -  定位具体的某一台主机
    端口号 - 定位具体主机中的某一个进程
   端口号的数据类型是：unsigned short类型，范围是：0 ~ 65535，其中0 ~ 1024被系统占用
小端系统：将低位数据存放在低位内存地址的系统
大端系统：将地位数据存放在高位内存地址的系统
2.基于socket的一对一通信模型
服务器：
      (1)创建socket，使用socket函数
      (2)准备通信地址，使用结构体类型
      (3)绑定socket和通信地址，使用bind函数
      (4)进行通信，使用read/write函数
      (5)关闭socket，使用close函数
客户端：
      (1)创建socket，使用socket函数
      (2)准备通信地址，使用服务器的地址
      (3)连接socket和通信地址，使用connect函数
      (4)进行通信，使用read/write函数
      (5)关闭socket，使用close函数
-----------------------------------------------------------------------------
今天内容：
     (1)基于tcp协议的网络通信模型
     (2)tcp协议和udp协议的比较
     (3)基于udp协议的网络通信模型
1.基于tcp协议的网络通信模型(重点)
1.1 通信模型
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)监听，使用listen函数
     (5)响应客户端的连接请求，使用accept函数
     (6)进行通信，使用read/write函数
     (7)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用服务器的地址
     (3)连接socket和通信地址，使用connect函数
     (4)进行通信，使用read/write函数
     (5)关闭socket，使用close函数
1.2 相关函数的解析
(1)listen函数
    #include <sys/types.h>          /* See NOTES */
    #include <sys/socket.h>
    int listen(int sockfd, int backlog);
第一个参数：socket描述符，socket函数的返回值
第二个参数：指定等待连接队列的最大长度
        (允许在该socket上等待被连接的最大个数)
函数功能：
     主要用于将第一个参数指定的socket标记为被动的socket，也就是该socket专门用于使用accept函数去响应即将到来的连接请求，不再作为通信使用
(2)accept函数
     #include <sys/types.h> 
     #include <sys/socket.h>
     int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：结构体指针，用于存放客户端的通信地址
第三个参数：通信地址的大小
返回值：成功返回用于通信的socket的描述符，失败返回-1
函数功能：
      主要用于响应等待被处理队列中的第一个连接请求
注意：
      socket函数返回的描述符 主要用于监听和响应
      accept函数返回的描述符 主要用于通信的
练习：
     使用tcp协议的编程模型实现一对多的通信
a.要求服务器可以不断地响应客户端的连接请求；
b.要求服务器可以同时和多个客户端进行通信；
c.要求针对每一个客户端可以进行不断地通信；
d.要求当客户端发来"bye"时，表示客户端下线，终止对应
    的子进程；
e.要求使用信号2来关闭服务器；
f. 要求客户端发送的消息由用户手动输入；
2.tcp协议和udp协议的比较
2.1 tcp协议的概念和特性
    tcp - 传输控制协议，是一种面向连接的协议，类似打电话
         建立连接   =>  进行通信   =>  断开连接
         在通信的整个过程中全程需要保持连接
优点和缺点：      
     (1)保证了数据传输的可靠性和有序性，也就是当数据接受
方没有反馈确认信息时，数据发送方会重新发送数据，并且对发送的数据进行编号，接受方可以根据编号进行排序
     (2)属于全双工的字节流通信方式
     (3)数据的接受方可以控制数据发送方的流量大小
     (4)服务器的压力比较大，资源的占用率比较高，发送的速度也会比较慢；
    
2.2 udp协议的概念和特性
    udp - 用户数据报协议，非面向连接的协议，类似发短信
    在通信的整个过程中不需要全程保持连接
优点和缺点：
    (1)服务器端的压力比较小，资源的占用率比较低，发送的速度比较快；
    (2)不能保证数据的可靠性和有序性，数据报也会丢失；
    (3)属于全双工的数据报通信方式
    (4)数据的接受方不能控制数据发送方的流量大小
3.基于udp协议的通信模型(重点)
3.1 通信模型
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)进行通信，使用sendto/recvfrom函数 
     (5)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用服务器的地址
     (3)进行通信，使用sendto/recvfrom函数 
     (4)关闭socket，使用close函数
3.2 相关函数的解析
(1)sendto函数
    #include <sys/types.h>
    #include <sys/socket.h>
     ssize_t send(int sockfd, const void *buf, size_t len, int flags);
     ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：被发送数据的首地址
第三个参数：被发送数据的大小
第四个参数：发送的标志，默认给0表示产生阻塞
第五个参数：数据接受方的通信地址
第六个参数：数据接受方通信地址的大小
返回值：成功返回实际发送的数据大小，失败返回-1
函数功能：
      主要用于将指定的消息发送到指定的地址上
(2)recvfrom函数
     #include <sys/types.h>
     #include <sys/socket.h>
     ssize_t recv(int sockfd, void *buf, size_t len, int flags);
     ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);
第一个参数：socket描述符，socket函数的返回值
第二个参数：存放接受到数据的缓冲区首地址
第三个参数：接受的数据大小
第四个参数：接受的标志，默认给0即可
第五个参数：保存数据发送方的通信地址(来电显示)
第六个参数：通信地址的大小
返回值：成功返回实际接受的数据大小，失败返回-1
函数功能：
      主要用于接受指定的数据并提供来电显示的功能
注意：
     在vi的命令模式下，执行命令：
           :n1,n2 >  表示将n1行到n2行之间的代码向右缩进
           :n1,n2 <  表示将n1行到n2行之间的代码向左缩进
           :n1,n2  co  n3  表示将n1行到n2行之间的代码拷贝
                            到n3行的下面
           :n1,n2  mo  n3  表示将n1行到n2行之间的代码剪切
                            到n3行的下面
     虽然read/write函数也可以实现接受和发送消息，但是在以后的网络编程中要求优先使用send/recv/sendto/recvfrom函数，尽量不去使用read/write函数
作业：
     使用udp协议的通信模型编程实现一个时间服务器，也就是只要服务器收到客户端发来的消息，则将当前服务器的系统时间发送给该客户端
明日预报：
    (1)多线程的编程
         
复习：
1.基于tcp协议的通信模型(重点)
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)监听，使用listen函数
     (5)响应客户端的连接请求，使用accept函数
     (6)进行通信，使用send/recv函数
     (7)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用服务器的地址
     (3)连接，使用connect函数
     (4)进行通信，使用send/recv函数
     (5)关闭socket，使用close函数
2.基于udp协议的通信模型(重点)
服务器：
     (1)创建socket，使用socket函数
     (2)准备通信地址，使用结构体类型
     (3)绑定socket和通信地址，使用bind函数
     (4)进行通信，使用recvfrom/sendto/recv/send函数
     (5)关闭socket，使用close函数
客户端：
     (1)创建socket，使用socket函数
     (2)准备通信地址，服务器的地址
     (3)进行通信，使用sendto/recvfrom/send/recv函数
     (4)关闭socket，使用close函数
作业：   
-----------------------------------------------------------------------------
今天内容：
     (1)多线程的编程
     (2)综合小项目
1.多线程的编程
1.1 基本概念
      线程本质就是进程内部的程序流，隶属于进程，目前主流的操作系统都支持多进程，而在每一个进程的内部又可以支持多线程，从而实现并行处理的效果
      进程是重量级的，每个进程都需要独立的内存空间，新建进程对资源的消耗是比较大的；而线程是轻量级的，共享所在进程的内存资源，但是每个线程都有一个独立的栈区；
1.2 线程的创建
(1)pthread_create函数
     #include <pthread.h>
     int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);
第一个参数：整数指针，用于存放新线程的线程编号
第二个参数：线程的属性，给NULL选择默认的属性
第三个参数：函数指针类型，新线程的处理函数
第四个参数：作为第三个参数指向函数的实参
返回值：成功返回0，失败返回具体的错误编号
函数功能：
      主要用于在当前正在调用的进程中启动新线程，让新线程去执行第三个参数指向的函数，函数执行完毕后，线程结束
注意：
       Compile and link with -pthread.
(2)多线程执行的关系
     执行main函数的线程  叫做  主线程
     使用pthread_create函数创建出来的新线程 叫做 子线程
     多线程创建完毕之后各自独立运行，执行的先后次序取决于操作系统，多线程之间相互独立也会相互影响，因为主线程结束时main函数结束，而main函数结束表示整个进程结束，一旦整个进程结束，则整个进程内部的所有线程结束
(3)pthread_self函数
     #include <pthread.h>
     pthread_t pthread_self(void);
函数功能：
     主要用于获取当前正在调用线程的编号，通过返回值返回
     Compile and link with -pthread.
练习：
     使用malloc函数申请4个字节的动态内存，提示用户输入一个半径存放到动态内存中，使用pthread_create函数创建子线程，在线程处理函数中计算圆形的周长和面积并且打印出来，等待子线程结束后，释放动态内存
1.3 线程的汇合和分离
(1)pthread_join函数
     #include <pthread.h>
     int pthread_join(pthread_t thread, void **retval);
第一个参数：线程的编号(等待哪一个线程)
第二个参数：该参数不为空时，将目标线程的退出状态信息拷
       贝到*retval指向的位置中
返回值：成功返回0，失败返回错误编号
函数功能：
      主要用于等待参数一指向的线程终止，并且获取终止的退出状态信息，同时回收该线程的所有资源，当然前提是thread指向的线程可以被等待
      Compile and link with -pthread.
练习：
     使用pthread_create函数创建子线程，在子线程中计算1 ~ 100之间的和并存放在sum变量中，要求将最终的计算结果返回给主线程，主线程通过pthread_join函数进行接受并打印出来
(2)pthread_detach函数
     #include <pthread.h>
     int pthread_detach(pthread_t thread);
函数功能：
     主要用于将参数指定的线程设置为分离状态，一个分离状态的线程终止时，它的资源会被自动地释放给系统不需要其他线程的帮助/等待/加入，其他线程调用pthread_join也无法等待
     Compile and link with -pthread
1.4 线程的终止和取消
(1)pthread_exit函数
    #include <pthread.h>
    void pthread_exit(void *retval);
函数功能：
     主要用于终止当前正在调用的线程，该函数的参数作为当前终止线程的退出状态信息，在同一个进程中的其他线程可以通过pthread_join来获取该参数值
     Compile and link with -pthread.
(2)pthread_cancel函数
     #include <pthread.h>
     int pthread_cancel(pthread_t thread);
函数功能：
//给thread线程发送终止信号
     主要用于给参数指定的线程发送取消的请求，是否取消以及何时取消取决于线程的属性信息:state  和  type
     Compile and link with -pthread.
     #include <pthread.h>
     int pthread_setcancelstate(int state, int *oldstate);
第一个参数：设置新的取消状态
     PTHREAD_CANCEL_ENABLE - 表示可以被取消(默认)
     PTHREAD_CANCEL_DISABLE - 表示不可以被取消
第二个参数：用于带出旧的取消状态，给NULL表示不获取
     int pthread_setcanceltype(int type, int *oldtype);
第一个参数：设置新的取消类型
     PTHREAD_CANCEL_DEFERRED - 延迟取消(默认)
     PTHREAD_CANCEL_ASYNCHRONOUS - 立即取消
第二个参数：用于带出旧的取消类型，给NULL表示不获取
     Compile and link with -pthread.
2.线程的同步问题
2.1 基本概念
    当一个进程中有多个线程时，多线程之间共享所在进程的资源，如果多个线程同时访问同一个共享资源时，需要相互协调，以防止数据出现不一致和不完整的问题，线程之间的协调和通信叫做线程的同步问题
2.2 实现线程同步的具体方案
     让多个线程依次串行访问共享资源即可
2.3 使用互斥量/互斥锁实现线程的同步
(1)定义互斥量
     pthread_mutex_t  mutex;
(2)初始化互斥量
     pthread_mutex_init(&mutex,NULL);
(3)使用互斥量进行加锁
     pthread_mutex_lock(&mutex);
(4)使用共享资源
(5)使用互斥量进行解锁
     pthread_mutex_unlock(&mutex);
(6)如果不再使用，销毁互斥量
     pthread_mutex_destroy(&mutex);     
2.4 使用信号量实现线程的同步问题
(1)基本概念
     信号量本质就是一个计数器，主要用于控制同时访问共享资源的进程/线程个数
     当信号量的值为1时，效果等同于互斥量；
(2)使用流程
    #include <semaphore.h>
    a.定义信号量
       sem_t sem;
    b.初始化信号量
       sem_init(&sem,0,最大的初始值);
    c.获取一个信号量(信号量的值减1)
       sem_wait(&sem);
    d.使用共享资源
    e.释放一个信号量(信号量的值加1)
       sem_post(&sem);
    f.如果不再使用，删除信号量
       sem_destroy(&sem);
3.综合小项目
     采用C/S架构通过tcp通信模型和多线程实现聊天室
服务器：
     (1)要求服务器可以不断地响应客户端的连接请求
          => 使用while(1)无限循环
          => 将每一个连接上来的客户端通信地址和对应的描述
                 符保存起来，采用数组/链表都可以
     (2)要求服务器可以同时和多个客户端通信
          => 使用多线程的技术来实现
     (3)要求服务器针对每一个客户端可以不断地通信
          => 使用while(1)无限循环
     (4)要求客户端发来"bye"时，表示客户端已下线
          => 进行字符串比较，终止对应的线程pthread_exit
          => 从数组/链表中删除已经下线的客户端信息
     (5)要求服务器可以将接受到的消息转发给其他所有客户端
          => 使用send函数对上述保存过的每一个描述符进行
                发送数据即可
          => 注意跳过已经下线的客户端
     (6)使用信号2来关闭服务器
          => 对信号2进行自定义处理
客户端：
     (1)要求每一个客户端启动时需要指定一个昵称
     (2)要求客户端不断地和服务器进行通信，发送的内容由
          用户手动输入
     (3)要求客户端收发功能独立运行，采用多线程技术
     (4)当客户端发送"bye"时，表示客户端下线
扩展功能：
     (1)编程实现传输文件的功能
     (2)使用网络编程和多线程技术重构银行项目
      
