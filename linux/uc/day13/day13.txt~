复习：
1.信号的处理
    sigaction() -  主要用于设置信号的处理方式
    sigqueue() - 主要用于发送信号和附加数据到指定进程
    setitimer()/getitimer() - 设置/获取计时器的相关信息

2.进程间通信的方式
   (1)文件
   (2)信号
   (3)管道
   (4)共享内存
   (5)消息队列(重点)
   (6)信号量集
   (7)网络(重点)
   ...
   其中(4)(5)(6)统称为 XSI IPC通信方式
   
3.使用管道实现进程间的通信
3.1 基本概念
     使用管道通信本质还是以文件作为通信的媒介，只不过该文件比较特殊，文件本身不会存放任何数据
     管道分为：有名管道  和 无名管道
3.2 使用有名管道实现进程间的通信
     mkfifo  xxx.pipe
     echo hello > xxx.pipe
     cat xxx.pipe
     mkfifo() - 创建有名管道
3.3 使用无名管道实现进程间的通信
     pipe() - 主要用于创建无名管道，返回两个描述符

4.使用共享内存实现进程间的通信
(1)获取key值，使用ftok函数
(2)创建/获取共享内存，使用shmget函数
(3)挂接共享内存，使用shmat函数
(4)使用共享内存
(5)脱接共享内存，使用shmdt函数
(6)如果不再使用，则删除共享内存，使用shmctl函数

ipcs -m   查看系统中的共享内存
ipcrm -m 共享内存的ID  表示删除指定的共享内存

5.使用消息队列实现进程间的通信
(1)获取key值，使用ftok函数
(2)创建/获取消息队列，使用msgget函数
(3)发送/接受消息，使用msgsnd/msgrcv函数
(4)如果不再使用，则删除消息队列，使用msgctl函数
----------------------------------------------------------------------------
今天内容：
    (1)使用消息队列实现进程间的通信
    (2)使用信号量集实现进程间的通信
    (3)综合小项目：银行账户管理系统

1.使用消息队列实现进程间的通信
1.1 相关函数的解析
(1)msgget函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgget(key_t key, int msgflg);
第一个参数：key值，ftok函数的返回值
第二个参数：操作标志
      IPC_CREAT  -  创建
      IPC_EXCL  -  与IPC_CREAT搭配使用，若存在创建失败
       0  -  获取一个已经存在的消息队列
返回值：成功返回消息队列的ID，失败返回-1
函数功能：
      主要用于创建/获取一个消息队列
注意：
     当创建新的消息队列时，需要在第二个参数中指定权限信息，如按位或 0664等

(2)msgsnd函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：消息的首地址，消息的一般格式如下：
struct msgbuf 
{
    long mtype;      /* 消息的类型, must be > 0 */
    char mtext[1];  /* 消息的内容，可以是其他结构*/
};
第三个参数：消息的大小
     用于指定消息内容的大小，不包括消息的类型
第四个参数：消息的发送标志，默认给0即可
     IPC_NOWAIT  -  不会产生阻塞现象
函数功能：
      主要用于将指定的消息发送到指定的消息队列中

(3)msgrcv函数
    #include <sys/types.h>
    #include <sys/ipc.h>
    #include <sys/msg.h>
    ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：存放消息的首地址
第三个参数：消息的大小，不包括消息的类型
第四个参数：消息的类型
    0  - 表示始终读取消息队列中的第一个消息
  >0  - 表示始终读取消息队列中第一个类型为msgtyp的消息
  <0  - 表示始终读取消息类型<=msgtyp绝对值的消息，其
           中最小的类型优先读取
第五个参数：接受消息的方式，默认给0，产生阻塞现象
返回值：成功返回实际接收的数据大小，失败返回-1
函数功能：
      主要用于从指定的消息队列中接收消息

(4)msgctl函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/msg.h>
     int msgctl(int msqid, int cmd, struct msqid_ds *buf);
第一个参数：消息队列的ID，msgget函数的返回值
第二个参数：具体的操作命令
      IPC_RMID  - 删除消息队列，第三个参数给NULL即可
第三个参数：结构体指针
函数功能：
     主要用于操作指定的消息队列

1.2 基本命令
    ipcs  -q  表示查看系统中存在的消息队列
    ipcrm  -q  消息队列的ID   表示删除指定的消息队列

2.使用信号量集实现进程间的通信
2.1 基本概念
(1)什么是信号量？
      信号量本质就是一种计数器，用于控制同时访问同一个共享资源的进程个数/线程个数

(2)什么是信号量集？
      信号量集本质就是信号量的集合，也就是由若干个信号量组成的集合，主要用于控制多种共享资源各自同时被访问的进程/线程个数

(3)信号量的工作方式
    a.将信号量初始化为最大值；
    b.如果有进程申请到资源，则信号量的值减1；
    c.当信号量的值变为0时，申请资源的进程进入阻塞状态；
    d.如果有进程释放资源，则信号量的值加1；
    e.当信号量的值 > 0时，阻塞的进程继续抢占资源；

2.2 使用信号量集通信的基本模型
(1)获取key值，使用ftok函数
(2)创建/获取信号量集，使用semget函数
(3)初始化信号量集，使用semctl函数
(4)操作信号量集，使用semop函数
(5)如果不再使用，则删除信号量集，使用semctl函数

2.3 相关函数的解析
(1)semget函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semget(key_t key, int  nsems,  int semflg);
第一个参数：key值，ftok函数的返回值
第二个参数：信号量集的大小(信号量的个数)
       0  -  获取已经存在的信号量集
第三个参数：操作的标志
      IPC_CREAT  -  创建
      IPC_EXCL  - 与IPC_CREAT搭配使用，存在则创建失败
       0  -  获取已经存在的信号量集
返回值：成功返回信号量集的ID，失败返回-1
函数功能：
      主要用于创建/获取信号量集
注意：
     当创建新的信号量集时需要指定权限，如：0664等

(2)semctl函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semctl(int semid, int semnum, int cmd, ...);
第一个参数：信号量集的ID，semget函数的返回值
第二个参数：信号量集的下标(一般从0开始)
第三个参数：具体的操作命令
      IPC_RMID  -  删除信号量集，此时忽略第二个参数，不
                           需要第四个参数
      SETVAL  -  使用函数的第四个参数给信号量集中下标为
                        semnum的信号量进行初始化
第四个参数：可变长参数，是否需要取决于cmd
函数功能：
      主要用于控制指定的信号量集，具体功能取决于cmd

(3)semop函数
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>
     int semop(int semid, struct sembuf *sops, unsigned nsops);
第一个参数：信号量集的ID，semget函数的返回值
第二个参数：结构体指针，可以指向结构体变量，也可以指向
          结构体数组的首地址，结构体类型如下：
struct sembuf
{
    unsigned short sem_num;  /* 信号量的下标 */
    short  sem_op;   /* 信号量的操作 
         正数表示增加  0表示不变   负数表示减少  */
    short  sem_flg;  /* 操作标志，默认给0即可*/
};
第三个参数：结构体指针指向的结构体个数
函数功能：
      主要用于对指定的信号量执行指定的操作

2.4 基本命令
     ipcs  -s  表示查看当前系统中的信号量集
     ipcs  -a  表示查看当前系统中所有的IPC对象，包括共享内存，消息队列以及信号量集
     ipcrm  -s  信号量集的ID   表示删除指定的信号量集

3.综合小项目
3.1 项目名称
     银行账户管理系统(模拟ATM的功能)
3.2 项目功能
     开户、销户、存款、取款、查询、转帐、退出
3.3 项目架构
     采用C(Client)/S(Server)架构进行项目的架构  
客户端：
     提供界面让用户选择具体的业务，将用户的选择交给服务器进行处理，等待服务器的处理结果，并且显示给用户；

服务器：
    接受客户端发来的业务功能，通过访问数据库的方式进行处理，再将最终的处理结果交给客户端；

3.4 项目的详细设计
(1)客户端和服务器之间如何通信？？
     提供两个消息队列来实现通信
          消息队列一： 客户端  =>  服务器
          消息队列二： 服务器  =>  客户端
(2)不同的业务之间如何区分？？
     提供8种不同的消息类型
           6种不同的业务类型  + 成功  +  失败
(3)账户的数据类型和消息的数据类型应该如何设计？？
     采用结构体类型
     账户的信息：帐号、账户名称、密码、余额
     消息的信息：消息的类型   +   消息的内容(账户信息)
(4)以开户为例分析一下项目的执行流程
客户端：
    a.提供字符界面由用户选择具体的业务编号；
       => 使用printf打印界面即可
    b.根据用户的选择进入不同的分支处理；
       => 采用switch-case多分支结构
    c.提示用户输入用户名、密码以及余额信息；
       => 使用scanf函数进行读取即可
    d.将用户提供的信息和业务编号打包成完整的消息，
        发送到消息队列一中；
       => 打包消息的结构体变量，使用msgsnd发送即可
    e.等待服务器的处理结果，接收消息队列二中的消息；
       => 使用msgrcv函数进行接收，根据接收到的消息类型
             判断成功或失败，将结果打印出来
服务器：        
    a.创建两个消息队列；
      => 使用msgget函数
    b.接收消息队列一中的消息，并且判断消息的类型
      => 使用msgrcv函数，判断消息类型是否为开户的类型
    c.自动生成帐号，补充完整开户的用户信息，写入文件
       => 调用generator_id函数，使用write函数写入
       => 将每个用户信息保存在每个独立的文件中
       => 使用账户作为文件名确保唯一性，使用sprintf函数 
   d.根据用户信息写入是否成功，来修改对应的消息类型
       => 开户成功可以修改消息类型为7，否则修改为8
   e.将处理结果打包成完整的消息，发送到消息队列二中；
       => 使用msgsnd函数进行发送
   f.服务器应该24小时启动，除非手动去关闭；
       => 使用while(1)无限循环
       => 使用ctrl+c来关闭服务器，销毁两个消息队列

3.5 项目的要求
     (1)要求采用多文件的结构进行编程，而在每个文件中采用多个函数各自封装独立功能的方式进行编程；
     (2)要求实现开户的功能即可，有余力的同学考虑其他功能

3.6 项目的提示
     vi bank.h  -  定义用户信息和消息的数据类型
     vi client.c  -  编写打印字符界面的功能函数 ....
     vi server.c  -  编写创建消息队列的功能函数  ...
     vi dao.c  -  编写自动生成帐号的功能函数 ...
     ....
     最后支持Makfile文件

     














































     
















































