复习：
1.文件管理
1.1 文件的基本操作
    open() - 打开/创建一个文件
    close() - 关闭文件
    read() - 读取文件中的内容
    write() - 向文件中写入数据
    lseek() - 调整文件的读写位置

1.2 标C和UC文件操作的比较
      标C的文件操作函数效率更高一些，因为函数内部提供了输入输出缓冲区，当数据积累到一定数量之后才会访问内核，才会写入数据到文件中
      使用time命令获取程序的执行时间
      UC文件操作可以通过自定义缓冲区的方式来提高效率，但不是缓冲区越大则效率越高

1.3 文件描述符的工作原理

作业：
--------------------------------------------------------------------------
今天内容：
     (1)文件的管理       

1.文件的管理
1.1 dup/dup2函数
     #include <unistd.h>
     int dup(int oldfd);
函数功能：
     主要用于对参数oldfd进行复制，成功返回新的文件描述符，失败返回-1

     #include  <unistd.h>
      int dup2(int oldfd, int newfd);
函数功能：
     主要用于实现从oldfd到newfd的复制，如果必要的话先强制关闭newfd再占用，成功返回新的描述符，失败返回-1

注意：
    使用dup/dup2函数复制文件描述符，本质就是复制文件描述符所对应的文件表地址，也就是让多个文件描述符同时对应同一个文件而已

1.2 fcntl函数
    #include <unistd.h>
    #include <fcntl.h>
    int fcntl(int fd, int cmd, ... /* arg */ );
第一个参数：文件描述符，open函数的返回值
第二个参数：操作的命令(执行一个什么样的操作)
     F_DUPFD - 实现复制文件描述符的功能，与dup2所不同
             的是，不会强制关闭占用的描述符，寻找>=第三个
             参数的描述符进行复制
    F_GETFD/F_SETFD - 获取/设置文件描述符的标志
    F_GETFL/F_SETFL - 获取/设置文件状态标志
    F_SETLK/F_SETLKW/F_GETLK - 实现文件锁的功能
第三个参数：可变长参数，是否需要取决于cmd
       实现文件锁的功能时，该参数是一个指向以下结构体的结构体指针，结构体类型如下：
struct flock 
{
     ...
     short l_type;/*锁的类型：F_RDLCK(读锁), F_WRLCK(写锁), F_UNLCK(解锁) */
     short l_whence;  /*锁定的起始位置:              SEEK_SET, SEEK_CUR, SEEK_END */
     off_t l_start;   /*针对起始位置的偏移量*/
     off_t l_len;     /*锁定的字节数*/
     pid_t l_pid;     /*加锁的进程号(F_GETLK使用)，否则默认给-1即可
};

返回值：
    F_DUPFD - 成功返回新的文件描述符，失败返回-1
    F_GETFD - 成功返回文件描述符的标志值，失败返回-1
    F_GETFL - 成功返回文件的状态值，失败返回-1
    其他命令成功返回0，失败返回-1
函数功能：
     (1)复制文件描述符(了解)
     (2)操作文件描述符标志(了解)
     (3)操作文件状态标志(了解)
     (4)实现建议锁/文件锁的功能(重点)

1.3 使用fcntl函数实现文件锁的功能
(1)文件锁的由来
     当有多个进程同时对同一个文件进行读写操作时，可能会产生数据的覆盖问题，也就是多个进程同时读文件可以进行，但是只要有一个进程在执行写操作，那么其他进程既不能读也不能写，为了实现上述效果，可以通过文件锁机制来实现
      文件锁本质就是一把读锁和一把写锁，其中读锁是一把共享锁，允许其他进程加读锁，不允许其他进程加写锁；而写锁是一把互斥锁，不允许其他进程加读锁和写锁(君子协定)
          
(2)F_SETLK作为函数的实参
      当锁的类型为F_RDLCK/F_WRLCK时，实现加锁功能
      当锁的类型为F_UNLCK时，实现解锁功能

练习：
     vi 04write.c文件，编程向文件b.txt中写入字符串内容"hello"，并且判断写入是否成功

总结：
     根据例子代码可知，给文件加完写锁之后还是可以向文件中写入数据内容的，结果说明文件锁是独立于文件的，也就是文件锁并不能控制对文件的读写操作，只能控制其他进程能否加锁成功，换句话说，如果给文件加了一把锁，可以导致第二次加锁失败(两个读锁除外)
  
思考：
    如果希望通过文件锁来控制对文件的读写操作,如何处理？

解决方案：
    为了实现上述效果，可以在每次进行读写操作之前尝试加读写锁，根据能否加上读写锁来决定能否进行读写操作，从而使得文件锁对文件的读写操作产生了约束

释放文件锁的方式：
     a.将锁的类型改为F_UNLCK，然后重新设置即可
     b.使用close函数关闭文件后，文件描述符对对应的文件
        上所有属于当前进程的文件锁都会释放
     c.进程结束，会自动释放所有该进程增加的文件锁

练习：
    vi 06unlock.c文件，首先对文件b.txt中的前10个字节加写锁，然后占用20秒之后开始解锁，解锁的方式为修改锁的类型，然后再占用20秒之后关闭文件，结束进程

(3)F_SETLKW作为函数的实参
      功能与F_SETLK类似，所不同的是如果当前锁加不上时，会进入阻塞状态一直等待，直到可以加上锁为止

(4)F_GETLK作为函数的实参
      如果第三个参数所描述的锁可以放置到文件上，则不去放置该锁，而是将锁的类型改为F_UNLCK，结构体中的其他成员保持不变；
      如果第三个参数所描述的锁不可以被放置到文件上，则使用文件上已经存在的锁信息去替换参数锁信息，并且将l_pid设置为真正给文件加锁的进程所对应的进程号；
 
1.4 access函数
      #include <unistd.h>
      int access(const char *pathname, int mode);
第一个参数：字符串形式的路径和文件名
第二个参数：操作模式
      F_OK  表示判断文件是否存在
      R_OK  表示判断文件是否可读
      W_OK  表示判断文件是否可写
      X_OK  表示判断文件是否可执行
函数功能：
     主要用于检查文件的存在性以及对应的权限信息      

作业：
     编写函数generator_id()实现生成递增帐号的功能
     a.out  100000   
     a.out  100001
     a.out  100002
     ... ...
明日预报：
    (1)文件管理
    (2)目录管理
    (3)进程管理























































































 
