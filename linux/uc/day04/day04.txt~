复习：
1.库文件的概念和使用
1.1 静态库的生成和调用步骤
(1)生成步骤
    a. vi add.c
    b. cc -c add.c
    c. ar -r libadd.a add.o
(2)调用步骤
    a. vi main.c
    b. cc -c main.c
    c. 链接的方式有三种：
        1) cc main.o libadd.a
        2) cc main.o -l add -L . 
        3) export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add

1.2 共享库的基本概念和特性
(1)基本概念
     共享库与静态库的最大不同之处：不会拷贝被调用的代码指令，而是将被调用代码指令在共享库中的相对地址拷贝到调用模块中

(2)基本特性
优点：
      a.共享库占用的空间比较小，可执行文件比较小
      b.修改和维护都比较方便
缺点：
      a.执行效率低
      b.不可以脱离共享库文件

1.3 共享库的生成和调用步骤
(1)生成步骤
    a. vi add.c
    b. cc -c -fpic add.c
    c.  cc -shared add.o -o libadd.so
(2)调用步骤
    a. vi main.c
    b. cc -c main.c
    c. 链接的方式有三种：
        1) cc main.o libadd.so
        2) cc main.o -l add -L . 
        3) export LIBRARY_PATH=$LIBRARY_PATH:.
             cc main.o -l add

注意：
    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.

1.4 共享库的动态加载
    #include <dlfcn.h>
     编译链接时需要指定 -ldl
    dlopen() - 打开/加载共享库文件
    dlsym() - 获取共享库中指定的函数地址
    dlclose() - 关闭/卸载共享库文件
    dlerror() - 获取具体的错误原因

2.C语言中的错误处理
2.1 C语言中的错误表现形式(错了吗？)
    (1)对于返回值类型为int类型的函数来说，并且函数的计算结果不可能是负数时，则返回-1代表错误，返回其他数据代表正常结束
    (2)对于返回值类型为int类型的函数来说，并且函数的计算结果可能是负数时，需要使用指针作为函数的参数将函数的计算结果带出去，而函数的返回值专门表示成功还是失败，使用-1表示错误，0表示成功
    (3)对于返回值类型为指针类型的函数来说，使用返回NULL表示错误
    (4)如果不考虑函数是否出错，则返回值类型给void

2.2 错误编号(为什么错了？)
     #include <errno.h>
     errno本质就是一个int类型的全局变量
     /etc/passwd - 包含了当前系统的用户信息
     /etc/shadow - 包含了系统中的真实密码信息
作业：
---------------------------------------------------------------------------
今天内容：
    (1)C语言中的错误处理
    (2)环境表的概念和使用
    (3)内存管理技术

1.C语言中的错误处理
1.1 错误信息
(1)strerror函数
     #include <string.h>
     char *strerror(int errnum);
函数功能：
     主要用于根据参数指定的错误编号翻译成对应的错误信息，通过返回值返回，当错误编号不合法时，返回“Unknown error nnn”

(2)perror函数(重点)
     #include <stdio.h>
     void perror(const char *s);
函数功能：
     主要用于向标准错误输出上打印最后一个错误信息，如果参数不为空时，则参数的内容原样输出，后面跟着一个冒号，一个空格，再跟着错误信息，并且最后自动换行

(3)printf函数(了解)
    printf("%m\n");  => 打印具体的错误信息

注意：
    判断函数是否出错需要根据函数的返回值进行判断，在明确函数已经出错的情况下，可以通过errno来获取具体的错误原因，但是不能直接使用errno来作为判断函数是否出错的依据，因为errno是个全局变量，errno的数值会随时发生改变，尤其在多线程编程中

2.环境表的概念和使用
2.1 基本概念
     环境表本质就是环境变量的集合，每个进程内部都拥有一张独立的环境表，用于记录和当前进程相关的环境变量信息
     环境表本质就是一个字符指针数组，并且以空指针作为字符指针数组的结尾标志，其中每个指针都是指向一个格式为"环境变量名=环境变量值"的字符串的首地址，而整个环境表的首地址记录在一个全局变量char** environ中，因此可以通过全局变量environ来获取整个环境表中的信息

2.2 基本操作
(1)getenv函数
     #include <stdlib.h>
     char *getenv(const char *name);
函数功能：
     主要用于获取参数指定的环境变量名所对应的环境变量值
，如果环境变量不存在，则返回NULL

(2)setenv函数
     #include <stdlib.h>
     int setenv(const char *name, const char 
*value, int overwrite);
第一个参数：环境变量名
第二个参数：环境变量值
第三个参数：是否修改的标志位
      非0 - 可以修改
        0 - 不可以修改
返回值：成功返回0，失败返回-1
函数功能：
      主要用于增加环境变量/修改环境变量的变量值，也就是如果环境变量不存在则增加，如果环境变量存在则是否修改取决于第三个参数

(3)unsetenv函数
    #include <stdlib.h>
    int unsetenv(const char *name);
函数功能：
      主要用于从环境表中删除参数指定的环境变量，如果该环境变量不存在，则函数的调用依然是成功的，环境表也不会发生改变

(4)putenv函数
     #include <stdlib.h>
     int putenv(char *string);
函数功能：
     主要用于增加环境变量/修改环境变量的值，参数的格式为：name=value，也就是说环境变量不存在则增加，存在则修改，成功返回0，失败返回非0

(5)clearenv函数
     #include <stdlib.h>
     int clearenv(void);
函数功能：
     主要用于清空整个环境表中所有的环境变量对，并且将全局变量environ也置为空指针，成功返回0，失败返回非0

2.3 main函数的原型
    int main(int argc,char* argv[],char* envp[])
第一个参数：记录命令行参数的个数
第二个参数：字符指针数组，用于记录每个命令行参数的地址
第三个参数：字符指针数组，用于记录当前进程的环境表信息

执行程序的方式为  a.out a.txt b.txt时：
      argc = 3;
      argv[0] = a.out
      argv[1] = a.txt
      argv[2] = b.txt
   
注意：
    由于历史的原因，main函数的第三个参数并不一定会被所有的系统支持，因此建议使用全局变量environ来访问环境表

实际案例：
     实现从文件argv[1]到文件argv[2]的拷贝
a.打开文件argv[1]和argv[2]
b.读取文件argv[1]中的内容写入到文件argv[2]中
c.关闭文件argv[1]和argv[2]        

     a.out a.txt b.txt     
  => 实现从a.txt到b.txt的拷贝
     a.out b.txt c.txt
  => 实现从b.txt到c.txt的拷贝

3.内存管理技术
3.1 程序和进程的基本概念
     程序 - 本质就是指存放在磁盘上的可执行文件
     进程 - 本质就是指运行在内存中的程序
     同一个程序可以同时启动多个进程

3.2 进程中的内存区域划分
如：
    int num;  // 全局变量   初始值是0    BSS段
    int main(void)
    {
         int num; // 局部变量  初始值是随机数   栈区
         return 0;
    }         
(1)代码区(Text)
    - 主要用于存放功能代码，函数指针指向该区域
(2)只读常量区(Text)
    - 主要用于存放字符串常量，const修饰的已经初始化的全
       局变量 和 静态局部变量
(3)全局区/数据区(Data)
    - 主要用于存放没有const修饰的已经初始化的全局变量和
       静态局部变量      
(4)BSS段(Data)
    - 主要用于存放没有const修饰的没有初始化的全局变量和
      静态局部变量
    - 该区域会在main函数执行之前执行自动清零的操作
(5)堆区(Heap)
    - 主要指使用malloc/calloc/realloc/free函数操作的
       内存区域
    - 该区域中的内存由程序员手动申请和手动释放
(6)栈区(Stack)
    - 主要用于存放局部变量(包括函数的形参),const修饰的
      局部变量以及块变量
    - 该区域中的内存由操作系统自动管理

综上所述：
     进程中的内存区域按照地址从小到大依次是：代码区、只读常量区、全局区、BSS段、堆区、栈区
     一般来说，堆区的内存地址按照从小到大依次分配，而栈区的内存地址按照从大到小依次进行分配

作业：
     根据图片以及程序来分析和理解进程中的内存区域划分
明日预报：
    (1)内存管理技术






     






























































































    












































       

















