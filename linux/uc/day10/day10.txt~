复习：
1.文件的管理
    stat()/fstat() - 主要用于获取文件的状态信息
    chmod()/fchmod() - 主要用于修改文件的权限信息
    truncate()/ftruncate() - 主要用于修改文件的大小
    umask()  -  主要用于设置文件创建时的权限屏蔽字
    mmap()/munmap() - 建立虚拟地址到文件的映射
    link()/unlink()/rename()/remove()/... ...

2.目录的管理
    opendir() - 打开目录
    readdir() - 读取目录中的内容
    closedir() - 关闭目录
    mkdir()/rmdir()/chdir()/getcwd()/ ... ...   
  
3.进程的管理
3.1 基本概念和基本命令
     ps  -  查看当前终端所启动的进程  PID   CMD
     ps -aux  -  显示所有包含其他使用者的进程信息
     ps -ef  -  以全格式的方式显示进程信息
     kill -9 进程号  表示杀死指定的进程
     目前主流的操作系统都支持多进程，如果进程A启动了进程B，则进程A叫做进程B的父进程，进程B叫做进程A的子进程
     进程0(系统级进程)负责启动了进程1(init)和进程2，其他所有的进程都是直接/间接 由 进程1/进程2 启动的，最终组成了树形结构   
-----------------------------------------------------------------------------
今天内容：
     (1)进程的管理
     (2)信号的处理

1.进程的管理
1.1 各种ID的获取
    #include <sys/types.h>
    #include <unistd.h>
    getpid()  -  获取当前进程的进程编号，返回pid_t
    getppid()  -  获取当前进程父进程的进程编号,返回pid_t
    getuid()  -  获取当前用户的编号，返回uid_t
    getgid()  -  获取当前用户所在用户组的编号，返回gid_t
注意：
    PID - 进程的编号，操作系统通过该编号唯一标识指定的进程，但是进程号的分配采用延迟重用的策略，在任意时刻都保证了进程号的唯一性
    pid_t本质就是int类型，进程号都是非负整数
    uid_t本质就是unsigned int类型
    gid_t本质就是unsigned int类型
      
1.2 进程的创建
(1)fork函数
     #include <unistd.h>
     pid_t fork(void);
函数功能：
     主要用于通过复制当前正在调用进程的方式来创建子进程，调用成功时父进程返回子进程的进程号，子进程返回0，调用失败时父进程返回-1，没有子进程存在

注意：
     使用fork函数创建子进程后，父子进程之间的执行顺序取决于操作系统的调度算法

(2)父子进程的代码执行方式
    a.对于fork函数之前的代码，由父进程执行一次；
    b.对于fork函数之后的代码，由父子进程各自执行一次；
    c.fork函数的返回值 由父子进程各自返回一次，父进程返
       回子进程的进程号，子进程返回0，因此可以通过函数的
       返回值来区分父子进程

(3)父子进程之间的关系
    a.父进程启动了子进程，父子进程同时执行，如果子进程先结束，子进程会给父进程发信号，父进程负责回收子进程的资源；
    b.如果父进程先结束，则子进程会变成孤儿进程，子进程会变更父进程(重新设定父进程,init进程)，init进程因为收养孤儿进程，因此被称为孤儿院；
    c.如果子进程先结束，但是父进程由于各种原因没有收到子进程发来的信号，则不会负责回收其资源，那么子进程就会变成僵尸进程；

(4)父子进程之间内存资源的关系
     对于fork函数创建的子进程来说，子进程会复制父进程中除了代码区之外的其他内存区域，而代码区和父进程共享

(5)扩展
    a.如何使用fork函数创建4个进程？？？
          fork();
          fork();
      4个进程：1个父进程 + 2个子进程 + 1个孙子进程
   b. 如何使用fork函数创建3个进程？？？
          pid = fork();
          if(0 != pid)
         {
                fork();
         }    
      3个进程：1个父进程  +  2个子进程
   c. 俗称"fork炸弹"
        while(1)
        {
              fork();
        }

1.3 进程的终止
(1)正常终止进程的方式
    a.执行到了main函数的return 0；
    b.调用exit()函数
    c.调用_exit()/_Exit()函数
    d.最后一个线程返回
    e.最后一个线程调用pthread_exit()函数
(2)非正常终止进程的方式
    a.采用信号来终止进程，如：ctrl+c
    b.最后一个线程被其他线程调用pthread_cancel函数取消

(3)终止进程相关函数的解析
    #include <unistd.h>
    void _exit(int status);   => UC函数
    #include <stdlib.h>
    void _Exit(int status);   => 标C函数
函数功能：
     主要用于立即终止当前正在调用的进程，自动关闭所有属于该进程的文件描述符，让该进程的所有子进程变更父进程为init进程，该进程也会其父进程发送SIGCHILD信号来回收该进程的资源
     参数值会被返回给当前进程的父进程作为当前进程的退出状态信息，父进程若要收集退出状态信息，则需要调用wait系列函数来处理

     #include <stdlib.h>
     void exit(int status);
函数功能：
      主要用于引起正在调用进程的终止，参数status & 0377之后的结果会被返回给父进程作为当前进程的退出状态信息
      在终止进程之前会自动调用所有由atexit()和on_exit()函数注册过的函数
      
      #include <stdlib.h>
      int atexit(void (*function)(void));
函数功能：
      主要用于注册参数指定的功能函数，注册过的函数会在进程正常终止时调用，而进程正常终止的方式为：调用exit()函数和从main函数中返回
      该函数调用成功时返回0，失败返回非0

1.4 进程的等待
(1)wait函数
     #include <sys/types.h>
     #include <sys/wait.h>
     pid_t wait(int *status);
函数功能：
     主要用于挂起当前正在调用的进程，直到该进程的一个子进程终止为止
     当参数不为空时，就将获取到的进程退出状态信息存放到参数status所指向的存储空间中，为了解析该退出状态信息，需要使用以下的带参宏：
     WIFEXITED(*status) - 如果进程正常终止则返回真，所谓正常终止就是指：调用exit()/_exit()/从main函数中返回
     WEXITSTATUS(*status) - 获取子进程的退出状态信息
     成功返回终止子进程的进程号，失败返回-1

(2)waitpid函数
     #include <sys/types.h>
     #include <sys/wait.h>
     pid_t waitpid(pid_t pid, int  *status,int options);
第一个参数：进程的编号
    <-1 等待进程组ID为pid绝对值的任意一个子进程(了解)
     -1  等待任意一个子进程(重点)
     0   等待和正在调用进程在同一个进程组的任意子进程
          (了解)
    >0  等待进程号为pid的子进程(重点)
第二个参数：指针作为函数的参数，获取进程的退出状态
第三个参数：等待的方式，默认给0，表示等不到会阻塞
    WNOHANG - 没有子进程终止时立即返回，不会阻塞
返回值：成功返回终止子进程的进程号，失败返回-1
函数功能：
      主要用于等待指定的进程状态发生改变
注意：
      The call wait(&status) is equivalent to:
      waitpid(-1, &status, 0);

1.5 进程的其他管理函数
(1)vfork函数
     #include <sys/types.h>
     #include <unistd.h>
     pid_t vfork(void);
函数功能：
     与fork函数类似，都是创建当前正在调用进程的子进程，有关创建的详细信息、返回值以及常见的错误信息请参考fork函数即可
     与fork函数不同之处在于，不会复制父进程中的内存区域，而是直接占用，导致父进程会被挂起直到子进程终止，或者子进程调用exec系列函数为止，所以vfork函数保证了子进程先于父进程执行
      使用vfork函数创建的子进程终止时只能调用_exit函数，而不能从当前函数返回 或者 调用exit函数

(2)exec系列函数
    #include <unistd.h> 
    int execl(const char *path, const char*arg, ...);
第一个参数：字符串形式的路径名
第二个参数：字符串形式的参数，一般指定可执行文件名
第三个参数：可变长参数，是否需要取决于前两个参数
函数功能：
      主要用于执行指定的文件
如：
    使用execl函数执行ls -l 命令时的用法如下：
        execl("/bin/ls","ls","-l",NULL);
注意：
       vfork函数本身没有太大的实际意义，一般需要与exec系列函数搭配使用，这样可以使得父子进程去执行完全不同的代码段
       fork函数也可以和exec系列函数搭配使用，但是效率相对比较低，因此一般情况下很少这样使用

(3)system函数
     #include <stdlib.h>
     int system(const char *command);
函数功能：
     主要用于执行参数指定的shell命令，但是在实际项目开发中可能更多地被用于执行shell脚本和可执行文件

2.中断的概念和分类
      中断就是指暂停执行当前正在执行的程序转而执行其他程序或者处理意外情况的过程
      中断分为：硬件中断  和 软件中断

3.信号的处理
3.1 基本概念和特点
(1)基本概念
      信号本质就是一种软件中断,它既可以作为进程间通信的一种方式，又可以中断一个正常运行的进程，它更多地被用于处理意外情况

(2)基本特点
    a.信号是异步的，也就是进程并不知道信号何时会到达;
    b.进程既可以处理信号，也可以发送信号给指定的进程;
    c.每个信号都有一个名字，并且用SIG开头;

3.2 信号的基本命令和分类
      kill -l  表示查看当前系统所支持的所有信号
      一般来说，在linux系统中支持的信号范围是：1 ~ 64，不保证信号是连续的，而unix系统与linux系统有所不同，一般支持的范围是 1 ~ 48;
      在linux系统中，其中 1 ~ 31之间的信号叫做不可靠信号，不支持排队，信号随时可能会丢失，也叫做非实时信号；
      其中34 ~ 64之间的信号叫做可靠信号，支持排队，信号不会丢失，也叫做实时信号；

要求掌握的信号：
      SIGINT    2   使用ctrl+c产生该信号   进程终止
      SIGQUIT  3   使用ctrl+\产生该信号   进程终止
      SIGKILL   9   使用kill -9产生该信号   进程终止
作业：
      查询signal函数并且尝试使用
明日预报：
      (1)信号的处理






   













































































































   


























































 













