十八 静态成员
C语言：static
      a.修饰局部变量
      b.修饰全局变量 
      c.修饰函数
1 静态成员变量
class 类名{
    static 数据类型 变量名;//声明
};
数据类型  类名::变量名 = 初值;//定义及初始化
1）非静态成员变量属于对象，静态成员变量属于类
2）不能在构造函数中被定义和初始化，需要类的外部单独定义并初始化。
3）可以通过类名直接访问，也可以通过对象访问。
4）静态成员变量在该类的多个实例对象间共享。
5）静态成员变量存放在全局区。
6）静态成员变量使用受访控属性影响。

2 静态成员函数
1）可以通过类名直接访问，也可以通过对象访问
2）和普通成员函数一样受访问属性的约束
3）静态成员函数没有this指针，也没有const属性

3 静态成员函数只能访问静态成员；非静态成员函数既可以访问静态成员也可以访问非静态成员。
-----------
4 单例模式
1）禁止在外部创建对象：私有化构造函数
2）类自己维护唯一对象：静态成员变量
3）提供访问该对象的方法: 静态成员函数
4）创建方式
     饿汉式 : 无论用不用，程序启动创建
     懒汉式 : 用的时候创建，不用时即销毁
------------------
------------------
十九  成员指针
1.成员变量指针
1）定义
类型 类名::*成员指针变量名 = &类名::成员变量;
Student s;
string* p = &s.name;//普通指针
string Student::*panme = &Student::name;
2)赋值
指针名 = &类名::成员变量名
3)使用
对象.*成员指针变量名；
对象指针->*成员指针变量名；
2.成员函数指针
1）定义：
  返回类型 (类名::*成员函数指针)(形参表) 
		  = &类名::成员函数名；
2)赋值
  成员函数指针 = &类名::成员函数名
3）使用
  (对象.*成员函数指针)(实参表)
  (对象指针->*成员函数指针)(实参表)

3.静态成员指针与普通指针在定义、使用和语义没有任何区别。
====================
二十  操作符重载
复数
3+4i；
（1+2i）+ （3+4i） = (4+6i)
 c1.add(c2)
1 双目操作符 L#R
1.1 运算类的双目操作符：+ - *  /  %...
  a.左右操作数可以是左值，也可以是右值
  b.表达式的值为右值
1）成员函数形式
  L#R的表达式会被编译器处理L.operator#(R)的成员函数调用，该函数的返回值即为表达式的值。
2）全局函数形式
  L#R的表达式也可以被编译器处理为::operator#(L,R)的全局函数调用，该函数的返回值就是表达式的值
3）通过friend关键字，可以把一个全局函数声明为某个类的友元，友元函数可以访问类当中的任何成员。
   
1.2 赋值类的双目操作符
   a.左操作数是左值不能是右值(常量)，右操作数可以是左值也可以是右值。
   b.表达式的值是一个左值，而且他就是左操作数的本身
1）成员函数形式
    L.operator#(R)
2）全局函数的形式
    ::operator#(L,R)

2 单目操作符#O
  -  ~ ！ ...
2.1 计算类单目操作符
1）成员函数形式
   O.operator#();
2）全局函数形式
   ::operator#(O);
2.2 自增减单目操作符
1）前缀自增减
int a = 10;
(++a) = 10;//ok
操作数是左值(可修改)，返回值就是操作数自身也是左值.
成员函数形式:
    O.operator#()
全局函数形式:
   operator#(O)
2）后缀自增减
int a = 10;
int res = a++;
(a++) = 20;//error
10++;
printf("%d\n",a);
操作数是左值(可修改)，返回值就是操作数副本，是右值.
成员函数形式:
    O.operator#(int)
全局函数形式:
   operator#(O，int)
============
3 其它操作符重载


-----------------
#include<iostream>
#include<stdarg.h>
int ripple(int, ...);
int main(void)
{
    int num;
    num = ripple(3, 5, 7);
    cout << num << endl;
}
int ripple(int n, ...)
{
    int i, j = 1, k = 0;
    va_list p;
    va_start(p, n);
    for( ; j < n; ++j)//循环2次
    {
        i = va_arg(p, int);//i = 7
        for( ; i; i &= i-1) // 100 & 011 = 0
        {
           ++k;//+1+1+1+1+1
        }
    }
    return k;  //5
}
 




