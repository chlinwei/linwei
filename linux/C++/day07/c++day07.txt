二十  操作符重载
1 ..
2 ..
3 其它操作符重载
3.1 插入/提取操作符： << >>
cout << a << b << endl;
cin >> a;
ostream cout;
istream cin;

friend ostream& operator<<(ostream& os,const RIGHT& right){}
friend istream& operator>>(istream& is,RIGHT& right){}

3.2 下标操作符: []
class A {
int *m_a;
};
A a(10);
a[0] = 10;//a.operator[](0) -> a.m_a[0] = 10

int arr[5] = {1,2,3,4,5};
arr[0] = 10;
const int (&r)[5] = arr;
r[0] = 10;//error

*3.3 函数操作符:()
func();
A a;
//a.operator()(...)
a(...);//实现类的对象可以当作函数来调用

3.4 解引用和间接成员访问操作符： *  ->
A a;
*a=
a->
用于实现智能指针：一个封装常规指针的类类型对象。

3.5 类型转换操作符
1）通过构造函数实现自定义类型转换
   基本类型 --> 类 类型
   类 类型 --> 类 类型
2）通过类型转换操作符函数实现实现自定义的类型转换
   类 类型-->基本类型
   类 类型 --> 类 类型
   operator 目标类型(void)const{...}
3)两个基本类型不能实现自定义转换

3.6 new/delete操作符
static void* operator new(size_t size){...}
static void opetator delete(void* p){...}

4 操作符重载的限制
1）下列操作符不能重载：
作用域限定操作符 "::"
直接成员访问操作符 “.”
直接成员指针解引用操作符 ".*"
条件操作符“?:”
字节长度操作符“sizeof”
	int a = 100;
	sizeof(a+3.14);//8
	sizeof(a = a+3.14);//4
	cout << ａ＜＜endl;//100
类型信息操作符“typeid”//后面讲

2）如果一个操作符的所有操作数都是基本类型，则无法重载。
    int operator+（int a,int b）{//error
	return a - b;
    }

3）操作符重载不会改变编译器预定义的优先级.

4）操作符重载无法改变操作数的个数。

5）无法通过操作符重载发明新的操作符
  double operator@（double a）｛//error
	return a*a;
｝

===========
二十一  继承（Inheritance）
1 继承的基本概念
    通过一种机制表达类型之间共性和特性的方式，利用已有数据类型定义新的数据类型，这种机制叫做继承。
  
  人类：姓名、年龄、吃饭、睡觉
  学生类：姓名、年龄、学号 、吃饭、睡觉、学习
  教师类：姓名、年龄、工资、吃饭、睡觉、授课

  人类：姓名、年龄、吃饭、睡觉
  学生继承人类：学号、学习
  教师继承人类：工资、授课

	人类(基类、父类)
               /       \
         学生类    教师类(派生类、子类)         
         基类派生子类，子类继承基类。
2 继承的语法
class 子类：继承方式1  基类1，继承方式2 基类2...{
         ...
};
class Human{
public:
   void sleep(){..}
   void eat(){..}   
private:
   string name;
   int age;
};
class Student:public Human{
  //Student类继承Human类，Student类中存在一份human类中成员。
};
继承方式:
    共有继承：public
    保护继承：protected
    私有继承：private

3 继承的特性（public）
3.1 任何时候子类对象可以看作是基类对象
Student s；
s.eat（）
s.sleep（）

3.2 向上和向下造型
1）向上造型：将子类 类型的指针或引用转换 为基类 类型的指针或引用。这种操作性缩小的类型转换，在编译器看来是安全的，可以隐式转换。
2）向下造型：将基类 类型的指针或引用转换 为子类 类型的指针或引用。这种操作性放大的类型转换，在编译器看来不不安全的，必须显示转换。

3.3 子类继承基类的成员
1）在子类中或者通过子类，可以直接访问基类中的共有和保护成员，如同它们是在子类中声明的一样。

2）基类的成员在子类中虽然存在但是不可见，所以无法直接访问，但是可以通过基类提供的共有或者保护的接口函数间接访问。

3）基类的构造函数和析构函数，子类无法继承，但是可以在子类自己的构造函数中通过初始化表，显示指明基类部分(基类子对象)的初始化方式。
===========
作业一 ：实现一个3X3矩阵，支持如下操作符
+ - "*" += -=  -(负) ++(前后)  --（前后） []  <<
operator[]
int m_a[3][3];
1 2 3      	9 8 7       	10  10  10
4 5 6  +  	6 5 4  =   	10  10  10
7 8 9      	3 2 1       	10  10  10
 
1 2 3      	9 8 7       	 30    24  18
4 5 6  *  	6 5 4  =   	 84    69  54
7 8 9      	3 2 1       	 138  114  90

作业二：读懂继承的案例

















