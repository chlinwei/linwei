二十二 多态(Polymorphic)
...
*5 多态实现原理（虚函数表和动态绑定）
1）编译器会为包含虚函数的类生成一张虚函数表，用来存放每个虚函数地址,简称虚表，每个虚函数对应虚表中的索引号。
2）编译器还会为包含数虚函数的类增加一个隐式的成员变量，用于存放虚函数表的首地址，该变量被称为虚函数表指针，简称虚指针。
3）所谓虚函数覆盖，其实就是用子类中的虚函数地址覆盖基类虚表中的虚函数地址。
4）当编译器看到通过指针或引用调用虚函数的语句时，不会生成有关函数调用的指令，而会用一段代码做替换，这段代码在运行阶段被执行，完成如下工作：
    a.确定调用指针或引用的目标对象的真是类型，并找到虚指针
    b.根据虚指针找到相应的虚表，并从中获取所调用虚函数的入口地址
    c.根据虚函数的入口地址执行虚函数代码。
    这个函数绑定的过程在运行阶段完成，因此被称为动态绑定。

6 动态绑定对性能的影响
1）动态绑定会增加内存的开销；
2）虚函数的调用会增加时间的开销；
3）虚函数不能被内联优化
如果没有多态的要求，最好不要使用虚函数

7 虚析构函数
如果将基类的析构声明为虚函数，那么子类的析构函数就也是一个虚函数，并且对基类的虚析构函数构成有效的覆盖，可以表现多态的特性。
这时delete一个指向子类对象的基类指针，实际被调用的将是子类的析构函数，子类析构会自动调用基类的析构函数，实现资源完美释放，避免内存泄漏的风险。
=================
实例：薪资计算
所有员工：姓名、工号、等级、基本工资
经理：绩效奖金
技术员：研发津贴(元/小时)
销售员：提成比率

薪资：基本工资+绩效工资
基本工资=等级额度*出勤率
绩效工资工资的计算因职务不同而异

绩效工资的具体计算方法
普通员工：基本工资的一般
经理：绩效奖金*绩效因数(输入)
*技术员：研发津贴*工作小时数*进度因数(输入)
销售员：销售额度(输入)*提成比率
*技术主管：(技术员绩效工资+经理的绩效工资)/2
销售主管：(销售员绩效工资+经理的绩效工资)/2

打印员工信息，输入必要数据，计算薪酬。
	员工
           /       |         \
   技术员     经理      销售员
        \      /     \      /
      技术主管     销售主管

=========================
二十三  运行时类型信息
1. typeid运算符
    typeid(类型/对象)，返回一个typeinfo类型对象的常引用。typeinfo中包含名为name(）成员函数，返回char*字符串,包含类型的信息。
    typeinfo类提供"==" "!="运算符的支持，通过它们直接进行类型之间的比较，如果在类型之间存在多态特性的继承关系，typeid还可以利用多态的特性确定实际对象类型。

2. 动态类型类型转换
   dynamic_cast主要用于具有多态特性的的父子类指针和引用之间的显示类型转换。
	A
               /　＼　
　　　　Ｂ　  Ｃ　　　
Ａ* pa = &b;
B*  pb = pa;//显示转换
C*  pc = pa;//动态类型，error

  dynamic_cast在转换过程中，会检查目标对象和期望转换的对象是否一致，如果一致则转换成功，否则失败。如果转换的是指针，返回NULL表示失败，如果是引用抛出“bad_cast”异常表示失败。

=============================
二十四 异常（Exception）
1 常见错误
1）语法错误
2）逻辑错误
3）功能错误
4）设计缺陷
5）需求不符
6）环境异常
7）操作不当

2 传统的错误处理机制
1）通过返回值表示错误
优点：函数调用路径中所有的局部对象都能被右花括号正确地析构，不会有内存泄漏。
缺点：错误处理流程比较复杂，逐层判断，代码臃肿。

2）通过远跳机制处理错误
优点：不需要逐层的判断，实现一步到位的错误处理，代码精炼。
缺点：函数调用路径中的局部对象失去被析构机会，容易形成内存泄漏。



int (*m_arr)[3] = new int[a][3];//ok
int arr[3][3] = new int[3][3];//error
int **arr = new int*[3];//ok
int **arr = new int[3][3];//error
