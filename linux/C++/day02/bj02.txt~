八、C++的函数
1. 函数重载
1)函数重载的定义
   在相同作用域中，定义同名的函数，但是它们的参数表必须有所区分，这样的函数构成重载关系。
   重载与函数的返回类型无关，与参数名也无关，而只与参数的个数，参数类型和顺序有关。

2)调用重载函数时，编译器根据实参与形参的匹配程序，自动选择最优的重载版本。
g++编译器的一般规则：
    完全匹配>常量转换>升级转换>降级转换>省略号匹配

3)函数重载原理
   C++编译器通过对函数进行换名，将参数表的信息整合到函数名中，实现解决函数重载与名字冲突的矛盾。
   函数声明中加入extern "C”要求C++编译器不对函数做换名，便于C程序调用该函数。
  extern "C" void func(..){...}
  extern "C"{
        void func1(...);
        void func2(...);
  }

2. 函数的缺省参数
1）可以为函数的部分或全部参数指定缺省值，调用该函数时，如果不给实参，就取缺省值作为相应的形参值。
void func(int a,int b,int flag=缺省值)｛｝
void func(int a,int b,int flag=0)｛...｝
int main(){
   func(10,20);
}
2）缺省参数必须靠右，如果一个参数有缺省值，那么这个参数右侧的所有参数都必须带有缺省值。
void func(int a = 10,int b){}//error
void func(int a = 10,int b = 100 ,int flag = 0)｛...｝
3）如果函数的定义和声明分开，缺省参数应该写在函数的声明部分，而定义部分不写。
  void func(){} -->函数的定义
  void func();   -->函数的声明

3.函数的哑元参数
1）只有类型没有变量名的形参称为哑元
void func(int){...}
2）为了兼容旧代码
算法库:void math_func(int a,int b){...}
使用者:
int main(){
    math_func(num1,num2);
    ...
    math_func(num1,num2);
}
---------
升级算法库:
void math_func(int a，int/*哑元*/){...}
int main(){
    math_func(num1,num2);
    ...
    math_func(num1,num2);
}
3）运算符函数重载:区分前后++、-- //后面讲

4. 内联函数
    使用inline关键字修饰的函数，表示这个函数是内联函数，编译器会尝试做内联优化，避免函数调用的开销。
1）多次调用的小而简单函数适合内联
2）调用次数极少或者大而复杂的函数不适合内联
3）递归函数不适合内联
4）内联只是一种建议不是要求，能否内联取决于编译器，有些函数不加inline关键字也会被编译器默认处理为内联
for(int i=0;i<10000;i++)
    for(int j=0;j<100;j++){...}
for(int i=0;i<100;i++)
    for(int j=0;j<10000;j++){...}
=====================
九、C++动态内存分配
C语言：malloc()/free()
C++中：new/delete 运算符
new运算符用于动态内存的分配，delete运算符用于动态内存的释放。
C语言:
      int *p = (int*)malloc(sizeof(int));
      *p = 100;
      free(p);
C++:
      int *p = new int(200);
      //*p = 200;
      delete  p;

     int* pa = new int[10];
     pa[0] = 10;
     pa[1] = 20;
     ....
     delete[] pa;

十、C++的引用（Reference）
1 定义
   引用就是某个变量的别名，对引用的操作与对该变量操作完全相同。
   int a = 10；
   int& b = a；//b就是a的别名
   b++；//等价于a++
   cout  <<  a  << endl;//11

2 常引用
1）定义引用时加const修饰，即为常引用，不能通过常引用修改引用的目标。
int a = 100;
const  int&  b = a;//b就是常引用
a = 200；//ok
b = 200;  //error
2）普通的引用只能引用左值，常引用既可以引用左值也可以引用右值。
int& b = a;//ok,a是左值
int& b = 10;//error,字面值常量10是右值
const int& r = a；//ok
const int& r = 10;//ok
3）关于左值和右值
左值：可以放在赋值运算符的左边，可以修改，可以被取地址。
    int i;
    i = 10;
    ++i;
    int* p = &i;
右值：只能放在赋值运算符右边的、不可以被修改，不可以被取地址。
   字面值都是右值：
	10 = i; --10;int* p = &10;//error
表达式值多为右值：
	a + b = c；//error
	(a + b)++;//error
                 int* p = &(a+b);//error
函数的返回值：
	int func(void){
	     int a=100;
	     return a;	
	}
	int main(){
	     int res = func();
                      func() = 10;//error
	    ++func();//error
                      int* p = &func(); //error
	}

2 引用型函数参数
1）引用用于函数的参数，可以修改实参的值，可以减小函数调用的开销，避免虚实结合过程中对实参的复制。
2）引用参数可能意外修改实参的值，如果不希望修改实参本身，可以将形参定义为常引用，提高传参的效率同时还可以接收常量型的实参。

















