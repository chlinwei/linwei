十三 类的定义与实例化
1
2
3 构造函数（Constructors）
类名(构造形参表)[:初始化表]{
     //构造函数体;
}
1）构造函数名与类名相同，且没有返回类型
2）构造函数在对象创建时自动被调用
3）构造函数负责确定对象初始化状态以及分配必要的内存
4）构造函数在每个对象的整个声明周期内，一定会被调用，且仅会被调用一次。

4 对象的创建和销毁
1）在栈中创建单个对象
类名 对象(构造实参表)；
类名 对象 = 类名(构造实参表)；

2）在栈中创建多个对象
类名 对象数组[元素个数] = {类名(构造实参表),...}

3) 在堆中创建/销毁单个对象
创建:
     类型* 对象指针 = new 类名(构造实参表)；
销毁：
    delete 对象指针
4）在队中创建/销毁多个对象
创建：
    //这种初始化的写法，只在c++2011支持
    类名* 对象指针 = new 类名[元素个数]{类名(参数),...}
销毁：
    delete[]  对象指针

5 类的声明和定义可以分别放在不用的文件中
类声明部分放在xx.h
类实现部分放在xx.cpp
使用该类的代码通过在其它的XX.cpp中

===========
实现一个电子时钟类，要求用构造接收当前的系统时间，以秒为单位运行。
1）属性：时、分、秒
2）行为：
构造函数初始化时间
    time_t  t = time(NULL);
    tm* local=localtime(&t);
    local->tm_hour;
    local->tm_min;
    local->tm_sec;
成员函数运行时钟，
    while(1){
         //打印时间；
         //计时：时间+1秒
    }；

十四 构造函数和初始化表
1 构造函数重载
  构造函数通过参数表的差别化形成重载，创建对象通过构造实参选择匹配，表示不同对象的创建方式。

2 缺省构造函数
如果一个类没有定义构造函数，编译器会提供一个缺省构造函数(无参构造函数)，使成员变量获得定义。
1)对于基本类型的成员变量不初始化
2)对类 类型的成员 变量，调用相应类型的无参构造函数。
3)如果定义了构造函数，无论是否有参数，编译器都不会再提供无参构造函数。

3 类型转换构造函数(单参构造函数)
class 目标类型{
     目标类名(源类型  src){...}
};
使用explicit关键字修饰类型转换构造函数，可以强制这种转换必须显示地进行。

4 拷贝构造函数
类名 (const 类名& that){...}
1）用一个已经存在的对象构造同类型的副本对象时，会调用该类的拷贝构造函数
class A{..};
A a1;//无参方式构造
A a2=a1;//拷贝方式构造

2）如果一个类没有定义拷贝构造函数，那么编译器会为其提供一个缺省拷贝构造函数
 a，对基本类型的成员变量，按字节复制
 b，对类类型的成员变量(成员子对象),调用相应类型的拷贝构造函数。

3）如果自己定义拷贝构造函数，编译器将不再提供缺省拷贝构造函数，这时要实现成员复制有关操作，必须在自己
定义的拷贝构造函数中编码完成。

4）拷贝构造函数调用时机
 a.用已经定义对象作为同类型对象的构造实参
 b.以对象的形式向函数传递参数。
 c.从函数中返回对象(有时会被编译器优化掉)
   
























































