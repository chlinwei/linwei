				左移<<:不会改变操作数的符号位,左移以0来填充空位

1正数的源码,反码,补码都是一样
2负数的源码为取其绝对值的源码,符号位为1,反码为符号位不变,其余位取反,
补码为取反后的结果+1

2左移5位
2在是正数在内存中以源码保存
00000000 00000000 00000000 00000010
左移5位后
00000000 00000000 00000000 01000000,十进制是2^6 = 64
符号位为第32位,0则为正数,而且本身左移也不会改变操作数的符号位


-2左移5位
-2左移肯定是负数,左移不会改变操作数的符号位
-2是负数,在内存中以补码方式保存,要左移,首先
得知道-2的补码
1.求-2的补码
1)去掉负号,求2的源码
10000000 00000000 00000000 00000010(源码,符号位为1)
2)取反+1,得到补码(除了符号为以外的取反)
11111111 11111111 11111111 11111101(反码)
11111111 11111111 11111111 11111110(补码)
3)补码左移5位
11111111 11111111 11111111 11000000(补码),此时得到了左移后的补码
4)转化为十进制:补码取反+1,得到的结果前面添加负号就行了
00000000 00000000 00000000 00111111(取反)
00000000 00000000 00000000 01000000(然后加1),64添加负号就行了



				    有符号右移 >> 左边的空位根据符号位来填充(即正数以0来填充,负数以1来填充)

-64右移5位 ,-64 >> 5;
首先-64在内存中是以补码的形式保存
1).-64的源码
10000000 00000000 00000000 01000000;(源码)
2)反码
1111111  11111111 11111111 10111111;(反码,符号位不变,其余位取反)
3)补码
11111111 11111111 11111111 11000000;(补码,反码+1后的结果)
4)反码右移的结果
11111111 11111111 11111111 111111100;(新的补码,由于符号位是1,判断是负数)
5)求上述的反码(符号位不变,其余位取反)
10000000 00000000 00000000 000000001;(反码)
6)去上述反码的源码,+1
10000000 00000000 00000000 000000010;(源码),符号不管,转成十进制为2加上符号为-2

		                  无符号右移动 >>>
-64 >>> 5
1.求-64的源码
10000000 00000000 00000000 01000000(源码)
2.求-64的反码(符号位不变)
11111111 11111111 11111111 10111111(反码)
3.求-64的补码(反码+1就ok了)
11111111 11111111 11111111 11000000(反码)
4.补码右移,无符号右移,空位由0来填充(得到的是补码,补码移动后还是补码)
00000111 11111111 11111111 11111110(补码,根据符号位可知为正数)
